"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@neynar";
exports.ids = ["vendor-chunks/@neynar"];
exports.modules = {

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/action-api.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/action-api.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionApi = exports.ActionApiFactory = exports.ActionApiFp = exports.ActionApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * ActionApi - axios parameter creator\n * @export\n */\nconst ActionApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\\'s Farcaster signer.\n         * @summary User actions across apps\n         * @param {FarcasterActionReqBody} farcasterActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)\n         *\n         */\n        publishFarcasterAction: async (farcasterActionReqBody, options = {}) => {\n            // verify required parameter 'farcasterActionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishFarcasterAction', 'farcasterActionReqBody', farcasterActionReqBody);\n            const localVarPath = `/farcaster/action`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(farcasterActionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ActionApiAxiosParamCreator = ActionApiAxiosParamCreator;\n/**\n * ActionApi - functional programming interface\n * @export\n */\nconst ActionApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ActionApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\\'s Farcaster signer.\n         * @summary User actions across apps\n         * @param {FarcasterActionReqBody} farcasterActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)\n         *\n         */\n        async publishFarcasterAction(farcasterActionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFarcasterAction(farcasterActionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ActionApi.publishFarcasterAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ActionApiFp = ActionApiFp;\n/**\n * ActionApi - factory interface\n * @export\n */\nconst ActionApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ActionApiFp)(configuration);\n    return {\n        /**\n         * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\\'s Farcaster signer.\n         * @summary User actions across apps\n         * @param {ActionApiPublishFarcasterActionRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)\n         *\n         */\n        publishFarcasterAction(requestParameters, options) {\n            return localVarFp.publishFarcasterAction(requestParameters.farcasterActionReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ActionApiFactory = ActionApiFactory;\n/**\n * ActionApi - object-oriented interface\n * @export\n * @class ActionApi\n * @extends {BaseAPI}\n */\nclass ActionApi extends base_1.BaseAPI {\n    /**\n     * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\\'s Farcaster signer.\n     * @summary User actions across apps\n     * @param {ActionApiPublishFarcasterActionRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ActionApi\n     * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)\n     *\n     */\n    publishFarcasterAction(requestParameters, options) {\n        return (0, exports.ActionApiFp)(this.configuration).publishFarcasterAction(requestParameters.farcasterActionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ActionApi = ActionApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2FjdGlvbi1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtDQUFrQztBQUN2RyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsMEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLFVBQVUscUJBQXFCLEdBQUcsZ0NBQWdDLHFCQUFxQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixVQUFVLHFCQUFxQixHQUFHLGdDQUFnQyxxQkFBcUI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0QsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixVQUFVLHFCQUFxQixHQUFHLGdDQUFnQyxxQkFBcUI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsVUFBVSxxQkFBcUIsR0FBRyxnQ0FBZ0MscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvYXBpL2FwaXMvYWN0aW9uLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWN0aW9uQXBpID0gZXhwb3J0cy5BY3Rpb25BcGlGYWN0b3J5ID0gZXhwb3J0cy5BY3Rpb25BcGlGcCA9IGV4cG9ydHMuQWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBBY3Rpb25BcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBBY3Rpb25BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlY3VyZWx5IGNvbW11bmljYXRlIGFuZCBwZXJmb3JtIGFjdGlvbnMgb24gYmVoYWxmIG9mIHVzZXJzIGFjcm9zcyBkaWZmZXJlbnQgYXBwcy4gSXQgZW5hYmxlcyBhbiBhcHAgdG8gc2VuZCBkYXRhIG9yIHRyaWdnZXIgYWN0aW9ucyBpbiBhbm90aGVyIGFwcCBvbiBiZWhhbGYgb2YgYSBtdXR1YWwgdXNlciBieSBzaWduaW5nIG1lc3NhZ2VzIHVzaW5nIHRoZSB1c2VyXFwncyBGYXJjYXN0ZXIgc2lnbmVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBVc2VyIGFjdGlvbnMgYWNyb3NzIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtGYXJjYXN0ZXJBY3Rpb25SZXFCb2R5fSBmYXJjYXN0ZXJBY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgW2tleTogc3RyaW5nXTogYW55OyB9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgeyBba2V5OiBzdHJpbmddOiBhbnk7IH1gIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vZG9jcy9mYXJjYXN0ZXItYWN0aW9ucy1zcGVjKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaEZhcmNhc3RlckFjdGlvbjogYXN5bmMgKGZhcmNhc3RlckFjdGlvblJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmFyY2FzdGVyQWN0aW9uUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdwdWJsaXNoRmFyY2FzdGVyQWN0aW9uJywgJ2ZhcmNhc3RlckFjdGlvblJlcUJvZHknLCBmYXJjYXN0ZXJBY3Rpb25SZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2FjdGlvbmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGZhcmNhc3RlckFjdGlvblJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBBY3Rpb25BcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQWN0aW9uQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQWN0aW9uQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5BY3Rpb25BcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlY3VyZWx5IGNvbW11bmljYXRlIGFuZCBwZXJmb3JtIGFjdGlvbnMgb24gYmVoYWxmIG9mIHVzZXJzIGFjcm9zcyBkaWZmZXJlbnQgYXBwcy4gSXQgZW5hYmxlcyBhbiBhcHAgdG8gc2VuZCBkYXRhIG9yIHRyaWdnZXIgYWN0aW9ucyBpbiBhbm90aGVyIGFwcCBvbiBiZWhhbGYgb2YgYSBtdXR1YWwgdXNlciBieSBzaWduaW5nIG1lc3NhZ2VzIHVzaW5nIHRoZSB1c2VyXFwncyBGYXJjYXN0ZXIgc2lnbmVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBVc2VyIGFjdGlvbnMgYWNyb3NzIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtGYXJjYXN0ZXJBY3Rpb25SZXFCb2R5fSBmYXJjYXN0ZXJBY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgW2tleTogc3RyaW5nXTogYW55OyB9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgeyBba2V5OiBzdHJpbmddOiBhbnk7IH1gIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vZG9jcy9mYXJjYXN0ZXItYWN0aW9ucy1zcGVjKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHVibGlzaEZhcmNhc3RlckFjdGlvbihmYXJjYXN0ZXJBY3Rpb25SZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5wdWJsaXNoRmFyY2FzdGVyQWN0aW9uKGZhcmNhc3RlckFjdGlvblJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBY3Rpb25BcGkucHVibGlzaEZhcmNhc3RlckFjdGlvbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BY3Rpb25BcGlGcCA9IEFjdGlvbkFwaUZwO1xuLyoqXG4gKiBBY3Rpb25BcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBY3Rpb25BcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5BY3Rpb25BcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlY3VyZWx5IGNvbW11bmljYXRlIGFuZCBwZXJmb3JtIGFjdGlvbnMgb24gYmVoYWxmIG9mIHVzZXJzIGFjcm9zcyBkaWZmZXJlbnQgYXBwcy4gSXQgZW5hYmxlcyBhbiBhcHAgdG8gc2VuZCBkYXRhIG9yIHRyaWdnZXIgYWN0aW9ucyBpbiBhbm90aGVyIGFwcCBvbiBiZWhhbGYgb2YgYSBtdXR1YWwgdXNlciBieSBzaWduaW5nIG1lc3NhZ2VzIHVzaW5nIHRoZSB1c2VyXFwncyBGYXJjYXN0ZXIgc2lnbmVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBVc2VyIGFjdGlvbnMgYWNyb3NzIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtBY3Rpb25BcGlQdWJsaXNoRmFyY2FzdGVyQWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IFtrZXk6IHN0cmluZ106IGFueTsgfT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYHsgW2tleTogc3RyaW5nXTogYW55OyB9YCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmFyY2FzdGVyLWFjdGlvbnMtc3BlYylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hGYXJjYXN0ZXJBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnB1Ymxpc2hGYXJjYXN0ZXJBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMuZmFyY2FzdGVyQWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQWN0aW9uQXBpRmFjdG9yeSA9IEFjdGlvbkFwaUZhY3Rvcnk7XG4vKipcbiAqIEFjdGlvbkFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBBY3Rpb25BcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBBY3Rpb25BcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogU2VjdXJlbHkgY29tbXVuaWNhdGUgYW5kIHBlcmZvcm0gYWN0aW9ucyBvbiBiZWhhbGYgb2YgdXNlcnMgYWNyb3NzIGRpZmZlcmVudCBhcHBzLiBJdCBlbmFibGVzIGFuIGFwcCB0byBzZW5kIGRhdGEgb3IgdHJpZ2dlciBhY3Rpb25zIGluIGFub3RoZXIgYXBwIG9uIGJlaGFsZiBvZiBhIG11dHVhbCB1c2VyIGJ5IHNpZ25pbmcgbWVzc2FnZXMgdXNpbmcgdGhlIHVzZXJcXCdzIEZhcmNhc3RlciBzaWduZXIuXG4gICAgICogQHN1bW1hcnkgVXNlciBhY3Rpb25zIGFjcm9zcyBhcHBzXG4gICAgICogQHBhcmFtIHtBY3Rpb25BcGlQdWJsaXNoRmFyY2FzdGVyQWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWN0aW9uQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8eyBba2V5OiBzdHJpbmddOiBhbnk7IH0+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB7IFtrZXk6IHN0cmluZ106IGFueTsgfWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vZG9jcy9mYXJjYXN0ZXItYWN0aW9ucy1zcGVjKVxuICAgICAqXG4gICAgICovXG4gICAgcHVibGlzaEZhcmNhc3RlckFjdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWN0aW9uQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaEZhcmNhc3RlckFjdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5mYXJjYXN0ZXJBY3Rpb25SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkFjdGlvbkFwaSA9IEFjdGlvbkFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/action-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/agents-api.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/agents-api.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AgentsApi = exports.AgentsApiFactory = exports.AgentsApiFp = exports.AgentsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * AgentsApi - axios parameter creator\n * @export\n */\nconst AgentsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Creates a new transaction pay mini app that can be used to collect payments through a mini app\n         * @summary Create transaction pay mini app\n         * @param {FramePayTransactionRequestBody} framePayTransactionRequestBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        createTransactionPayFrame: async (framePayTransactionRequestBody, options = {}) => {\n            // verify required parameter 'framePayTransactionRequestBody' is not null or undefined\n            (0, common_1.assertParamExists)('createTransactionPayFrame', 'framePayTransactionRequestBody', framePayTransactionRequestBody);\n            const localVarPath = `/farcaster/frame/transaction/pay`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(framePayTransactionRequestBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of interactions between two users\n         * @summary User interactions\n         * @param {string} fids Comma separated list of two FIDs\n         * @param {Array<NotificationType>} [type] Comma seperated list of Interaction type to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object\n         *\n         */\n        fetchUserInteractions: async (fids, type, options = {}) => {\n            // verify required parameter 'fids' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserInteractions', 'fids', fids);\n            const localVarPath = `/farcaster/user/interactions`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fids !== undefined) {\n                localVarQueryParameter['fids'] = fids;\n            }\n            if (type) {\n                localVarQueryParameter['type'] = type.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.\n         * @summary Cast conversation summary\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {number} [limit] Number of casts to consider in a summary up to a point of target cast  (Default: 20, Maximum: 50)\n         * @param {string} [prompt] Additional prompt used to generate a summary\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)\n         *\n         */\n        lookupCastConversationSummary: async (identifier, limit, prompt, options = {}) => {\n            // verify required parameter 'identifier' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastConversationSummary', 'identifier', identifier);\n            const localVarPath = `/farcaster/cast/conversation/summary`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (identifier !== undefined) {\n                localVarQueryParameter['identifier'] = identifier;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (prompt !== undefined) {\n                localVarQueryParameter['prompt'] = prompt;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AgentsApiAxiosParamCreator = AgentsApiAxiosParamCreator;\n/**\n * AgentsApi - functional programming interface\n * @export\n */\nconst AgentsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AgentsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Creates a new transaction pay mini app that can be used to collect payments through a mini app\n         * @summary Create transaction pay mini app\n         * @param {FramePayTransactionRequestBody} framePayTransactionRequestBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        async createTransactionPayFrame(framePayTransactionRequestBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionPayFrame(framePayTransactionRequestBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.createTransactionPayFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of interactions between two users\n         * @summary User interactions\n         * @param {string} fids Comma separated list of two FIDs\n         * @param {Array<NotificationType>} [type] Comma seperated list of Interaction type to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object\n         *\n         */\n        async fetchUserInteractions(fids, type, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserInteractions(fids, type, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.fetchUserInteractions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.\n         * @summary Cast conversation summary\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {number} [limit] Number of casts to consider in a summary up to a point of target cast  (Default: 20, Maximum: 50)\n         * @param {string} [prompt] Additional prompt used to generate a summary\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)\n         *\n         */\n        async lookupCastConversationSummary(identifier, limit, prompt, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupCastConversationSummary(identifier, limit, prompt, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AgentsApi.lookupCastConversationSummary']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AgentsApiFp = AgentsApiFp;\n/**\n * AgentsApi - factory interface\n * @export\n */\nconst AgentsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AgentsApiFp)(configuration);\n    return {\n        /**\n         * Creates a new transaction pay mini app that can be used to collect payments through a mini app\n         * @summary Create transaction pay mini app\n         * @param {AgentsApiCreateTransactionPayFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        createTransactionPayFrame(requestParameters, options) {\n            return localVarFp.createTransactionPayFrame(requestParameters.framePayTransactionRequestBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of interactions between two users\n         * @summary User interactions\n         * @param {AgentsApiFetchUserInteractionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object\n         *\n         */\n        fetchUserInteractions(requestParameters, options) {\n            return localVarFp.fetchUserInteractions(requestParameters.fids, requestParameters.type, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.\n         * @summary Cast conversation summary\n         * @param {AgentsApiLookupCastConversationSummaryRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)\n         *\n         */\n        lookupCastConversationSummary(requestParameters, options) {\n            return localVarFp.lookupCastConversationSummary(requestParameters.identifier, requestParameters.limit, requestParameters.prompt, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AgentsApiFactory = AgentsApiFactory;\n/**\n * AgentsApi - object-oriented interface\n * @export\n * @class AgentsApi\n * @extends {BaseAPI}\n */\nclass AgentsApi extends base_1.BaseAPI {\n    /**\n     * Creates a new transaction pay mini app that can be used to collect payments through a mini app\n     * @summary Create transaction pay mini app\n     * @param {AgentsApiCreateTransactionPayFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AgentsApi\n     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n     *\n     */\n    createTransactionPayFrame(requestParameters, options) {\n        return (0, exports.AgentsApiFp)(this.configuration).createTransactionPayFrame(requestParameters.framePayTransactionRequestBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of interactions between two users\n     * @summary User interactions\n     * @param {AgentsApiFetchUserInteractionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AgentsApi\n     * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object\n     *\n     */\n    fetchUserInteractions(requestParameters, options) {\n        return (0, exports.AgentsApiFp)(this.configuration).fetchUserInteractions(requestParameters.fids, requestParameters.type, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.\n     * @summary Cast conversation summary\n     * @param {AgentsApiLookupCastConversationSummaryRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AgentsApi\n     * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)\n     *\n     */\n    lookupCastConversationSummary(requestParameters, options) {\n        return (0, exports.AgentsApiFp)(this.configuration).lookupCastConversationSummary(requestParameters.identifier, requestParameters.limit, requestParameters.prompt, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AgentsApi = AgentsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2FnZW50cy1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtDQUFrQztBQUN2RyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsMEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnQkFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIseUJBQXlCO0FBQzVDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsMkNBQTJDO0FBQ2hFO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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IExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9hZ2VudHMtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZ2VudHNBcGkgPSBleHBvcnRzLkFnZW50c0FwaUZhY3RvcnkgPSBleHBvcnRzLkFnZW50c0FwaUZwID0gZXhwb3J0cy5BZ2VudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEFnZW50c0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFnZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiBwYXkgbWluaSBhcHAgdGhhdCBjYW4gYmUgdXNlZCB0byBjb2xsZWN0IHBheW1lbnRzIHRocm91Z2ggYSBtaW5pIGFwcFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5fSBmcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWU6IGFzeW5jIChmcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWUnLCAnZnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5JywgZnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lL3RyYW5zYWN0aW9uL3BheWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGZyYW1lUGF5VHJhbnNhY3Rpb25SZXF1ZXN0Qm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgaW50ZXJhY3Rpb25zIGJldHdlZW4gdHdvIHVzZXJzXG4gICAgICAgICAqIEBzdW1tYXJ5IFVzZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWRzIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHR3byBGSURzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm90aWZpY2F0aW9uVHlwZT59IFt0eXBlXSBDb21tYSBzZXBlcmF0ZWQgbGlzdCBvZiBJbnRlcmFjdGlvbiB0eXBlIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckludGVyYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VySW50ZXJhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VySW50ZXJhY3Rpb25zOiBhc3luYyAoZmlkcywgdHlwZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWRzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlckludGVyYWN0aW9ucycsICdmaWRzJywgZmlkcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2ludGVyYWN0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWRzJ10gPSBmaWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0eXBlJ10gPSB0eXBlLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGEgc3VtbWFyeSBvZiBhbGwgY2FzdHMgcmVsYXRlZCB0byBhIGNvbnZlcnNhdGlvbiBzdXJyb3VuZGluZyBhIGNhc3QgYnkgcGFzc2luZyBpbiBhIGNhc3QgaGFzaCBvciBGYXJjYXN0ZXIgVVJMLiAgU3VtbWFyeSBpcyBnZW5lcmF0ZWQgYnkgYW4gTExNIGFuZCBpcyBpbnRlbmRlZCB0byBiZSBwYXNzZWQgYXMgYSBjb250ZXh0IHRvIEFJIGFnZW50cy5cbiAgICAgICAgICogQHN1bW1hcnkgQ2FzdCBjb252ZXJzYXRpb24gc3VtbWFyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBDYXN0IGlkZW50aWZpZXIgKEl0cyBlaXRoZXIgYSB1cmwgb3IgYSBoYXNoKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgY2FzdHMgdG8gY29uc2lkZXIgaW4gYSBzdW1tYXJ5IHVwIHRvIGEgcG9pbnQgb2YgdGFyZ2V0IGNhc3QgIChEZWZhdWx0OiAyMCwgTWF4aW11bTogNTApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvbXB0XSBBZGRpdGlvbmFsIHByb21wdCB1c2VkIHRvIGdlbmVyYXRlIGEgc3VtbWFyeVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb252ZXJzYXRpb25TdW1tYXJ5Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ29udmVyc2F0aW9uU3VtbWFyeWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtY29udmVyc2F0aW9uLXN1bW1hcnkpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBDYXN0Q29udmVyc2F0aW9uU3VtbWFyeTogYXN5bmMgKGlkZW50aWZpZXIsIGxpbWl0LCBwcm9tcHQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaWRlbnRpZmllcicgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBDYXN0Q29udmVyc2F0aW9uU3VtbWFyeScsICdpZGVudGlmaWVyJywgaWRlbnRpZmllcik7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jYXN0L2NvbnZlcnNhdGlvbi9zdW1tYXJ5YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2lkZW50aWZpZXInXSA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9tcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3Byb21wdCddID0gcHJvbXB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZ2VudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEFnZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBBZ2VudHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZ2VudHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkFnZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiBwYXkgbWluaSBhcHAgdGhhdCBjYW4gYmUgdXNlZCB0byBjb2xsZWN0IHBheW1lbnRzIHRocm91Z2ggYSBtaW5pIGFwcFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5fSBmcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWUoZnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVUcmFuc2FjdGlvblBheUZyYW1lKGZyYW1lUGF5VHJhbnNhY3Rpb25SZXF1ZXN0Qm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FnZW50c0FwaS5jcmVhdGVUcmFuc2FjdGlvblBheUZyYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBpbnRlcmFjdGlvbnMgYmV0d2VlbiB0d28gdXNlcnNcbiAgICAgICAgICogQHN1bW1hcnkgVXNlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZHMgQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgdHdvIEZJRHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb3RpZmljYXRpb25UeXBlPn0gW3R5cGVdIENvbW1hIHNlcGVyYXRlZCBsaXN0IG9mIEludGVyYWN0aW9uIHR5cGUgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VySW50ZXJhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJJbnRlcmFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJJbnRlcmFjdGlvbnMoZmlkcywgdHlwZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2VySW50ZXJhY3Rpb25zKGZpZHMsIHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZ2VudHNBcGkuZmV0Y2hVc2VySW50ZXJhY3Rpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgYSBzdW1tYXJ5IG9mIGFsbCBjYXN0cyByZWxhdGVkIHRvIGEgY29udmVyc2F0aW9uIHN1cnJvdW5kaW5nIGEgY2FzdCBieSBwYXNzaW5nIGluIGEgY2FzdCBoYXNoIG9yIEZhcmNhc3RlciBVUkwuICBTdW1tYXJ5IGlzIGdlbmVyYXRlZCBieSBhbiBMTE0gYW5kIGlzIGludGVuZGVkIHRvIGJlIHBhc3NlZCBhcyBhIGNvbnRleHQgdG8gQUkgYWdlbnRzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDYXN0IGNvbnZlcnNhdGlvbiBzdW1tYXJ5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIENhc3QgaWRlbnRpZmllciAoSXRzIGVpdGhlciBhIHVybCBvciBhIGhhc2gpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiBjYXN0cyB0byBjb25zaWRlciBpbiBhIHN1bW1hcnkgdXAgdG8gYSBwb2ludCBvZiB0YXJnZXQgY2FzdCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiA1MClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcm9tcHRdIEFkZGl0aW9uYWwgcHJvbXB0IHVzZWQgdG8gZ2VuZXJhdGUgYSBzdW1tYXJ5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnZlcnNhdGlvblN1bW1hcnk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDb252ZXJzYXRpb25TdW1tYXJ5YCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2FzdC1jb252ZXJzYXRpb24tc3VtbWFyeSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cENhc3RDb252ZXJzYXRpb25TdW1tYXJ5KGlkZW50aWZpZXIsIGxpbWl0LCBwcm9tcHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cENhc3RDb252ZXJzYXRpb25TdW1tYXJ5KGlkZW50aWZpZXIsIGxpbWl0LCBwcm9tcHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZ2VudHNBcGkubG9va3VwQ2FzdENvbnZlcnNhdGlvblN1bW1hcnknXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQWdlbnRzQXBpRnAgPSBBZ2VudHNBcGlGcDtcbi8qKlxuICogQWdlbnRzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQWdlbnRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQWdlbnRzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbGxlY3QgcGF5bWVudHMgdGhyb3VnaCBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSB0cmFuc2FjdGlvbiBwYXkgbWluaSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtBZ2VudHNBcGlDcmVhdGVUcmFuc2FjdGlvblBheUZyYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbkZyYW1lUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmFuc2FjdGlvbkZyYW1lUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb25QYXlGcmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlVHJhbnNhY3Rpb25QYXlGcmFtZShyZXF1ZXN0UGFyYW1ldGVycy5mcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBpbnRlcmFjdGlvbnMgYmV0d2VlbiB0d28gdXNlcnNcbiAgICAgICAgICogQHN1bW1hcnkgVXNlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtBZ2VudHNBcGlGZXRjaFVzZXJJbnRlcmFjdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckludGVyYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VySW50ZXJhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VySW50ZXJhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJJbnRlcmFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkcywgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhIHN1bW1hcnkgb2YgYWxsIGNhc3RzIHJlbGF0ZWQgdG8gYSBjb252ZXJzYXRpb24gc3Vycm91bmRpbmcgYSBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBjYXN0IGhhc2ggb3IgRmFyY2FzdGVyIFVSTC4gIFN1bW1hcnkgaXMgZ2VuZXJhdGVkIGJ5IGFuIExMTSBhbmQgaXMgaW50ZW5kZWQgdG8gYmUgcGFzc2VkIGFzIGEgY29udGV4dCB0byBBSSBhZ2VudHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IENhc3QgY29udmVyc2F0aW9uIHN1bW1hcnlcbiAgICAgICAgICogQHBhcmFtIHtBZ2VudHNBcGlMb29rdXBDYXN0Q29udmVyc2F0aW9uU3VtbWFyeVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q29udmVyc2F0aW9uU3VtbWFyeT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENvbnZlcnNhdGlvblN1bW1hcnlgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWNvbnZlcnNhdGlvbi1zdW1tYXJ5KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2FzdENvbnZlcnNhdGlvblN1bW1hcnkocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cENhc3RDb252ZXJzYXRpb25TdW1tYXJ5KHJlcXVlc3RQYXJhbWV0ZXJzLmlkZW50aWZpZXIsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5wcm9tcHQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFnZW50c0FwaUZhY3RvcnkgPSBBZ2VudHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBBZ2VudHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQWdlbnRzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQWdlbnRzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29sbGVjdCBwYXltZW50cyB0aHJvdWdoIGEgbWluaSBhcHBcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICogQHBhcmFtIHtBZ2VudHNBcGlDcmVhdGVUcmFuc2FjdGlvblBheUZyYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWdlbnRzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFnZW50c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWUocmVxdWVzdFBhcmFtZXRlcnMuZnJhbWVQYXlUcmFuc2FjdGlvblJlcXVlc3RCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgaW50ZXJhY3Rpb25zIGJldHdlZW4gdHdvIHVzZXJzXG4gICAgICogQHN1bW1hcnkgVXNlciBpbnRlcmFjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FnZW50c0FwaUZldGNoVXNlckludGVyYWN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFnZW50c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckludGVyYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VySW50ZXJhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VySW50ZXJhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZ2VudHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJJbnRlcmFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkcywgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN1bW1hcnkgb2YgYWxsIGNhc3RzIHJlbGF0ZWQgdG8gYSBjb252ZXJzYXRpb24gc3Vycm91bmRpbmcgYSBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBjYXN0IGhhc2ggb3IgRmFyY2FzdGVyIFVSTC4gIFN1bW1hcnkgaXMgZ2VuZXJhdGVkIGJ5IGFuIExMTSBhbmQgaXMgaW50ZW5kZWQgdG8gYmUgcGFzc2VkIGFzIGEgY29udGV4dCB0byBBSSBhZ2VudHMuXG4gICAgICogQHN1bW1hcnkgQ2FzdCBjb252ZXJzYXRpb24gc3VtbWFyeVxuICAgICAqIEBwYXJhbSB7QWdlbnRzQXBpTG9va3VwQ2FzdENvbnZlcnNhdGlvblN1bW1hcnlSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZ2VudHNBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb252ZXJzYXRpb25TdW1tYXJ5Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ29udmVyc2F0aW9uU3VtbWFyeWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWNvbnZlcnNhdGlvbi1zdW1tYXJ5KVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwQ2FzdENvbnZlcnNhdGlvblN1bW1hcnkocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFnZW50c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cENhc3RDb252ZXJzYXRpb25TdW1tYXJ5KHJlcXVlc3RQYXJhbWV0ZXJzLmlkZW50aWZpZXIsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5wcm9tcHQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWdlbnRzQXBpID0gQWdlbnRzQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/agents-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/app-host-api.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/app-host-api.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppHostApi = exports.AppHostApiFactory = exports.AppHostApiFp = exports.AppHostApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * AppHostApi - axios parameter creator\n * @export\n */\nconst AppHostApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Returns event object for app host events. Used if the app host intends to sign the event message instead of using Neynar-hosted signers.\n         * @summary Get app host event\n         * @param {string} appDomain The domain of the mini app\n         * @param {number} fid The FID of the user who initiated the event\n         * @param {AppHostEventType} event The type of event\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostGetEventResponse>} A promise that resolves to a `AppHostGetEventResponse` object\n         *\n         */\n        appHostGetEvent: async (appDomain, fid, event, options = {}) => {\n            // verify required parameter 'appDomain' is not null or undefined\n            (0, common_1.assertParamExists)('appHostGetEvent', 'appDomain', appDomain);\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('appHostGetEvent', 'fid', fid);\n            // verify required parameter 'event' is not null or undefined\n            (0, common_1.assertParamExists)('appHostGetEvent', 'event', event);\n            const localVarPath = `/farcaster/app_host/user/event`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (appDomain !== undefined) {\n                localVarQueryParameter['app_domain'] = appDomain;\n            }\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (event !== undefined) {\n                localVarQueryParameter['event'] = event;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns the current notification state for a specific user across all mini app domains in this app host. Shows which domains have notifications enabled.\n         * @summary Get the user\\'s notification subscriptions\n         * @param {number} fid The FID of the user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostUserStateResponse>} A promise that resolves to a `AppHostUserStateResponse` object\n         *\n         */\n        appHostGetUserState: async (fid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('appHostGetUserState', 'fid', fid);\n            const localVarPath = `/farcaster/app_host/user/state`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Post an app_host event to the domain\\'s webhook. Events such as enabling or disabling notifications for a user. Provide either a signed message or the signer UUID of an authorized neynar-hosted signers.\n         * @summary Process app host event\n         * @param {AppHostPostEventBody} appHostPostEventBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostPostEventResponse>} A promise that resolves to a `AppHostPostEventResponse` object\n         *\n         */\n        appHostPostEvent: async (appHostPostEventBody, options = {}) => {\n            // verify required parameter 'appHostPostEventBody' is not null or undefined\n            (0, common_1.assertParamExists)('appHostPostEvent', 'appHostPostEventBody', appHostPostEventBody);\n            const localVarPath = `/farcaster/app_host/user/event`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(appHostPostEventBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AppHostApiAxiosParamCreator = AppHostApiAxiosParamCreator;\n/**\n * AppHostApi - functional programming interface\n * @export\n */\nconst AppHostApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AppHostApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Returns event object for app host events. Used if the app host intends to sign the event message instead of using Neynar-hosted signers.\n         * @summary Get app host event\n         * @param {string} appDomain The domain of the mini app\n         * @param {number} fid The FID of the user who initiated the event\n         * @param {AppHostEventType} event The type of event\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostGetEventResponse>} A promise that resolves to a `AppHostGetEventResponse` object\n         *\n         */\n        async appHostGetEvent(appDomain, fid, event, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.appHostGetEvent(appDomain, fid, event, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AppHostApi.appHostGetEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns the current notification state for a specific user across all mini app domains in this app host. Shows which domains have notifications enabled.\n         * @summary Get the user\\'s notification subscriptions\n         * @param {number} fid The FID of the user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostUserStateResponse>} A promise that resolves to a `AppHostUserStateResponse` object\n         *\n         */\n        async appHostGetUserState(fid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.appHostGetUserState(fid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AppHostApi.appHostGetUserState']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Post an app_host event to the domain\\'s webhook. Events such as enabling or disabling notifications for a user. Provide either a signed message or the signer UUID of an authorized neynar-hosted signers.\n         * @summary Process app host event\n         * @param {AppHostPostEventBody} appHostPostEventBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostPostEventResponse>} A promise that resolves to a `AppHostPostEventResponse` object\n         *\n         */\n        async appHostPostEvent(appHostPostEventBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.appHostPostEvent(appHostPostEventBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AppHostApi.appHostPostEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AppHostApiFp = AppHostApiFp;\n/**\n * AppHostApi - factory interface\n * @export\n */\nconst AppHostApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AppHostApiFp)(configuration);\n    return {\n        /**\n         * Returns event object for app host events. Used if the app host intends to sign the event message instead of using Neynar-hosted signers.\n         * @summary Get app host event\n         * @param {AppHostApiAppHostGetEventRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostGetEventResponse>} A promise that resolves to a `AppHostGetEventResponse` object\n         *\n         */\n        appHostGetEvent(requestParameters, options) {\n            return localVarFp.appHostGetEvent(requestParameters.appDomain, requestParameters.fid, requestParameters.event, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns the current notification state for a specific user across all mini app domains in this app host. Shows which domains have notifications enabled.\n         * @summary Get the user\\'s notification subscriptions\n         * @param {AppHostApiAppHostGetUserStateRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostUserStateResponse>} A promise that resolves to a `AppHostUserStateResponse` object\n         *\n         */\n        appHostGetUserState(requestParameters, options) {\n            return localVarFp.appHostGetUserState(requestParameters.fid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Post an app_host event to the domain\\'s webhook. Events such as enabling or disabling notifications for a user. Provide either a signed message or the signer UUID of an authorized neynar-hosted signers.\n         * @summary Process app host event\n         * @param {AppHostApiAppHostPostEventRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AppHostPostEventResponse>} A promise that resolves to a `AppHostPostEventResponse` object\n         *\n         */\n        appHostPostEvent(requestParameters, options) {\n            return localVarFp.appHostPostEvent(requestParameters.appHostPostEventBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AppHostApiFactory = AppHostApiFactory;\n/**\n * AppHostApi - object-oriented interface\n * @export\n * @class AppHostApi\n * @extends {BaseAPI}\n */\nclass AppHostApi extends base_1.BaseAPI {\n    /**\n     * Returns event object for app host events. Used if the app host intends to sign the event message instead of using Neynar-hosted signers.\n     * @summary Get app host event\n     * @param {AppHostApiAppHostGetEventRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppHostApi\n     * @returns {Promise<AppHostGetEventResponse>} A promise that resolves to a `AppHostGetEventResponse` object\n     *\n     */\n    appHostGetEvent(requestParameters, options) {\n        return (0, exports.AppHostApiFp)(this.configuration).appHostGetEvent(requestParameters.appDomain, requestParameters.fid, requestParameters.event, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns the current notification state for a specific user across all mini app domains in this app host. Shows which domains have notifications enabled.\n     * @summary Get the user\\'s notification subscriptions\n     * @param {AppHostApiAppHostGetUserStateRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppHostApi\n     * @returns {Promise<AppHostUserStateResponse>} A promise that resolves to a `AppHostUserStateResponse` object\n     *\n     */\n    appHostGetUserState(requestParameters, options) {\n        return (0, exports.AppHostApiFp)(this.configuration).appHostGetUserState(requestParameters.fid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Post an app_host event to the domain\\'s webhook. Events such as enabling or disabling notifications for a user. Provide either a signed message or the signer UUID of an authorized neynar-hosted signers.\n     * @summary Process app host event\n     * @param {AppHostApiAppHostPostEventRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AppHostApi\n     * @returns {Promise<AppHostPostEventResponse>} A promise that resolves to a `AppHostPostEventResponse` object\n     *\n     */\n    appHostPostEvent(requestParameters, options) {\n        return (0, exports.AppHostApiFp)(this.configuration).appHostPostEvent(requestParameters.appHostPostEventBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AppHostApi = AppHostApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2FwcC1ob3N0LWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsbUNBQW1DO0FBQzNHLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsa0NBQWtDO0FBQ3ZEO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnQkFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsa0NBQWtDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQ0FBc0M7QUFDckQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9hcHAtaG9zdC1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcEhvc3RBcGkgPSBleHBvcnRzLkFwcEhvc3RBcGlGYWN0b3J5ID0gZXhwb3J0cy5BcHBIb3N0QXBpRnAgPSBleHBvcnRzLkFwcEhvc3RBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEFwcEhvc3RBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBBcHBIb3N0QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGV2ZW50IG9iamVjdCBmb3IgYXBwIGhvc3QgZXZlbnRzLiBVc2VkIGlmIHRoZSBhcHAgaG9zdCBpbnRlbmRzIHRvIHNpZ24gdGhlIGV2ZW50IG1lc3NhZ2UgaW5zdGVhZCBvZiB1c2luZyBOZXluYXItaG9zdGVkIHNpZ25lcnMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhcHAgaG9zdCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwRG9tYWluIFRoZSBkb21haW4gb2YgdGhlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgdXNlciB3aG8gaW5pdGlhdGVkIHRoZSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge0FwcEhvc3RFdmVudFR5cGV9IGV2ZW50IFRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEhvc3RHZXRFdmVudFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdEdldEV2ZW50UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXBwSG9zdEdldEV2ZW50OiBhc3luYyAoYXBwRG9tYWluLCBmaWQsIGV2ZW50LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FwcERvbWFpbicgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdhcHBIb3N0R2V0RXZlbnQnLCAnYXBwRG9tYWluJywgYXBwRG9tYWluKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdhcHBIb3N0R2V0RXZlbnQnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2V2ZW50JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2FwcEhvc3RHZXRFdmVudCcsICdldmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2FwcF9ob3N0L3VzZXIvZXZlbnRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoYXBwRG9tYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhcHBfZG9tYWluJ10gPSBhcHBEb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZXZlbnQnXSA9IGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBub3RpZmljYXRpb24gc3RhdGUgZm9yIGEgc3BlY2lmaWMgdXNlciBhY3Jvc3MgYWxsIG1pbmkgYXBwIGRvbWFpbnMgaW4gdGhpcyBhcHAgaG9zdC4gU2hvd3Mgd2hpY2ggZG9tYWlucyBoYXZlIG5vdGlmaWNhdGlvbnMgZW5hYmxlZC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSB1c2VyXFwncyBub3RpZmljYXRpb24gc3Vic2NyaXB0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgb2YgdGhlIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdFVzZXJTdGF0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdFVzZXJTdGF0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFwcEhvc3RHZXRVc2VyU3RhdGU6IGFzeW5jIChmaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2FwcEhvc3RHZXRVc2VyU3RhdGUnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2FwcF9ob3N0L3VzZXIvc3RhdGVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc3QgYW4gYXBwX2hvc3QgZXZlbnQgdG8gdGhlIGRvbWFpblxcJ3Mgd2ViaG9vay4gRXZlbnRzIHN1Y2ggYXMgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci4gUHJvdmlkZSBlaXRoZXIgYSBzaWduZWQgbWVzc2FnZSBvciB0aGUgc2lnbmVyIFVVSUQgb2YgYW4gYXV0aG9yaXplZCBuZXluYXItaG9zdGVkIHNpZ25lcnMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb2Nlc3MgYXBwIGhvc3QgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtBcHBIb3N0UG9zdEV2ZW50Qm9keX0gYXBwSG9zdFBvc3RFdmVudEJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFwcEhvc3RQb3N0RXZlbnQ6IGFzeW5jIChhcHBIb3N0UG9zdEV2ZW50Qm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhcHBIb3N0UG9zdEV2ZW50Qm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdhcHBIb3N0UG9zdEV2ZW50JywgJ2FwcEhvc3RQb3N0RXZlbnRCb2R5JywgYXBwSG9zdFBvc3RFdmVudEJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvYXBwX2hvc3QvdXNlci9ldmVudGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGFwcEhvc3RQb3N0RXZlbnRCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFwcEhvc3RBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEFwcEhvc3RBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQXBwSG9zdEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFwcEhvc3RBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkFwcEhvc3RBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgZXZlbnQgb2JqZWN0IGZvciBhcHAgaG9zdCBldmVudHMuIFVzZWQgaWYgdGhlIGFwcCBob3N0IGludGVuZHMgdG8gc2lnbiB0aGUgZXZlbnQgbWVzc2FnZSBpbnN0ZWFkIG9mIHVzaW5nIE5leW5hci1ob3N0ZWQgc2lnbmVycy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFwcCBob3N0IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBEb21haW4gVGhlIGRvbWFpbiBvZiB0aGUgbWluaSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSB1c2VyIHdobyBpbml0aWF0ZWQgdGhlIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7QXBwSG9zdEV2ZW50VHlwZX0gZXZlbnQgVGhlIHR5cGUgb2YgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdEdldEV2ZW50UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBBcHBIb3N0R2V0RXZlbnRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBhcHBIb3N0R2V0RXZlbnQoYXBwRG9tYWluLCBmaWQsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5hcHBIb3N0R2V0RXZlbnQoYXBwRG9tYWluLCBmaWQsIGV2ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQXBwSG9zdEFwaS5hcHBIb3N0R2V0RXZlbnQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbm90aWZpY2F0aW9uIHN0YXRlIGZvciBhIHNwZWNpZmljIHVzZXIgYWNyb3NzIGFsbCBtaW5pIGFwcCBkb21haW5zIGluIHRoaXMgYXBwIGhvc3QuIFNob3dzIHdoaWNoIGRvbWFpbnMgaGF2ZSBub3RpZmljYXRpb25zIGVuYWJsZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdXNlclxcJ3Mgbm90aWZpY2F0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBhcHBIb3N0R2V0VXNlclN0YXRlKGZpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYXBwSG9zdEdldFVzZXJTdGF0ZShmaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBcHBIb3N0QXBpLmFwcEhvc3RHZXRVc2VyU3RhdGUnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc3QgYW4gYXBwX2hvc3QgZXZlbnQgdG8gdGhlIGRvbWFpblxcJ3Mgd2ViaG9vay4gRXZlbnRzIHN1Y2ggYXMgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci4gUHJvdmlkZSBlaXRoZXIgYSBzaWduZWQgbWVzc2FnZSBvciB0aGUgc2lnbmVyIFVVSUQgb2YgYW4gYXV0aG9yaXplZCBuZXluYXItaG9zdGVkIHNpZ25lcnMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb2Nlc3MgYXBwIGhvc3QgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtBcHBIb3N0UG9zdEV2ZW50Qm9keX0gYXBwSG9zdFBvc3RFdmVudEJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGFwcEhvc3RQb3N0RXZlbnQoYXBwSG9zdFBvc3RFdmVudEJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmFwcEhvc3RQb3N0RXZlbnQoYXBwSG9zdFBvc3RFdmVudEJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBcHBIb3N0QXBpLmFwcEhvc3RQb3N0RXZlbnQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQXBwSG9zdEFwaUZwID0gQXBwSG9zdEFwaUZwO1xuLyoqXG4gKiBBcHBIb3N0QXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXBwSG9zdEFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkFwcEhvc3RBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgZXZlbnQgb2JqZWN0IGZvciBhcHAgaG9zdCBldmVudHMuIFVzZWQgaWYgdGhlIGFwcCBob3N0IGludGVuZHMgdG8gc2lnbiB0aGUgZXZlbnQgbWVzc2FnZSBpbnN0ZWFkIG9mIHVzaW5nIE5leW5hci1ob3N0ZWQgc2lnbmVycy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFwcCBob3N0IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7QXBwSG9zdEFwaUFwcEhvc3RHZXRFdmVudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdEdldEV2ZW50UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBBcHBIb3N0R2V0RXZlbnRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhcHBIb3N0R2V0RXZlbnQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmFwcEhvc3RHZXRFdmVudChyZXF1ZXN0UGFyYW1ldGVycy5hcHBEb21haW4sIHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuZXZlbnQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiBzdGF0ZSBmb3IgYSBzcGVjaWZpYyB1c2VyIGFjcm9zcyBhbGwgbWluaSBhcHAgZG9tYWlucyBpbiB0aGlzIGFwcCBob3N0LiBTaG93cyB3aGljaCBkb21haW5zIGhhdmUgbm90aWZpY2F0aW9ucyBlbmFibGVkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHVzZXJcXCdzIG5vdGlmaWNhdGlvbiBzdWJzY3JpcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7QXBwSG9zdEFwaUFwcEhvc3RHZXRVc2VyU3RhdGVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhcHBIb3N0R2V0VXNlclN0YXRlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5hcHBIb3N0R2V0VXNlclN0YXRlKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc3QgYW4gYXBwX2hvc3QgZXZlbnQgdG8gdGhlIGRvbWFpblxcJ3Mgd2ViaG9vay4gRXZlbnRzIHN1Y2ggYXMgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci4gUHJvdmlkZSBlaXRoZXIgYSBzaWduZWQgbWVzc2FnZSBvciB0aGUgc2lnbmVyIFVVSUQgb2YgYW4gYXV0aG9yaXplZCBuZXluYXItaG9zdGVkIHNpZ25lcnMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb2Nlc3MgYXBwIGhvc3QgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtBcHBIb3N0QXBpQXBwSG9zdFBvc3RFdmVudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFwcEhvc3RQb3N0RXZlbnQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmFwcEhvc3RQb3N0RXZlbnQocmVxdWVzdFBhcmFtZXRlcnMuYXBwSG9zdFBvc3RFdmVudEJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFwcEhvc3RBcGlGYWN0b3J5ID0gQXBwSG9zdEFwaUZhY3Rvcnk7XG4vKipcbiAqIEFwcEhvc3RBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQXBwSG9zdEFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEFwcEhvc3RBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBldmVudCBvYmplY3QgZm9yIGFwcCBob3N0IGV2ZW50cy4gVXNlZCBpZiB0aGUgYXBwIGhvc3QgaW50ZW5kcyB0byBzaWduIHRoZSBldmVudCBtZXNzYWdlIGluc3RlYWQgb2YgdXNpbmcgTmV5bmFyLWhvc3RlZCBzaWduZXJzLlxuICAgICAqIEBzdW1tYXJ5IEdldCBhcHAgaG9zdCBldmVudFxuICAgICAqIEBwYXJhbSB7QXBwSG9zdEFwaUFwcEhvc3RHZXRFdmVudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFwcEhvc3RBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBIb3N0R2V0RXZlbnRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RHZXRFdmVudFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGFwcEhvc3RHZXRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQXBwSG9zdEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmFwcEhvc3RHZXRFdmVudChyZXF1ZXN0UGFyYW1ldGVycy5hcHBEb21haW4sIHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuZXZlbnQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5vdGlmaWNhdGlvbiBzdGF0ZSBmb3IgYSBzcGVjaWZpYyB1c2VyIGFjcm9zcyBhbGwgbWluaSBhcHAgZG9tYWlucyBpbiB0aGlzIGFwcCBob3N0LiBTaG93cyB3aGljaCBkb21haW5zIGhhdmUgbm90aWZpY2F0aW9ucyBlbmFibGVkLlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdXNlclxcJ3Mgbm90aWZpY2F0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FwcEhvc3RBcGlBcHBIb3N0R2V0VXNlclN0YXRlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQXBwSG9zdEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RVc2VyU3RhdGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBhcHBIb3N0R2V0VXNlclN0YXRlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BcHBIb3N0QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYXBwSG9zdEdldFVzZXJTdGF0ZShyZXF1ZXN0UGFyYW1ldGVycy5maWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGFuIGFwcF9ob3N0IGV2ZW50IHRvIHRoZSBkb21haW5cXCdzIHdlYmhvb2suIEV2ZW50cyBzdWNoIGFzIGVuYWJsaW5nIG9yIGRpc2FibGluZyBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuIFByb3ZpZGUgZWl0aGVyIGEgc2lnbmVkIG1lc3NhZ2Ugb3IgdGhlIHNpZ25lciBVVUlEIG9mIGFuIGF1dGhvcml6ZWQgbmV5bmFyLWhvc3RlZCBzaWduZXJzLlxuICAgICAqIEBzdW1tYXJ5IFByb2Nlc3MgYXBwIGhvc3QgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0FwcEhvc3RBcGlBcHBIb3N0UG9zdEV2ZW50UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQXBwSG9zdEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEhvc3RQb3N0RXZlbnRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RQb3N0RXZlbnRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBhcHBIb3N0UG9zdEV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BcHBIb3N0QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYXBwSG9zdFBvc3RFdmVudChyZXF1ZXN0UGFyYW1ldGVycy5hcHBIb3N0UG9zdEV2ZW50Qm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcHBIb3N0QXBpID0gQXBwSG9zdEFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/app-host-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/ban-api.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/ban-api.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BanApi = exports.BanApiFactory = exports.BanApiFp = exports.BanApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * BanApi - axios parameter creator\n * @export\n */\nconst BanApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Deletes a list of FIDs from the app associated with your API key.\n         * @summary Unban FIDs from app\n         * @param {BanReqBody} banReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)\n         *\n         */\n        deleteBans: async (banReqBody, options = {}) => {\n            // verify required parameter 'banReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteBans', 'banReqBody', banReqBody);\n            const localVarPath = `/farcaster/ban`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(banReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all FIDs that your app has banned.\n         * @summary Banned FIDs of app\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)\n         *\n         */\n        fetchBanList: async (limit, cursor, xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/ban/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.\n         * @summary Ban FIDs from app\n         * @param {BanReqBody} banReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)\n         *\n         */\n        publishBans: async (banReqBody, options = {}) => {\n            // verify required parameter 'banReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishBans', 'banReqBody', banReqBody);\n            const localVarPath = `/farcaster/ban`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(banReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.BanApiAxiosParamCreator = BanApiAxiosParamCreator;\n/**\n * BanApi - functional programming interface\n * @export\n */\nconst BanApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.BanApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Deletes a list of FIDs from the app associated with your API key.\n         * @summary Unban FIDs from app\n         * @param {BanReqBody} banReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)\n         *\n         */\n        async deleteBans(banReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBans(banReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BanApi.deleteBans']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all FIDs that your app has banned.\n         * @summary Banned FIDs of app\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)\n         *\n         */\n        async fetchBanList(limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBanList(limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BanApi.fetchBanList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.\n         * @summary Ban FIDs from app\n         * @param {BanReqBody} banReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)\n         *\n         */\n        async publishBans(banReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishBans(banReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BanApi.publishBans']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.BanApiFp = BanApiFp;\n/**\n * BanApi - factory interface\n * @export\n */\nconst BanApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.BanApiFp)(configuration);\n    return {\n        /**\n         * Deletes a list of FIDs from the app associated with your API key.\n         * @summary Unban FIDs from app\n         * @param {BanApiDeleteBansRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)\n         *\n         */\n        deleteBans(requestParameters, options) {\n            return localVarFp.deleteBans(requestParameters.banReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all FIDs that your app has banned.\n         * @summary Banned FIDs of app\n         * @param {BanApiFetchBanListRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)\n         *\n         */\n        fetchBanList(requestParameters = {}, options) {\n            return localVarFp.fetchBanList(requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.\n         * @summary Ban FIDs from app\n         * @param {BanApiPublishBansRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)\n         *\n         */\n        publishBans(requestParameters, options) {\n            return localVarFp.publishBans(requestParameters.banReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.BanApiFactory = BanApiFactory;\n/**\n * BanApi - object-oriented interface\n * @export\n * @class BanApi\n * @extends {BaseAPI}\n */\nclass BanApi extends base_1.BaseAPI {\n    /**\n     * Deletes a list of FIDs from the app associated with your API key.\n     * @summary Unban FIDs from app\n     * @param {BanApiDeleteBansRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BanApi\n     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)\n     *\n     */\n    deleteBans(requestParameters, options) {\n        return (0, exports.BanApiFp)(this.configuration).deleteBans(requestParameters.banReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all FIDs that your app has banned.\n     * @summary Banned FIDs of app\n     * @param {BanApiFetchBanListRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BanApi\n     * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)\n     *\n     */\n    fetchBanList(requestParameters = {}, options) {\n        return (0, exports.BanApiFp)(this.configuration).fetchBanList(requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.\n     * @summary Ban FIDs from app\n     * @param {BanApiPublishBansRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BanApi\n     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)\n     *\n     */\n    publishBans(requestParameters, options) {\n        return (0, exports.BanApiFp)(this.configuration).publishBans(requestParameters.banReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.BanApi = BanApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2Jhbi1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0IsR0FBRywrQkFBK0I7QUFDM0YsZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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L1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9iYW4tYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYW5BcGkgPSBleHBvcnRzLkJhbkFwaUZhY3RvcnkgPSBleHBvcnRzLkJhbkFwaUZwID0gZXhwb3J0cy5CYW5BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEJhbkFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbkFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGxpc3Qgb2YgRklEcyBmcm9tIHRoZSBhcHAgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQVBJIGtleS5cbiAgICAgICAgICogQHN1bW1hcnkgVW5iYW4gRklEcyBmcm9tIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge0JhblJlcUJvZHl9IGJhblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QmFuUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCYW5SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLWJhbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVCYW5zOiBhc3luYyAoYmFuUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdiYW5SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlbGV0ZUJhbnMnLCAnYmFuUmVxQm9keScsIGJhblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvYmFuYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShiYW5SZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGFsbCBGSURzIHRoYXQgeW91ciBhcHAgaGFzIGJhbm5lZC5cbiAgICAgICAgICogQHN1bW1hcnkgQmFubmVkIEZJRHMgb2YgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5MaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCYW5MaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJhbi1saXN0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCYW5MaXN0OiBhc3luYyAobGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9iYW4vbGlzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQmFucyBhIGxpc3Qgb2YgRklEcyBmcm9tIHRoZSBhcHAgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQVBJIGtleS4gQmFubmVkIHVzZXJzLCB0aGVpciBjYXN0cyBhbmQgcmVhY3Rpb25zIHdpbGwgbm90IGFwcGVhciBpbiBmZWVkcy5cbiAgICAgICAgICogQHN1bW1hcnkgQmFuIEZJRHMgZnJvbSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtCYW5SZXFCb2R5fSBiYW5SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtYmFucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hCYW5zOiBhc3luYyAoYmFuUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdiYW5SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hCYW5zJywgJ2JhblJlcUJvZHknLCBiYW5SZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2JhbmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJhblJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmFuQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBCYW5BcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQmFuQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmFuQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5CYW5BcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgYSBsaXN0IG9mIEZJRHMgZnJvbSB0aGUgYXBwIGFzc29jaWF0ZWQgd2l0aCB5b3VyIEFQSSBrZXkuXG4gICAgICAgICAqIEBzdW1tYXJ5IFVuYmFuIEZJRHMgZnJvbSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtCYW5SZXFCb2R5fSBiYW5SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1iYW5zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZGVsZXRlQmFucyhiYW5SZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5kZWxldGVCYW5zKGJhblJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydCYW5BcGkuZGVsZXRlQmFucyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgRklEcyB0aGF0IHlvdXIgYXBwIGhhcyBiYW5uZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJhbm5lZCBGSURzIG9mIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QmFuTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1iYW4tbGlzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQmFuTGlzdChsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEJhbkxpc3QobGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0JhbkFwaS5mZXRjaEJhbkxpc3QnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhbnMgYSBsaXN0IG9mIEZJRHMgZnJvbSB0aGUgYXBwIGFzc29jaWF0ZWQgd2l0aCB5b3VyIEFQSSBrZXkuIEJhbm5lZCB1c2VycywgdGhlaXIgY2FzdHMgYW5kIHJlYWN0aW9ucyB3aWxsIG5vdCBhcHBlYXIgaW4gZmVlZHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJhbiBGSURzIGZyb20gYXBwXG4gICAgICAgICAqIEBwYXJhbSB7QmFuUmVxQm9keX0gYmFuUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLWJhbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBwdWJsaXNoQmFucyhiYW5SZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5wdWJsaXNoQmFucyhiYW5SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQmFuQXBpLnB1Ymxpc2hCYW5zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkJhbkFwaUZwID0gQmFuQXBpRnA7XG4vKipcbiAqIEJhbkFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbkFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkJhbkFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGxpc3Qgb2YgRklEcyBmcm9tIHRoZSBhcHAgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQVBJIGtleS5cbiAgICAgICAgICogQHN1bW1hcnkgVW5iYW4gRklEcyBmcm9tIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge0JhbkFwaURlbGV0ZUJhbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1iYW5zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlQmFucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlQmFucyhyZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgRklEcyB0aGF0IHlvdXIgYXBwIGhhcyBiYW5uZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJhbm5lZCBGSURzIG9mIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge0JhbkFwaUZldGNoQmFuTGlzdFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QmFuTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1iYW4tbGlzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQmFuTGlzdChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEJhbkxpc3QocmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhbnMgYSBsaXN0IG9mIEZJRHMgZnJvbSB0aGUgYXBwIGFzc29jaWF0ZWQgd2l0aCB5b3VyIEFQSSBrZXkuIEJhbm5lZCB1c2VycywgdGhlaXIgY2FzdHMgYW5kIHJlYWN0aW9ucyB3aWxsIG5vdCBhcHBlYXIgaW4gZmVlZHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJhbiBGSURzIGZyb20gYXBwXG4gICAgICAgICAqIEBwYXJhbSB7QmFuQXBpUHVibGlzaEJhbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFuUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtYmFucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hCYW5zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoQmFucyhyZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5CYW5BcGlGYWN0b3J5ID0gQmFuQXBpRmFjdG9yeTtcbi8qKlxuICogQmFuQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEJhbkFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEJhbkFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbGlzdCBvZiBGSURzIGZyb20gdGhlIGFwcCBhc3NvY2lhdGVkIHdpdGggeW91ciBBUEkga2V5LlxuICAgICAqIEBzdW1tYXJ5IFVuYmFuIEZJRHMgZnJvbSBhcHBcbiAgICAgKiBAcGFyYW0ge0JhbkFwaURlbGV0ZUJhbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBCYW5BcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLWJhbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVCYW5zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5CYW5BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVCYW5zKHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFsbCBGSURzIHRoYXQgeW91ciBhcHAgaGFzIGJhbm5lZC5cbiAgICAgKiBAc3VtbWFyeSBCYW5uZWQgRklEcyBvZiBhcHBcbiAgICAgKiBAcGFyYW0ge0JhbkFwaUZldGNoQmFuTGlzdFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEJhbkFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhbkxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhbkxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJhbi1saXN0KVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hCYW5MaXN0KHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkJhbkFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoQmFuTGlzdChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFucyBhIGxpc3Qgb2YgRklEcyBmcm9tIHRoZSBhcHAgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQVBJIGtleS4gQmFubmVkIHVzZXJzLCB0aGVpciBjYXN0cyBhbmQgcmVhY3Rpb25zIHdpbGwgbm90IGFwcGVhciBpbiBmZWVkcy5cbiAgICAgKiBAc3VtbWFyeSBCYW4gRklEcyBmcm9tIGFwcFxuICAgICAqIEBwYXJhbSB7QmFuQXBpUHVibGlzaEJhbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBCYW5BcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1iYW5zKVxuICAgICAqXG4gICAgICovXG4gICAgcHVibGlzaEJhbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkJhbkFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnB1Ymxpc2hCYW5zKHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFuQXBpID0gQmFuQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/ban-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/block-api.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/block-api.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlockApi = exports.BlockApiFactory = exports.BlockApiFp = exports.BlockApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * BlockApi - axios parameter creator\n * @export\n */\nconst BlockApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Deletes a block for a given FID.\n         * @summary Unblock FID\n         * @param {BlockReqBody} blockReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)\n         *\n         */\n        deleteBlock: async (blockReqBody, options = {}) => {\n            // verify required parameter 'blockReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteBlock', 'blockReqBody', blockReqBody);\n            const localVarPath = `/farcaster/block`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(blockReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all FIDs that a user has blocked or has been blocked by\n         * @summary Blocked / Blocked by FIDs\n         * @param {number} [blockerFid] Providing this will return the users that this user has blocked\n         * @param {number} [blockedFid] Providing this will return the users that have blocked this user\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)\n         *\n         */\n        fetchBlockList: async (blockerFid, blockedFid, limit, cursor, xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/block/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (blockerFid !== undefined) {\n                localVarQueryParameter['blocker_fid'] = blockerFid;\n            }\n            if (blockedFid !== undefined) {\n                localVarQueryParameter['blocked_fid'] = blockedFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Adds a block for a given FID.\n         * @summary Block FID\n         * @param {BlockReqBody} blockReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)\n         *\n         */\n        publishBlock: async (blockReqBody, options = {}) => {\n            // verify required parameter 'blockReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishBlock', 'blockReqBody', blockReqBody);\n            const localVarPath = `/farcaster/block`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(blockReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.BlockApiAxiosParamCreator = BlockApiAxiosParamCreator;\n/**\n * BlockApi - functional programming interface\n * @export\n */\nconst BlockApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.BlockApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Deletes a block for a given FID.\n         * @summary Unblock FID\n         * @param {BlockReqBody} blockReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)\n         *\n         */\n        async deleteBlock(blockReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlock(blockReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BlockApi.deleteBlock']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all FIDs that a user has blocked or has been blocked by\n         * @summary Blocked / Blocked by FIDs\n         * @param {number} [blockerFid] Providing this will return the users that this user has blocked\n         * @param {number} [blockedFid] Providing this will return the users that have blocked this user\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)\n         *\n         */\n        async fetchBlockList(blockerFid, blockedFid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBlockList(blockerFid, blockedFid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BlockApi.fetchBlockList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Adds a block for a given FID.\n         * @summary Block FID\n         * @param {BlockReqBody} blockReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)\n         *\n         */\n        async publishBlock(blockReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishBlock(blockReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BlockApi.publishBlock']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.BlockApiFp = BlockApiFp;\n/**\n * BlockApi - factory interface\n * @export\n */\nconst BlockApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.BlockApiFp)(configuration);\n    return {\n        /**\n         * Deletes a block for a given FID.\n         * @summary Unblock FID\n         * @param {BlockApiDeleteBlockRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)\n         *\n         */\n        deleteBlock(requestParameters, options) {\n            return localVarFp.deleteBlock(requestParameters.blockReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all FIDs that a user has blocked or has been blocked by\n         * @summary Blocked / Blocked by FIDs\n         * @param {BlockApiFetchBlockListRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)\n         *\n         */\n        fetchBlockList(requestParameters = {}, options) {\n            return localVarFp.fetchBlockList(requestParameters.blockerFid, requestParameters.blockedFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Adds a block for a given FID.\n         * @summary Block FID\n         * @param {BlockApiPublishBlockRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)\n         *\n         */\n        publishBlock(requestParameters, options) {\n            return localVarFp.publishBlock(requestParameters.blockReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.BlockApiFactory = BlockApiFactory;\n/**\n * BlockApi - object-oriented interface\n * @export\n * @class BlockApi\n * @extends {BaseAPI}\n */\nclass BlockApi extends base_1.BaseAPI {\n    /**\n     * Deletes a block for a given FID.\n     * @summary Unblock FID\n     * @param {BlockApiDeleteBlockRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BlockApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)\n     *\n     */\n    deleteBlock(requestParameters, options) {\n        return (0, exports.BlockApiFp)(this.configuration).deleteBlock(requestParameters.blockReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all FIDs that a user has blocked or has been blocked by\n     * @summary Blocked / Blocked by FIDs\n     * @param {BlockApiFetchBlockListRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BlockApi\n     * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)\n     *\n     */\n    fetchBlockList(requestParameters = {}, options) {\n        return (0, exports.BlockApiFp)(this.configuration).fetchBlockList(requestParameters.blockerFid, requestParameters.blockedFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Adds a block for a given FID.\n     * @summary Block FID\n     * @param {BlockApiPublishBlockRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BlockApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)\n     *\n     */\n    publishBlock(requestParameters, options) {\n        return (0, exports.BlockApiFp)(this.configuration).publishBlock(requestParameters.blockReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.BlockApi = BlockApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2Jsb2NrLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDO0FBQ25HLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5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QUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9ibG9jay1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2NrQXBpID0gZXhwb3J0cy5CbG9ja0FwaUZhY3RvcnkgPSBleHBvcnRzLkJsb2NrQXBpRnAgPSBleHBvcnRzLkJsb2NrQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBCbG9ja0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJsb2NrQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGEgYmxvY2sgZm9yIGEgZ2l2ZW4gRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBVbmJsb2NrIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0Jsb2NrUmVxQm9keX0gYmxvY2tSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1ibG9jaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUJsb2NrOiBhc3luYyAoYmxvY2tSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jsb2NrUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZWxldGVCbG9jaycsICdibG9ja1JlcUJvZHknLCBibG9ja1JlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvYmxvY2tgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdERUxFVEUnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJsb2NrUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgRklEcyB0aGF0IGEgdXNlciBoYXMgYmxvY2tlZCBvciBoYXMgYmVlbiBibG9ja2VkIGJ5XG4gICAgICAgICAqIEBzdW1tYXJ5IEJsb2NrZWQgLyBCbG9ja2VkIGJ5IEZJRHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtibG9ja2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiB0aGUgdXNlcnMgdGhhdCB0aGlzIHVzZXIgaGFzIGJsb2NrZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtibG9ja2VkRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiB0aGUgdXNlcnMgdGhhdCBoYXZlIGJsb2NrZWQgdGhpcyB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9ja0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJsb2NrTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ibG9jay1saXN0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCbG9ja0xpc3Q6IGFzeW5jIChibG9ja2VyRmlkLCBibG9ja2VkRmlkLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2Jsb2NrL2xpc3RgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoYmxvY2tlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYmxvY2tlcl9maWQnXSA9IGJsb2NrZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tlZEZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYmxvY2tlZF9maWQnXSA9IGJsb2NrZWRGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBibG9jayBmb3IgYSBnaXZlbiBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJsb2NrIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0Jsb2NrUmVxQm9keX0gYmxvY2tSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtYmxvY2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoQmxvY2s6IGFzeW5jIChibG9ja1JlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYmxvY2tSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hCbG9jaycsICdibG9ja1JlcUJvZHknLCBibG9ja1JlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvYmxvY2tgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShibG9ja1JlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmxvY2tBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEJsb2NrQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEJsb2NrQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkJsb2NrQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGEgYmxvY2sgZm9yIGEgZ2l2ZW4gRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBVbmJsb2NrIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0Jsb2NrUmVxQm9keX0gYmxvY2tSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1ibG9jaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZUJsb2NrKGJsb2NrUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZGVsZXRlQmxvY2soYmxvY2tSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQmxvY2tBcGkuZGVsZXRlQmxvY2snXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIGJsb2NrZWQgb3IgaGFzIGJlZW4gYmxvY2tlZCBieVxuICAgICAgICAgKiBAc3VtbWFyeSBCbG9ja2VkIC8gQmxvY2tlZCBieSBGSURzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmxvY2tlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gdGhlIHVzZXJzIHRoYXQgdGhpcyB1c2VyIGhhcyBibG9ja2VkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmxvY2tlZEZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gdGhlIHVzZXJzIHRoYXQgaGF2ZSBibG9ja2VkIHRoaXMgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QmxvY2tMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCbG9ja0xpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYmxvY2stbGlzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQmxvY2tMaXN0KGJsb2NrZXJGaWQsIGJsb2NrZWRGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQmxvY2tMaXN0KGJsb2NrZXJGaWQsIGJsb2NrZWRGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydCbG9ja0FwaS5mZXRjaEJsb2NrTGlzdCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGJsb2NrIGZvciBhIGdpdmVuIEZJRC5cbiAgICAgICAgICogQHN1bW1hcnkgQmxvY2sgRklEXG4gICAgICAgICAqIEBwYXJhbSB7QmxvY2tSZXFCb2R5fSBibG9ja1JlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1ibG9jaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hCbG9jayhibG9ja1JlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hCbG9jayhibG9ja1JlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydCbG9ja0FwaS5wdWJsaXNoQmxvY2snXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmxvY2tBcGlGcCA9IEJsb2NrQXBpRnA7XG4vKipcbiAqIEJsb2NrQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5CbG9ja0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGJsb2NrIGZvciBhIGdpdmVuIEZJRC5cbiAgICAgICAgICogQHN1bW1hcnkgVW5ibG9jayBGSURcbiAgICAgICAgICogQHBhcmFtIHtCbG9ja0FwaURlbGV0ZUJsb2NrUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtYmxvY2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVCbG9jayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlQmxvY2socmVxdWVzdFBhcmFtZXRlcnMuYmxvY2tSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgRklEcyB0aGF0IGEgdXNlciBoYXMgYmxvY2tlZCBvciBoYXMgYmVlbiBibG9ja2VkIGJ5XG4gICAgICAgICAqIEBzdW1tYXJ5IEJsb2NrZWQgLyBCbG9ja2VkIGJ5IEZJRHNcbiAgICAgICAgICogQHBhcmFtIHtCbG9ja0FwaUZldGNoQmxvY2tMaXN0UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9ja0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJsb2NrTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ibG9jay1saXN0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMuYmxvY2tlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuYmxvY2tlZEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBibG9jayBmb3IgYSBnaXZlbiBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJsb2NrIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0Jsb2NrQXBpUHVibGlzaEJsb2NrUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLWJsb2NrKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaEJsb2NrKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoQmxvY2socmVxdWVzdFBhcmFtZXRlcnMuYmxvY2tSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5CbG9ja0FwaUZhY3RvcnkgPSBCbG9ja0FwaUZhY3Rvcnk7XG4vKipcbiAqIEJsb2NrQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEJsb2NrQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQmxvY2tBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGJsb2NrIGZvciBhIGdpdmVuIEZJRC5cbiAgICAgKiBAc3VtbWFyeSBVbmJsb2NrIEZJRFxuICAgICAqIEBwYXJhbSB7QmxvY2tBcGlEZWxldGVCbG9ja1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEJsb2NrQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1ibG9jaylcbiAgICAgKlxuICAgICAqL1xuICAgIGRlbGV0ZUJsb2NrKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5CbG9ja0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlbGV0ZUJsb2NrKHJlcXVlc3RQYXJhbWV0ZXJzLmJsb2NrUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIGJsb2NrZWQgb3IgaGFzIGJlZW4gYmxvY2tlZCBieVxuICAgICAqIEBzdW1tYXJ5IEJsb2NrZWQgLyBCbG9ja2VkIGJ5IEZJRHNcbiAgICAgKiBAcGFyYW0ge0Jsb2NrQXBpRmV0Y2hCbG9ja0xpc3RSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBCbG9ja0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2NrTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmxvY2tMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ibG9jay1saXN0KVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQmxvY2tBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycy5ibG9ja2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5ibG9ja2VkRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGJsb2NrIGZvciBhIGdpdmVuIEZJRC5cbiAgICAgKiBAc3VtbWFyeSBCbG9jayBGSURcbiAgICAgKiBAcGFyYW0ge0Jsb2NrQXBpUHVibGlzaEJsb2NrUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQmxvY2tBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1ibG9jaylcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2hCbG9jayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQmxvY2tBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5wdWJsaXNoQmxvY2socmVxdWVzdFBhcmFtZXRlcnMuYmxvY2tSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2NrQXBpID0gQmxvY2tBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/block-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/cast-api.js":
/*!********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/cast-api.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SearchCastsModeEnum = exports.LookupCastConversationFoldEnum = exports.FetchBulkCastsSortTypeEnum = exports.CastApi = exports.CastApiFactory = exports.CastApiFp = exports.CastApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * CastApi - axios parameter creator\n * @export\n */\nconst CastApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Delete an existing cast. \\\\ (In order to delete a cast `signer_uuid` must be approved)\n         * @summary Delete a cast\n         * @param {DeleteCastReqBody} deleteCastReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)\n         *\n         */\n        deleteCast: async (deleteCastReqBody, options = {}) => {\n            // verify required parameter 'deleteCastReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteCast', 'deleteCastReqBody', deleteCastReqBody);\n            const localVarPath = `/farcaster/cast`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteCastReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch multiple casts using their respective hashes.\n         * @summary Bulk fetch casts\n         * @param {string} casts Hashes of the cast to be retrived (Comma separated, no spaces)\n         * @param {number} [viewerFid] adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n         * @param {FetchBulkCastsSortTypeEnum} [sortType] Optional parameter to sort the casts based on different criteria\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)\n         *\n         */\n        fetchBulkCasts: async (casts, viewerFid, sortType, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'casts' is not null or undefined\n            (0, common_1.assertParamExists)('fetchBulkCasts', 'casts', casts);\n            const localVarPath = `/farcaster/casts`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (casts !== undefined) {\n                localVarQueryParameter['casts'] = casts;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (sortType !== undefined) {\n                localVarQueryParameter['sort_type'] = sortType;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all composer actions on Warpcast. You can filter by top or featured.\n         * @summary Fetch composer actions\n         * @param {CastComposerType} list Type of list to fetch.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)\n         *\n         */\n        fetchComposerActions: async (list, limit, cursor, options = {}) => {\n            // verify required parameter 'list' is not null or undefined\n            (0, common_1.assertParamExists)('fetchComposerActions', 'list', list);\n            const localVarPath = `/farcaster/cast/composer_actions/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (list !== undefined) {\n                localVarQueryParameter['list'] = list;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Crawls the given URL and returns metadata useful when embedding the URL in a cast.\n         * @summary Embedded URL metadata\n         * @param {string} url URL to crawl metadata of\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)\n         *\n         */\n        fetchEmbeddedUrlMetadata: async (url, options = {}) => {\n            // verify required parameter 'url' is not null or undefined\n            (0, common_1.assertParamExists)('fetchEmbeddedUrlMetadata', 'url', url);\n            const localVarPath = `/farcaster/cast/embed/crawl`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (url !== undefined) {\n                localVarQueryParameter['url'] = url;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Gets information about an individual cast by passing in a Farcaster web URL or cast hash\n         * @summary By hash or URL\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {CastParamType} type\n         * @param {number} [viewerFid] adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)\n         *\n         */\n        lookupCastByHashOrWarpcastUrl: async (identifier, type, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'identifier' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastByHashOrWarpcastUrl', 'identifier', identifier);\n            // verify required parameter 'type' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastByHashOrWarpcastUrl', 'type', type);\n            const localVarPath = `/farcaster/cast`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (identifier !== undefined) {\n                localVarQueryParameter['identifier'] = identifier;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.\n         * @summary Conversation for a cast\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {CastParamType} type\n         * @param {number} [replyDepth] The depth of replies in the conversation that will be returned (default 2)\n         * @param {boolean} [includeChronologicalParentCasts] Include all parent casts in chronological order\n         * @param {number} [viewerFid] Providing this will return a conversation that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {CastConversationSortType} [sortType] Sort type for the ordering of descendants. Default is &#x60;chron&#x60;\n         * @param {LookupCastConversationFoldEnum} [fold] Show conversation above or below the fold. Lower quality responses are hidden below the fold. Not passing in a value shows the full conversation without any folding.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)\n         *\n         */\n        lookupCastConversation: async (identifier, type, replyDepth, includeChronologicalParentCasts, viewerFid, sortType, fold, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'identifier' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastConversation', 'identifier', identifier);\n            // verify required parameter 'type' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastConversation', 'type', type);\n            const localVarPath = `/farcaster/cast/conversation`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (identifier !== undefined) {\n                localVarQueryParameter['identifier'] = identifier;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (replyDepth !== undefined) {\n                localVarQueryParameter['reply_depth'] = replyDepth;\n            }\n            if (includeChronologicalParentCasts !== undefined) {\n                localVarQueryParameter['include_chronological_parent_casts'] = includeChronologicalParentCasts;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (sortType !== undefined) {\n                localVarQueryParameter['sort_type'] = sortType;\n            }\n            if (fold !== undefined) {\n                localVarQueryParameter['fold'] = fold;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)\n         * @summary Post a cast\n         * @param {PostCastReqBody} postCastReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)\n         *\n         */\n        publishCast: async (postCastReqBody, options = {}) => {\n            // verify required parameter 'postCastReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishCast', 'postCastReqBody', postCastReqBody);\n            const localVarPath = `/farcaster/cast`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(postCastReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Search for casts based on a query string, with optional AND filters\n         * @summary Search for casts\n         * @param {string} q Query string to search for casts. Supported operators:  | Operator  | Description                                                                                              | | --------- | -------------------------------------------------------------------------------------------------------- | | &#x60;+&#x60;       | Acts as the AND operator. This is the default operator between terms and can usually be omitted.         | | &#x60;\\\\|&#x60;      | Acts as the OR operator.                                                                                 | | &#x60;*&#x60;       | When used at the end of a term, signifies a prefix query.                                                  | | &#x60;\\&quot;&#x60;       | Wraps several terms into a phrase (for example, &#x60;\\&quot;star wars\\&quot;&#x60;).                                          | | &#x60;(&#x60;, &#x60;)&#x60;  | Wrap a clause for precedence (for example, &#x60;star + (wars \\\\| trek)&#x60;).                                     | | &#x60;~n&#x60;      | When used after a term (for example, &#x60;satr~3&#x60;), sets &#x60;fuzziness&#x60;. When used after a phrase, sets &#x60;slop&#x60;. | | &#x60;-&#x60;       | Negates the term.                                                                                        | | &#x60;before:&#x60; | Search for casts before a specific date. (e.g. &#x60;before:2025-04-20&#x60;)                                       | | &#x60;after:&#x60;  | Search for casts after a specific date. (e.g. &#x60;after:2025-04-20&#x60;)                                         |\n         * @param {SearchCastsModeEnum} [mode] Choices are: - &#x60;literal&#x60; - Searches for the words in the query string (default) - &#x60;semantic&#x60; - Searches for the meaning of the query string - &#x60;hybrid&#x60; - Combines both literal and semantic results\n         * @param {SearchSortType} [sortType] Choices are: - &#x60;desc_chron&#x60; - All casts sorted by time (default) - &#x60;algorithmic&#x60; - Casts sorted by engagement and time\n         * @param {number} [authorFid] Fid of the user whose casts you want to search\n         * @param {number} [viewerFid] Providing this will return search results that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [parentUrl] Parent URL of the casts you want to search\n         * @param {string} [channelId] Channel ID of the casts you want to search\n         * @param {boolean} [priorityMode] When true, only returns search results from power badge users and users that the viewer follows (if viewer_fid is provided).\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)\n         *\n         */\n        searchCasts: async (q, mode, sortType, authorFid, viewerFid, parentUrl, channelId, priorityMode, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'q' is not null or undefined\n            (0, common_1.assertParamExists)('searchCasts', 'q', q);\n            const localVarPath = `/farcaster/cast/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (q !== undefined) {\n                localVarQueryParameter['q'] = q;\n            }\n            if (mode !== undefined) {\n                localVarQueryParameter['mode'] = mode;\n            }\n            if (sortType !== undefined) {\n                localVarQueryParameter['sort_type'] = sortType;\n            }\n            if (authorFid !== undefined) {\n                localVarQueryParameter['author_fid'] = authorFid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (parentUrl !== undefined) {\n                localVarQueryParameter['parent_url'] = parentUrl;\n            }\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (priorityMode !== undefined) {\n                localVarQueryParameter['priority_mode'] = priorityMode;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.CastApiAxiosParamCreator = CastApiAxiosParamCreator;\n/**\n * CastApi - functional programming interface\n * @export\n */\nconst CastApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.CastApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Delete an existing cast. \\\\ (In order to delete a cast `signer_uuid` must be approved)\n         * @summary Delete a cast\n         * @param {DeleteCastReqBody} deleteCastReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)\n         *\n         */\n        async deleteCast(deleteCastReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCast(deleteCastReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.deleteCast']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch multiple casts using their respective hashes.\n         * @summary Bulk fetch casts\n         * @param {string} casts Hashes of the cast to be retrived (Comma separated, no spaces)\n         * @param {number} [viewerFid] adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n         * @param {FetchBulkCastsSortTypeEnum} [sortType] Optional parameter to sort the casts based on different criteria\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)\n         *\n         */\n        async fetchBulkCasts(casts, viewerFid, sortType, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkCasts(casts, viewerFid, sortType, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.fetchBulkCasts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all composer actions on Warpcast. You can filter by top or featured.\n         * @summary Fetch composer actions\n         * @param {CastComposerType} list Type of list to fetch.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)\n         *\n         */\n        async fetchComposerActions(list, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchComposerActions(list, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.fetchComposerActions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Crawls the given URL and returns metadata useful when embedding the URL in a cast.\n         * @summary Embedded URL metadata\n         * @param {string} url URL to crawl metadata of\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)\n         *\n         */\n        async fetchEmbeddedUrlMetadata(url, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchEmbeddedUrlMetadata(url, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.fetchEmbeddedUrlMetadata']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Gets information about an individual cast by passing in a Farcaster web URL or cast hash\n         * @summary By hash or URL\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {CastParamType} type\n         * @param {number} [viewerFid] adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)\n         *\n         */\n        async lookupCastByHashOrWarpcastUrl(identifier, type, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupCastByHashOrWarpcastUrl(identifier, type, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.lookupCastByHashOrWarpcastUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.\n         * @summary Conversation for a cast\n         * @param {string} identifier Cast identifier (Its either a url or a hash)\n         * @param {CastParamType} type\n         * @param {number} [replyDepth] The depth of replies in the conversation that will be returned (default 2)\n         * @param {boolean} [includeChronologicalParentCasts] Include all parent casts in chronological order\n         * @param {number} [viewerFid] Providing this will return a conversation that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {CastConversationSortType} [sortType] Sort type for the ordering of descendants. Default is &#x60;chron&#x60;\n         * @param {LookupCastConversationFoldEnum} [fold] Show conversation above or below the fold. Lower quality responses are hidden below the fold. Not passing in a value shows the full conversation without any folding.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)\n         *\n         */\n        async lookupCastConversation(identifier, type, replyDepth, includeChronologicalParentCasts, viewerFid, sortType, fold, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupCastConversation(identifier, type, replyDepth, includeChronologicalParentCasts, viewerFid, sortType, fold, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.lookupCastConversation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)\n         * @summary Post a cast\n         * @param {PostCastReqBody} postCastReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)\n         *\n         */\n        async publishCast(postCastReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishCast(postCastReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.publishCast']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Search for casts based on a query string, with optional AND filters\n         * @summary Search for casts\n         * @param {string} q Query string to search for casts. Supported operators:  | Operator  | Description                                                                                              | | --------- | -------------------------------------------------------------------------------------------------------- | | &#x60;+&#x60;       | Acts as the AND operator. This is the default operator between terms and can usually be omitted.         | | &#x60;\\\\|&#x60;      | Acts as the OR operator.                                                                                 | | &#x60;*&#x60;       | When used at the end of a term, signifies a prefix query.                                                  | | &#x60;\\&quot;&#x60;       | Wraps several terms into a phrase (for example, &#x60;\\&quot;star wars\\&quot;&#x60;).                                          | | &#x60;(&#x60;, &#x60;)&#x60;  | Wrap a clause for precedence (for example, &#x60;star + (wars \\\\| trek)&#x60;).                                     | | &#x60;~n&#x60;      | When used after a term (for example, &#x60;satr~3&#x60;), sets &#x60;fuzziness&#x60;. When used after a phrase, sets &#x60;slop&#x60;. | | &#x60;-&#x60;       | Negates the term.                                                                                        | | &#x60;before:&#x60; | Search for casts before a specific date. (e.g. &#x60;before:2025-04-20&#x60;)                                       | | &#x60;after:&#x60;  | Search for casts after a specific date. (e.g. &#x60;after:2025-04-20&#x60;)                                         |\n         * @param {SearchCastsModeEnum} [mode] Choices are: - &#x60;literal&#x60; - Searches for the words in the query string (default) - &#x60;semantic&#x60; - Searches for the meaning of the query string - &#x60;hybrid&#x60; - Combines both literal and semantic results\n         * @param {SearchSortType} [sortType] Choices are: - &#x60;desc_chron&#x60; - All casts sorted by time (default) - &#x60;algorithmic&#x60; - Casts sorted by engagement and time\n         * @param {number} [authorFid] Fid of the user whose casts you want to search\n         * @param {number} [viewerFid] Providing this will return search results that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [parentUrl] Parent URL of the casts you want to search\n         * @param {string} [channelId] Channel ID of the casts you want to search\n         * @param {boolean} [priorityMode] When true, only returns search results from power badge users and users that the viewer follows (if viewer_fid is provided).\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)\n         *\n         */\n        async searchCasts(q, mode, sortType, authorFid, viewerFid, parentUrl, channelId, priorityMode, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCasts(q, mode, sortType, authorFid, viewerFid, parentUrl, channelId, priorityMode, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastApi.searchCasts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.CastApiFp = CastApiFp;\n/**\n * CastApi - factory interface\n * @export\n */\nconst CastApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.CastApiFp)(configuration);\n    return {\n        /**\n         * Delete an existing cast. \\\\ (In order to delete a cast `signer_uuid` must be approved)\n         * @summary Delete a cast\n         * @param {CastApiDeleteCastRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)\n         *\n         */\n        deleteCast(requestParameters, options) {\n            return localVarFp.deleteCast(requestParameters.deleteCastReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch multiple casts using their respective hashes.\n         * @summary Bulk fetch casts\n         * @param {CastApiFetchBulkCastsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)\n         *\n         */\n        fetchBulkCasts(requestParameters, options) {\n            return localVarFp.fetchBulkCasts(requestParameters.casts, requestParameters.viewerFid, requestParameters.sortType, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all composer actions on Warpcast. You can filter by top or featured.\n         * @summary Fetch composer actions\n         * @param {CastApiFetchComposerActionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)\n         *\n         */\n        fetchComposerActions(requestParameters, options) {\n            return localVarFp.fetchComposerActions(requestParameters.list, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Crawls the given URL and returns metadata useful when embedding the URL in a cast.\n         * @summary Embedded URL metadata\n         * @param {CastApiFetchEmbeddedUrlMetadataRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)\n         *\n         */\n        fetchEmbeddedUrlMetadata(requestParameters, options) {\n            return localVarFp.fetchEmbeddedUrlMetadata(requestParameters.url, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Gets information about an individual cast by passing in a Farcaster web URL or cast hash\n         * @summary By hash or URL\n         * @param {CastApiLookupCastByHashOrWarpcastUrlRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)\n         *\n         */\n        lookupCastByHashOrWarpcastUrl(requestParameters, options) {\n            return localVarFp.lookupCastByHashOrWarpcastUrl(requestParameters.identifier, requestParameters.type, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.\n         * @summary Conversation for a cast\n         * @param {CastApiLookupCastConversationRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)\n         *\n         */\n        lookupCastConversation(requestParameters, options) {\n            return localVarFp.lookupCastConversation(requestParameters.identifier, requestParameters.type, requestParameters.replyDepth, requestParameters.includeChronologicalParentCasts, requestParameters.viewerFid, requestParameters.sortType, requestParameters.fold, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)\n         * @summary Post a cast\n         * @param {CastApiPublishCastRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)\n         *\n         */\n        publishCast(requestParameters, options) {\n            return localVarFp.publishCast(requestParameters.postCastReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Search for casts based on a query string, with optional AND filters\n         * @summary Search for casts\n         * @param {CastApiSearchCastsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)\n         *\n         */\n        searchCasts(requestParameters, options) {\n            return localVarFp.searchCasts(requestParameters.q, requestParameters.mode, requestParameters.sortType, requestParameters.authorFid, requestParameters.viewerFid, requestParameters.parentUrl, requestParameters.channelId, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.CastApiFactory = CastApiFactory;\n/**\n * CastApi - object-oriented interface\n * @export\n * @class CastApi\n * @extends {BaseAPI}\n */\nclass CastApi extends base_1.BaseAPI {\n    /**\n     * Delete an existing cast. \\\\ (In order to delete a cast `signer_uuid` must be approved)\n     * @summary Delete a cast\n     * @param {CastApiDeleteCastRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)\n     *\n     */\n    deleteCast(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).deleteCast(requestParameters.deleteCastReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch multiple casts using their respective hashes.\n     * @summary Bulk fetch casts\n     * @param {CastApiFetchBulkCastsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)\n     *\n     */\n    fetchBulkCasts(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).fetchBulkCasts(requestParameters.casts, requestParameters.viewerFid, requestParameters.sortType, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all composer actions on Warpcast. You can filter by top or featured.\n     * @summary Fetch composer actions\n     * @param {CastApiFetchComposerActionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)\n     *\n     */\n    fetchComposerActions(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).fetchComposerActions(requestParameters.list, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Crawls the given URL and returns metadata useful when embedding the URL in a cast.\n     * @summary Embedded URL metadata\n     * @param {CastApiFetchEmbeddedUrlMetadataRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)\n     *\n     */\n    fetchEmbeddedUrlMetadata(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).fetchEmbeddedUrlMetadata(requestParameters.url, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Gets information about an individual cast by passing in a Farcaster web URL or cast hash\n     * @summary By hash or URL\n     * @param {CastApiLookupCastByHashOrWarpcastUrlRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)\n     *\n     */\n    lookupCastByHashOrWarpcastUrl(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).lookupCastByHashOrWarpcastUrl(requestParameters.identifier, requestParameters.type, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.\n     * @summary Conversation for a cast\n     * @param {CastApiLookupCastConversationRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)\n     *\n     */\n    lookupCastConversation(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).lookupCastConversation(requestParameters.identifier, requestParameters.type, requestParameters.replyDepth, requestParameters.includeChronologicalParentCasts, requestParameters.viewerFid, requestParameters.sortType, requestParameters.fold, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)\n     * @summary Post a cast\n     * @param {CastApiPublishCastRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)\n     *\n     */\n    publishCast(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).publishCast(requestParameters.postCastReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Search for casts based on a query string, with optional AND filters\n     * @summary Search for casts\n     * @param {CastApiSearchCastsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastApi\n     * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)\n     *\n     */\n    searchCasts(requestParameters, options) {\n        return (0, exports.CastApiFp)(this.configuration).searchCasts(requestParameters.q, requestParameters.mode, requestParameters.sortType, requestParameters.authorFid, requestParameters.viewerFid, requestParameters.parentUrl, requestParameters.channelId, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.CastApi = CastApi;\n/**\n * @export\n */\nexports.FetchBulkCastsSortTypeEnum = {\n    Trending: 'trending',\n    Likes: 'likes',\n    Recasts: 'recasts',\n    Replies: 'replies',\n    Recent: 'recent'\n};\n/**\n * @export\n */\nexports.LookupCastConversationFoldEnum = {\n    Above: 'above',\n    Below: 'below'\n};\n/**\n * @export\n */\nexports.SearchCastsModeEnum = {\n    Literal: 'literal',\n    Semantic: 'semantic',\n    Hybrid: 'hybrid'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2Nhc3QtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxzQ0FBc0MsR0FBRyxrQ0FBa0MsR0FBRyxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsZ0NBQWdDO0FBQzNNLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2Nhc3QtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWFyY2hDYXN0c01vZGVFbnVtID0gZXhwb3J0cy5Mb29rdXBDYXN0Q29udmVyc2F0aW9uRm9sZEVudW0gPSBleHBvcnRzLkZldGNoQnVsa0Nhc3RzU29ydFR5cGVFbnVtID0gZXhwb3J0cy5DYXN0QXBpID0gZXhwb3J0cy5DYXN0QXBpRmFjdG9yeSA9IGV4cG9ydHMuQ2FzdEFwaUZwID0gZXhwb3J0cy5DYXN0QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBDYXN0QXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2FzdEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIGNhc3QuIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSBhIGNhc3QgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7RGVsZXRlQ2FzdFJlcUJvZHl9IGRlbGV0ZUNhc3RSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1jYXN0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlQ2FzdDogYXN5bmMgKGRlbGV0ZUNhc3RSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RlbGV0ZUNhc3RSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlbGV0ZUNhc3QnLCAnZGVsZXRlQ2FzdFJlcUJvZHknLCBkZWxldGVDYXN0UmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jYXN0YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShkZWxldGVDYXN0UmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggbXVsdGlwbGUgY2FzdHMgdXNpbmcgdGhlaXIgcmVzcGVjdGl2ZSBoYXNoZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1bGsgZmV0Y2ggY2FzdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNhc3RzIEhhc2hlcyBvZiB0aGUgY2FzdCB0byBiZSByZXRyaXZlZCAoQ29tbWEgc2VwYXJhdGVkLCBubyBzcGFjZXMpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBhZGRzIHZpZXdlcl9jb250ZXh0IHRvIGNhc3Qgb2JqZWN0IHRvIHNob3cgd2hldGhlciB2aWV3ZXIgaGFzIGxpa2VkIG9yIHJlY2FzdGVkIHRoZSBjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0ZldGNoQnVsa0Nhc3RzU29ydFR5cGVFbnVtfSBbc29ydFR5cGVdIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzb3J0IHRoZSBjYXN0cyBiYXNlZCBvbiBkaWZmZXJlbnQgY3JpdGVyaWFcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstY2FzdHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEJ1bGtDYXN0czogYXN5bmMgKGNhc3RzLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Nhc3RzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQnVsa0Nhc3RzJywgJ2Nhc3RzJywgY2FzdHMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2FzdHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoY2FzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Nhc3RzJ10gPSBjYXN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc29ydF90eXBlJ10gPSBzb3J0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGFsbCBjb21wb3NlciBhY3Rpb25zIG9uIFdhcnBjYXN0LiBZb3UgY2FuIGZpbHRlciBieSB0b3Agb3IgZmVhdHVyZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGNvbXBvc2VyIGFjdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtDYXN0Q29tcG9zZXJUeXBlfSBsaXN0IFR5cGUgb2YgbGlzdCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMjUpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdENvbXBvc2VyQWN0aW9uc0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RDb21wb3NlckFjdGlvbnNMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNvbXBvc2VyLWFjdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENvbXBvc2VyQWN0aW9uczogYXN5bmMgKGxpc3QsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbGlzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaENvbXBvc2VyQWN0aW9ucycsICdsaXN0JywgbGlzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jYXN0L2NvbXBvc2VyX2FjdGlvbnMvbGlzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaXN0J10gPSBsaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyYXdscyB0aGUgZ2l2ZW4gVVJMIGFuZCByZXR1cm5zIG1ldGFkYXRhIHVzZWZ1bCB3aGVuIGVtYmVkZGluZyB0aGUgVVJMIGluIGEgY2FzdC5cbiAgICAgICAgICogQHN1bW1hcnkgRW1iZWRkZWQgVVJMIG1ldGFkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIGNyYXdsIG1ldGFkYXRhIG9mXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RFbWJlZENyYXdsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0RW1iZWRDcmF3bFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1lbWJlZGRlZC11cmwtbWV0YWRhdGEpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGE6IGFzeW5jICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndXJsJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoRW1iZWRkZWRVcmxNZXRhZGF0YScsICd1cmwnLCB1cmwpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2FzdC9lbWJlZC9jcmF3bGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBhbiBpbmRpdmlkdWFsIGNhc3QgYnkgcGFzc2luZyBpbiBhIEZhcmNhc3RlciB3ZWIgVVJMIG9yIGNhc3QgaGFzaFxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBoYXNoIG9yIFVSTFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBDYXN0IGlkZW50aWZpZXIgKEl0cyBlaXRoZXIgYSB1cmwgb3IgYSBoYXNoKVxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RQYXJhbVR5cGV9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIGFkZHMgdmlld2VyX2NvbnRleHQgdG8gY2FzdCBvYmplY3QgdG8gc2hvdyB3aGV0aGVyIHZpZXdlciBoYXMgbGlrZWQgb3IgcmVjYXN0ZWQgdGhlIGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtYnktaGFzaC1vci13YXJwY2FzdC11cmwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBDYXN0QnlIYXNoT3JXYXJwY2FzdFVybDogYXN5bmMgKGlkZW50aWZpZXIsIHR5cGUsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZGVudGlmaWVyJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cENhc3RCeUhhc2hPcldhcnBjYXN0VXJsJywgJ2lkZW50aWZpZXInLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3R5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwnLCAndHlwZScsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2FzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpZGVudGlmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3R5cGUnXSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbGwgY2FzdHMgcmVsYXRlZCB0byBhIGNvbnZlcnNhdGlvbiBzdXJyb3VuZGluZyBhIGNhc3QgYnkgcGFzc2luZyBpbiBhIGNhc3QgaGFzaCBvciBGYXJjYXN0ZXIgVVJMLiBJbmNsdWRlcyBhbGwgdGhlIGFuY2VzdG9ycyBvZiBhIGNhc3QgdXAgdG8gdGhlIHJvb3QgcGFyZW50IGluIGEgY2hyb25vbG9naWNhbCBvcmRlci4gSW5jbHVkZXMgYWxsIGRpcmVjdF9yZXBsaWVzIHRvIHRoZSBjYXN0IHVwIHRvIHRoZSByZXBseV9kZXB0aCBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgICAgICogQHN1bW1hcnkgQ29udmVyc2F0aW9uIGZvciBhIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgQ2FzdCBpZGVudGlmaWVyIChJdHMgZWl0aGVyIGEgdXJsIG9yIGEgaGFzaClcbiAgICAgICAgICogQHBhcmFtIHtDYXN0UGFyYW1UeXBlfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVwbHlEZXB0aF0gVGhlIGRlcHRoIG9mIHJlcGxpZXMgaW4gdGhlIGNvbnZlcnNhdGlvbiB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgKGRlZmF1bHQgMilcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0c10gSW5jbHVkZSBhbGwgcGFyZW50IGNhc3RzIGluIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgY29udmVyc2F0aW9uIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Q2FzdENvbnZlcnNhdGlvblNvcnRUeXBlfSBbc29ydFR5cGVdIFNvcnQgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIG9mIGRlc2NlbmRhbnRzLiBEZWZhdWx0IGlzICYjeDYwO2Nocm9uJiN4NjA7XG4gICAgICAgICAqIEBwYXJhbSB7TG9va3VwQ2FzdENvbnZlcnNhdGlvbkZvbGRFbnVtfSBbZm9sZF0gU2hvdyBjb252ZXJzYXRpb24gYWJvdmUgb3IgYmVsb3cgdGhlIGZvbGQuIExvd2VyIHF1YWxpdHkgcmVzcG9uc2VzIGFyZSBoaWRkZW4gYmVsb3cgdGhlIGZvbGQuIE5vdCBwYXNzaW5nIGluIGEgdmFsdWUgc2hvd3MgdGhlIGZ1bGwgY29udmVyc2F0aW9uIHdpdGhvdXQgYW55IGZvbGRpbmcuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDUwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnZlcnNhdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENvbnZlcnNhdGlvbmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtY29udmVyc2F0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2FzdENvbnZlcnNhdGlvbjogYXN5bmMgKGlkZW50aWZpZXIsIHR5cGUsIHJlcGx5RGVwdGgsIGluY2x1ZGVDaHJvbm9sb2dpY2FsUGFyZW50Q2FzdHMsIHZpZXdlckZpZCwgc29ydFR5cGUsIGZvbGQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaWRlbnRpZmllcicgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBDYXN0Q29udmVyc2F0aW9uJywgJ2lkZW50aWZpZXInLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3R5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwQ2FzdENvbnZlcnNhdGlvbicsICd0eXBlJywgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jYXN0L2NvbnZlcnNhdGlvbmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpZGVudGlmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydpZGVudGlmaWVyJ10gPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3R5cGUnXSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwbHlEZXB0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmVwbHlfZGVwdGgnXSA9IHJlcGx5RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnaW5jbHVkZV9jaHJvbm9sb2dpY2FsX3BhcmVudF9jYXN0cyddID0gaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc29ydF90eXBlJ10gPSBzb3J0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmb2xkJ10gPSBmb2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0cyBhIGNhc3Qgb3IgY2FzdCByZXBseS4gV29ya3Mgd2l0aCBtZW50aW9ucyBhbmQgZW1iZWRzLiAgIChJbiBvcmRlciB0byBwb3N0IGEgY2FzdCBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvc3QgYSBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7UG9zdENhc3RSZXFCb2R5fSBwb3N0Q2FzdFJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UG9zdENhc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFBvc3RDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtY2FzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hDYXN0OiBhc3luYyAocG9zdENhc3RSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3Bvc3RDYXN0UmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdwdWJsaXNoQ2FzdCcsICdwb3N0Q2FzdFJlcUJvZHknLCBwb3N0Q2FzdFJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2FzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHBvc3RDYXN0UmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoIGZvciBjYXN0cyBiYXNlZCBvbiBhIHF1ZXJ5IHN0cmluZywgd2l0aCBvcHRpb25hbCBBTkQgZmlsdGVyc1xuICAgICAgICAgKiBAc3VtbWFyeSBTZWFyY2ggZm9yIGNhc3RzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxIFF1ZXJ5IHN0cmluZyB0byBzZWFyY2ggZm9yIGNhc3RzLiBTdXBwb3J0ZWQgb3BlcmF0b3JzOiAgfCBPcGVyYXRvciAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCB8ICYjeDYwOysmI3g2MDsgICAgICAgfCBBY3RzIGFzIHRoZSBBTkQgb3BlcmF0b3IuIFRoaXMgaXMgdGhlIGRlZmF1bHQgb3BlcmF0b3IgYmV0d2VlbiB0ZXJtcyBhbmQgY2FuIHVzdWFsbHkgYmUgb21pdHRlZC4gICAgICAgICB8IHwgJiN4NjA7XFxcXHwmI3g2MDsgICAgICB8IEFjdHMgYXMgdGhlIE9SIG9wZXJhdG9yLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAmI3g2MDsqJiN4NjA7ICAgICAgIHwgV2hlbiB1c2VkIGF0IHRoZSBlbmQgb2YgYSB0ZXJtLCBzaWduaWZpZXMgYSBwcmVmaXggcXVlcnkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgJiN4NjA7XFwmcXVvdDsmI3g2MDsgICAgICAgfCBXcmFwcyBzZXZlcmFsIHRlcm1zIGludG8gYSBwaHJhc2UgKGZvciBleGFtcGxlLCAmI3g2MDtcXCZxdW90O3N0YXIgd2Fyc1xcJnF1b3Q7JiN4NjA7KS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgJiN4NjA7KCYjeDYwOywgJiN4NjA7KSYjeDYwOyAgfCBXcmFwIGEgY2xhdXNlIGZvciBwcmVjZWRlbmNlIChmb3IgZXhhbXBsZSwgJiN4NjA7c3RhciArICh3YXJzIFxcXFx8IHRyZWspJiN4NjA7KS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICYjeDYwO35uJiN4NjA7ICAgICAgfCBXaGVuIHVzZWQgYWZ0ZXIgYSB0ZXJtIChmb3IgZXhhbXBsZSwgJiN4NjA7c2F0cn4zJiN4NjA7KSwgc2V0cyAmI3g2MDtmdXp6aW5lc3MmI3g2MDsuIFdoZW4gdXNlZCBhZnRlciBhIHBocmFzZSwgc2V0cyAmI3g2MDtzbG9wJiN4NjA7LiB8IHwgJiN4NjA7LSYjeDYwOyAgICAgICB8IE5lZ2F0ZXMgdGhlIHRlcm0uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAmI3g2MDtiZWZvcmU6JiN4NjA7IHwgU2VhcmNoIGZvciBjYXN0cyBiZWZvcmUgYSBzcGVjaWZpYyBkYXRlLiAoZS5nLiAmI3g2MDtiZWZvcmU6MjAyNS0wNC0yMCYjeDYwOykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgJiN4NjA7YWZ0ZXI6JiN4NjA7ICB8IFNlYXJjaCBmb3IgY2FzdHMgYWZ0ZXIgYSBzcGVjaWZpYyBkYXRlLiAoZS5nLiAmI3g2MDthZnRlcjoyMDI1LTA0LTIwJiN4NjA7KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiBAcGFyYW0ge1NlYXJjaENhc3RzTW9kZUVudW19IFttb2RlXSBDaG9pY2VzIGFyZTogLSAmI3g2MDtsaXRlcmFsJiN4NjA7IC0gU2VhcmNoZXMgZm9yIHRoZSB3b3JkcyBpbiB0aGUgcXVlcnkgc3RyaW5nIChkZWZhdWx0KSAtICYjeDYwO3NlbWFudGljJiN4NjA7IC0gU2VhcmNoZXMgZm9yIHRoZSBtZWFuaW5nIG9mIHRoZSBxdWVyeSBzdHJpbmcgLSAmI3g2MDtoeWJyaWQmI3g2MDsgLSBDb21iaW5lcyBib3RoIGxpdGVyYWwgYW5kIHNlbWFudGljIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHtTZWFyY2hTb3J0VHlwZX0gW3NvcnRUeXBlXSBDaG9pY2VzIGFyZTogLSAmI3g2MDtkZXNjX2Nocm9uJiN4NjA7IC0gQWxsIGNhc3RzIHNvcnRlZCBieSB0aW1lIChkZWZhdWx0KSAtICYjeDYwO2FsZ29yaXRobWljJiN4NjA7IC0gQ2FzdHMgc29ydGVkIGJ5IGVuZ2FnZW1lbnQgYW5kIHRpbWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFthdXRob3JGaWRdIEZpZCBvZiB0aGUgdXNlciB3aG9zZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIHNlYXJjaCByZXN1bHRzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyZW50VXJsXSBQYXJlbnQgVVJMIG9mIHRoZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFubmVsSWRdIENoYW5uZWwgSUQgb2YgdGhlIGNhc3RzIHlvdSB3YW50IHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmlvcml0eU1vZGVdIFdoZW4gdHJ1ZSwgb25seSByZXR1cm5zIHNlYXJjaCByZXN1bHRzIGZyb20gcG93ZXIgYmFkZ2UgdXNlcnMgYW5kIHVzZXJzIHRoYXQgdGhlIHZpZXdlciBmb2xsb3dzIChpZiB2aWV3ZXJfZmlkIGlzIHByb3ZpZGVkKS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlYXJjaC1jYXN0cylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaENhc3RzOiBhc3luYyAocSwgbW9kZSwgc29ydFR5cGUsIGF1dGhvckZpZCwgdmlld2VyRmlkLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgcHJpb3JpdHlNb2RlLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3EnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnc2VhcmNoQ2FzdHMnLCAncScsIHEpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2FzdC9zZWFyY2hgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncSddID0gcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydtb2RlJ10gPSBtb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzb3J0X3R5cGUnXSA9IHNvcnRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1dGhvckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYXV0aG9yX2ZpZCddID0gYXV0aG9yRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFyZW50X3VybCddID0gcGFyZW50VXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5uZWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY2hhbm5lbF9pZCddID0gY2hhbm5lbElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW9yaXR5TW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJpb3JpdHlfbW9kZSddID0gcHJpb3JpdHlNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNhc3RBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENhc3RBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQ2FzdEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENhc3RBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNhc3RBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBjYXN0LiBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSBjYXN0IGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0RlbGV0ZUNhc3RSZXFCb2R5fSBkZWxldGVDYXN0UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtY2FzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZUNhc3QoZGVsZXRlQ2FzdFJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZUNhc3QoZGVsZXRlQ2FzdFJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDYXN0QXBpLmRlbGV0ZUNhc3QnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIG11bHRpcGxlIGNhc3RzIHVzaW5nIHRoZWlyIHJlc3BlY3RpdmUgaGFzaGVzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCdWxrIGZldGNoIGNhc3RzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXN0cyBIYXNoZXMgb2YgdGhlIGNhc3QgdG8gYmUgcmV0cml2ZWQgKENvbW1hIHNlcGFyYXRlZCwgbm8gc3BhY2VzKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gYWRkcyB2aWV3ZXJfY29udGV4dCB0byBjYXN0IG9iamVjdCB0byBzaG93IHdoZXRoZXIgdmlld2VyIGhhcyBsaWtlZCBvciByZWNhc3RlZCB0aGUgY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtGZXRjaEJ1bGtDYXN0c1NvcnRUeXBlRW51bX0gW3NvcnRUeXBlXSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc29ydCB0aGUgY2FzdHMgYmFzZWQgb24gZGlmZmVyZW50IGNyaXRlcmlhXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0c1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1idWxrLWNhc3RzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hCdWxrQ2FzdHMoY2FzdHMsIHZpZXdlckZpZCwgc29ydFR5cGUsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQnVsa0Nhc3RzKGNhc3RzLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2FzdEFwaS5mZXRjaEJ1bGtDYXN0cyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgY29tcG9zZXIgYWN0aW9ucyBvbiBXYXJwY2FzdC4gWW91IGNhbiBmaWx0ZXIgYnkgdG9wIG9yIGZlYXR1cmVkLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBjb21wb3NlciBhY3Rpb25zXG4gICAgICAgICAqIEBwYXJhbSB7Q2FzdENvbXBvc2VyVHlwZX0gbGlzdCBUeXBlIG9mIGxpc3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDI1KVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RDb21wb3NlckFjdGlvbnNMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0Q29tcG9zZXJBY3Rpb25zTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jb21wb3Nlci1hY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hDb21wb3NlckFjdGlvbnMobGlzdCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hDb21wb3NlckFjdGlvbnMobGlzdCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Nhc3RBcGkuZmV0Y2hDb21wb3NlckFjdGlvbnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyYXdscyB0aGUgZ2l2ZW4gVVJMIGFuZCByZXR1cm5zIG1ldGFkYXRhIHVzZWZ1bCB3aGVuIGVtYmVkZGluZyB0aGUgVVJMIGluIGEgY2FzdC5cbiAgICAgICAgICogQHN1bW1hcnkgRW1iZWRkZWQgVVJMIG1ldGFkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIGNyYXdsIG1ldGFkYXRhIG9mXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RFbWJlZENyYXdsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0RW1iZWRDcmF3bFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1lbWJlZGRlZC11cmwtbWV0YWRhdGEpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGEodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGEodXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2FzdEFwaS5mZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGEnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kaXZpZHVhbCBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBGYXJjYXN0ZXIgd2ViIFVSTCBvciBjYXN0IGhhc2hcbiAgICAgICAgICogQHN1bW1hcnkgQnkgaGFzaCBvciBVUkxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgQ2FzdCBpZGVudGlmaWVyIChJdHMgZWl0aGVyIGEgdXJsIG9yIGEgaGFzaClcbiAgICAgICAgICogQHBhcmFtIHtDYXN0UGFyYW1UeXBlfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBhZGRzIHZpZXdlcl9jb250ZXh0IHRvIGNhc3Qgb2JqZWN0IHRvIHNob3cgd2hldGhlciB2aWV3ZXIgaGFzIGxpa2VkIG9yIHJlY2FzdGVkIHRoZSBjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWJ5LWhhc2gtb3Itd2FycGNhc3QtdXJsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwoaWRlbnRpZmllciwgdHlwZSwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5sb29rdXBDYXN0QnlIYXNoT3JXYXJwY2FzdFVybChpZGVudGlmaWVyLCB0eXBlLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDYXN0QXBpLmxvb2t1cENhc3RCeUhhc2hPcldhcnBjYXN0VXJsJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFsbCBjYXN0cyByZWxhdGVkIHRvIGEgY29udmVyc2F0aW9uIHN1cnJvdW5kaW5nIGEgY2FzdCBieSBwYXNzaW5nIGluIGEgY2FzdCBoYXNoIG9yIEZhcmNhc3RlciBVUkwuIEluY2x1ZGVzIGFsbCB0aGUgYW5jZXN0b3JzIG9mIGEgY2FzdCB1cCB0byB0aGUgcm9vdCBwYXJlbnQgaW4gYSBjaHJvbm9sb2dpY2FsIG9yZGVyLiBJbmNsdWRlcyBhbGwgZGlyZWN0X3JlcGxpZXMgdG8gdGhlIGNhc3QgdXAgdG8gdGhlIHJlcGx5X2RlcHRoIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBDb252ZXJzYXRpb24gZm9yIGEgY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBDYXN0IGlkZW50aWZpZXIgKEl0cyBlaXRoZXIgYSB1cmwgb3IgYSBoYXNoKVxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RQYXJhbVR5cGV9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXBseURlcHRoXSBUaGUgZGVwdGggb2YgcmVwbGllcyBpbiB0aGUgY29udmVyc2F0aW9uIHRoYXQgd2lsbCBiZSByZXR1cm5lZCAoZGVmYXVsdCAyKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzXSBJbmNsdWRlIGFsbCBwYXJlbnQgY2FzdHMgaW4gY2hyb25vbG9naWNhbCBvcmRlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBjb252ZXJzYXRpb24gdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtDYXN0Q29udmVyc2F0aW9uU29ydFR5cGV9IFtzb3J0VHlwZV0gU29ydCB0eXBlIGZvciB0aGUgb3JkZXJpbmcgb2YgZGVzY2VuZGFudHMuIERlZmF1bHQgaXMgJiN4NjA7Y2hyb24mI3g2MDtcbiAgICAgICAgICogQHBhcmFtIHtMb29rdXBDYXN0Q29udmVyc2F0aW9uRm9sZEVudW19IFtmb2xkXSBTaG93IGNvbnZlcnNhdGlvbiBhYm92ZSBvciBiZWxvdyB0aGUgZm9sZC4gTG93ZXIgcXVhbGl0eSByZXNwb25zZXMgYXJlIGhpZGRlbiBiZWxvdyB0aGUgZm9sZC4gTm90IHBhc3NpbmcgaW4gYSB2YWx1ZSBzaG93cyB0aGUgZnVsbCBjb252ZXJzYXRpb24gd2l0aG91dCBhbnkgZm9sZGluZy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogNTApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q29udmVyc2F0aW9uPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ29udmVyc2F0aW9uYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2FzdC1jb252ZXJzYXRpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsb29rdXBDYXN0Q29udmVyc2F0aW9uKGlkZW50aWZpZXIsIHR5cGUsIHJlcGx5RGVwdGgsIGluY2x1ZGVDaHJvbm9sb2dpY2FsUGFyZW50Q2FzdHMsIHZpZXdlckZpZCwgc29ydFR5cGUsIGZvbGQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cENhc3RDb252ZXJzYXRpb24oaWRlbnRpZmllciwgdHlwZSwgcmVwbHlEZXB0aCwgaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0cywgdmlld2VyRmlkLCBzb3J0VHlwZSwgZm9sZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Nhc3RBcGkubG9va3VwQ2FzdENvbnZlcnNhdGlvbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdHMgYSBjYXN0IG9yIGNhc3QgcmVwbHkuIFdvcmtzIHdpdGggbWVudGlvbnMgYW5kIGVtYmVkcy4gICAoSW4gb3JkZXIgdG8gcG9zdCBhIGNhc3QgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBQb3N0IGEgY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge1Bvc3RDYXN0UmVxQm9keX0gcG9zdENhc3RSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFBvc3RDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBQb3N0Q2FzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLWNhc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBwdWJsaXNoQ2FzdChwb3N0Q2FzdFJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hDYXN0KHBvc3RDYXN0UmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Nhc3RBcGkucHVibGlzaENhc3QnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaCBmb3IgY2FzdHMgYmFzZWQgb24gYSBxdWVyeSBzdHJpbmcsIHdpdGggb3B0aW9uYWwgQU5EIGZpbHRlcnNcbiAgICAgICAgICogQHN1bW1hcnkgU2VhcmNoIGZvciBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcSBRdWVyeSBzdHJpbmcgdG8gc2VhcmNoIGZvciBjYXN0cy4gU3VwcG9ydGVkIG9wZXJhdG9yczogIHwgT3BlcmF0b3IgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8IC0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgfCAmI3g2MDsrJiN4NjA7ICAgICAgIHwgQWN0cyBhcyB0aGUgQU5EIG9wZXJhdG9yLiBUaGlzIGlzIHRoZSBkZWZhdWx0IG9wZXJhdG9yIGJldHdlZW4gdGVybXMgYW5kIGNhbiB1c3VhbGx5IGJlIG9taXR0ZWQuICAgICAgICAgfCB8ICYjeDYwO1xcXFx8JiN4NjA7ICAgICAgfCBBY3RzIGFzIHRoZSBPUiBvcGVyYXRvci4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgJiN4NjA7KiYjeDYwOyAgICAgICB8IFdoZW4gdXNlZCBhdCB0aGUgZW5kIG9mIGEgdGVybSwgc2lnbmlmaWVzIGEgcHJlZml4IHF1ZXJ5LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICYjeDYwO1xcJnF1b3Q7JiN4NjA7ICAgICAgIHwgV3JhcHMgc2V2ZXJhbCB0ZXJtcyBpbnRvIGEgcGhyYXNlIChmb3IgZXhhbXBsZSwgJiN4NjA7XFwmcXVvdDtzdGFyIHdhcnNcXCZxdW90OyYjeDYwOykuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICYjeDYwOygmI3g2MDssICYjeDYwOykmI3g2MDsgIHwgV3JhcCBhIGNsYXVzZSBmb3IgcHJlY2VkZW5jZSAoZm9yIGV4YW1wbGUsICYjeDYwO3N0YXIgKyAod2FycyBcXFxcfCB0cmVrKSYjeDYwOykuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAmI3g2MDt+biYjeDYwOyAgICAgIHwgV2hlbiB1c2VkIGFmdGVyIGEgdGVybSAoZm9yIGV4YW1wbGUsICYjeDYwO3NhdHJ+MyYjeDYwOyksIHNldHMgJiN4NjA7ZnV6emluZXNzJiN4NjA7LiBXaGVuIHVzZWQgYWZ0ZXIgYSBwaHJhc2UsIHNldHMgJiN4NjA7c2xvcCYjeDYwOy4gfCB8ICYjeDYwOy0mI3g2MDsgICAgICAgfCBOZWdhdGVzIHRoZSB0ZXJtLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgJiN4NjA7YmVmb3JlOiYjeDYwOyB8IFNlYXJjaCBmb3IgY2FzdHMgYmVmb3JlIGEgc3BlY2lmaWMgZGF0ZS4gKGUuZy4gJiN4NjA7YmVmb3JlOjIwMjUtMDQtMjAmI3g2MDspICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICYjeDYwO2FmdGVyOiYjeDYwOyAgfCBTZWFyY2ggZm9yIGNhc3RzIGFmdGVyIGEgc3BlY2lmaWMgZGF0ZS4gKGUuZy4gJiN4NjA7YWZ0ZXI6MjAyNS0wNC0yMCYjeDYwOykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogQHBhcmFtIHtTZWFyY2hDYXN0c01vZGVFbnVtfSBbbW9kZV0gQ2hvaWNlcyBhcmU6IC0gJiN4NjA7bGl0ZXJhbCYjeDYwOyAtIFNlYXJjaGVzIGZvciB0aGUgd29yZHMgaW4gdGhlIHF1ZXJ5IHN0cmluZyAoZGVmYXVsdCkgLSAmI3g2MDtzZW1hbnRpYyYjeDYwOyAtIFNlYXJjaGVzIGZvciB0aGUgbWVhbmluZyBvZiB0aGUgcXVlcnkgc3RyaW5nIC0gJiN4NjA7aHlicmlkJiN4NjA7IC0gQ29tYmluZXMgYm90aCBsaXRlcmFsIGFuZCBzZW1hbnRpYyByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7U2VhcmNoU29ydFR5cGV9IFtzb3J0VHlwZV0gQ2hvaWNlcyBhcmU6IC0gJiN4NjA7ZGVzY19jaHJvbiYjeDYwOyAtIEFsbCBjYXN0cyBzb3J0ZWQgYnkgdGltZSAoZGVmYXVsdCkgLSAmI3g2MDthbGdvcml0aG1pYyYjeDYwOyAtIENhc3RzIHNvcnRlZCBieSBlbmdhZ2VtZW50IGFuZCB0aW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXV0aG9yRmlkXSBGaWQgb2YgdGhlIHVzZXIgd2hvc2UgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBzZWFyY2ggcmVzdWx0cyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmVudFVybF0gUGFyZW50IFVSTCBvZiB0aGUgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhbm5lbElkXSBDaGFubmVsIElEIG9mIHRoZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJpb3JpdHlNb2RlXSBXaGVuIHRydWUsIG9ubHkgcmV0dXJucyBzZWFyY2ggcmVzdWx0cyBmcm9tIHBvd2VyIGJhZGdlIHVzZXJzIGFuZCB1c2VycyB0aGF0IHRoZSB2aWV3ZXIgZm9sbG93cyAoaWYgdmlld2VyX2ZpZCBpcyBwcm92aWRlZCkuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RzU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0c1NlYXJjaFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2FzdHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzZWFyY2hDYXN0cyhxLCBtb2RlLCBzb3J0VHlwZSwgYXV0aG9yRmlkLCB2aWV3ZXJGaWQsIHBhcmVudFVybCwgY2hhbm5lbElkLCBwcmlvcml0eU1vZGUsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnNlYXJjaENhc3RzKHEsIG1vZGUsIHNvcnRUeXBlLCBhdXRob3JGaWQsIHZpZXdlckZpZCwgcGFyZW50VXJsLCBjaGFubmVsSWQsIHByaW9yaXR5TW9kZSwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Nhc3RBcGkuc2VhcmNoQ2FzdHMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ2FzdEFwaUZwID0gQ2FzdEFwaUZwO1xuLyoqXG4gKiBDYXN0QXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2FzdEFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkNhc3RBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBjYXN0LiBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSBjYXN0IGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RBcGlEZWxldGVDYXN0UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtY2FzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUNhc3QocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmRlbGV0ZUNhc3QocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2FzdFJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBtdWx0aXBsZSBjYXN0cyB1c2luZyB0aGVpciByZXNwZWN0aXZlIGhhc2hlcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnVsayBmZXRjaCBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RBcGlGZXRjaEJ1bGtDYXN0c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstY2FzdHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEJ1bGtDYXN0cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hCdWxrQ2FzdHMocmVxdWVzdFBhcmFtZXRlcnMuY2FzdHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuc29ydFR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGFsbCBjb21wb3NlciBhY3Rpb25zIG9uIFdhcnBjYXN0LiBZb3UgY2FuIGZpbHRlciBieSB0b3Agb3IgZmVhdHVyZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGNvbXBvc2VyIGFjdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtDYXN0QXBpRmV0Y2hDb21wb3NlckFjdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RDb21wb3NlckFjdGlvbnNMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0Q29tcG9zZXJBY3Rpb25zTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jb21wb3Nlci1hY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDb21wb3NlckFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ29tcG9zZXJBY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmxpc3QsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmF3bHMgdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJucyBtZXRhZGF0YSB1c2VmdWwgd2hlbiBlbWJlZGRpbmcgdGhlIFVSTCBpbiBhIGNhc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtYmVkZGVkIFVSTCBtZXRhZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RBcGlGZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGFSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RFbWJlZENyYXdsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0RW1iZWRDcmF3bFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1lbWJlZGRlZC11cmwtbWV0YWRhdGEpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGEocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoRW1iZWRkZWRVcmxNZXRhZGF0YShyZXF1ZXN0UGFyYW1ldGVycy51cmwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGl2aWR1YWwgY2FzdCBieSBwYXNzaW5nIGluIGEgRmFyY2FzdGVyIHdlYiBVUkwgb3IgY2FzdCBoYXNoXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGhhc2ggb3IgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7Q2FzdEFwaUxvb2t1cENhc3RCeUhhc2hPcldhcnBjYXN0VXJsUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWJ5LWhhc2gtb3Itd2FycGNhc3QtdXJsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cENhc3RCeUhhc2hPcldhcnBjYXN0VXJsKHJlcXVlc3RQYXJhbWV0ZXJzLmlkZW50aWZpZXIsIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYWxsIGNhc3RzIHJlbGF0ZWQgdG8gYSBjb252ZXJzYXRpb24gc3Vycm91bmRpbmcgYSBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBjYXN0IGhhc2ggb3IgRmFyY2FzdGVyIFVSTC4gSW5jbHVkZXMgYWxsIHRoZSBhbmNlc3RvcnMgb2YgYSBjYXN0IHVwIHRvIHRoZSByb290IHBhcmVudCBpbiBhIGNocm9ub2xvZ2ljYWwgb3JkZXIuIEluY2x1ZGVzIGFsbCBkaXJlY3RfcmVwbGllcyB0byB0aGUgY2FzdCB1cCB0byB0aGUgcmVwbHlfZGVwdGggc3BlY2lmaWVkIGluIHRoZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IENvbnZlcnNhdGlvbiBmb3IgYSBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7Q2FzdEFwaUxvb2t1cENhc3RDb252ZXJzYXRpb25SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnZlcnNhdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENvbnZlcnNhdGlvbmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtY29udmVyc2F0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2FzdENvbnZlcnNhdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwQ2FzdENvbnZlcnNhdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5pZGVudGlmaWVyLCByZXF1ZXN0UGFyYW1ldGVycy50eXBlLCByZXF1ZXN0UGFyYW1ldGVycy5yZXBseURlcHRoLCByZXF1ZXN0UGFyYW1ldGVycy5pbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnNvcnRUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5mb2xkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdHMgYSBjYXN0IG9yIGNhc3QgcmVwbHkuIFdvcmtzIHdpdGggbWVudGlvbnMgYW5kIGVtYmVkcy4gICAoSW4gb3JkZXIgdG8gcG9zdCBhIGNhc3QgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBQb3N0IGEgY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RBcGlQdWJsaXNoQ2FzdFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UG9zdENhc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFBvc3RDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtY2FzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hDYXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoQ2FzdChyZXF1ZXN0UGFyYW1ldGVycy5wb3N0Q2FzdFJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2ggZm9yIGNhc3RzIGJhc2VkIG9uIGEgcXVlcnkgc3RyaW5nLCB3aXRoIG9wdGlvbmFsIEFORCBmaWx0ZXJzXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBmb3IgY2FzdHNcbiAgICAgICAgICogQHBhcmFtIHtDYXN0QXBpU2VhcmNoQ2FzdHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RzU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0c1NlYXJjaFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2FzdHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBzZWFyY2hDYXN0cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuc2VhcmNoQ2FzdHMocmVxdWVzdFBhcmFtZXRlcnMucSwgcmVxdWVzdFBhcmFtZXRlcnMubW9kZSwgcmVxdWVzdFBhcmFtZXRlcnMuc29ydFR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLmF1dGhvckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRVcmwsIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxJZCwgcmVxdWVzdFBhcmFtZXRlcnMucHJpb3JpdHlNb2RlLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5DYXN0QXBpRmFjdG9yeSA9IENhc3RBcGlGYWN0b3J5O1xuLyoqXG4gKiBDYXN0QXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIENhc3RBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBDYXN0QXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBjYXN0LiBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSBjYXN0IGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSBjYXN0XG4gICAgICogQHBhcmFtIHtDYXN0QXBpRGVsZXRlQ2FzdFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENhc3RBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLWNhc3QpXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVDYXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DYXN0QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZGVsZXRlQ2FzdChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDYXN0UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIG11bHRpcGxlIGNhc3RzIHVzaW5nIHRoZWlyIHJlc3BlY3RpdmUgaGFzaGVzLlxuICAgICAqIEBzdW1tYXJ5IEJ1bGsgZmV0Y2ggY2FzdHNcbiAgICAgKiBAcGFyYW0ge0Nhc3RBcGlGZXRjaEJ1bGtDYXN0c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENhc3RBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0c1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstY2FzdHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEJ1bGtDYXN0cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoQnVsa0Nhc3RzKHJlcXVlc3RQYXJhbWV0ZXJzLmNhc3RzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnNvcnRUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgY29tcG9zZXIgYWN0aW9ucyBvbiBXYXJwY2FzdC4gWW91IGNhbiBmaWx0ZXIgYnkgdG9wIG9yIGZlYXR1cmVkLlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGNvbXBvc2VyIGFjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Nhc3RBcGlGZXRjaENvbXBvc2VyQWN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENhc3RBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0Q29tcG9zZXJBY3Rpb25zTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdENvbXBvc2VyQWN0aW9uc0xpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNvbXBvc2VyLWFjdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaENvbXBvc2VyQWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoQ29tcG9zZXJBY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmxpc3QsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmF3bHMgdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJucyBtZXRhZGF0YSB1c2VmdWwgd2hlbiBlbWJlZGRpbmcgdGhlIFVSTCBpbiBhIGNhc3QuXG4gICAgICogQHN1bW1hcnkgRW1iZWRkZWQgVVJMIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtDYXN0QXBpRmV0Y2hFbWJlZGRlZFVybE1ldGFkYXRhUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2FzdEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RFbWJlZENyYXdsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0RW1iZWRDcmF3bFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZW1iZWRkZWQtdXJsLW1ldGFkYXRhKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hFbWJlZGRlZFVybE1ldGFkYXRhKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DYXN0QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hFbWJlZGRlZFVybE1ldGFkYXRhKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kaXZpZHVhbCBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBGYXJjYXN0ZXIgd2ViIFVSTCBvciBjYXN0IGhhc2hcbiAgICAgKiBAc3VtbWFyeSBCeSBoYXNoIG9yIFVSTFxuICAgICAqIEBwYXJhbSB7Q2FzdEFwaUxvb2t1cENhc3RCeUhhc2hPcldhcnBjYXN0VXJsUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2FzdEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWJ5LWhhc2gtb3Itd2FycGNhc3QtdXJsKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNhc3RBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBDYXN0QnlIYXNoT3JXYXJwY2FzdFVybChyZXF1ZXN0UGFyYW1ldGVycy5pZGVudGlmaWVyLCByZXF1ZXN0UGFyYW1ldGVycy50eXBlLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBjYXN0cyByZWxhdGVkIHRvIGEgY29udmVyc2F0aW9uIHN1cnJvdW5kaW5nIGEgY2FzdCBieSBwYXNzaW5nIGluIGEgY2FzdCBoYXNoIG9yIEZhcmNhc3RlciBVUkwuIEluY2x1ZGVzIGFsbCB0aGUgYW5jZXN0b3JzIG9mIGEgY2FzdCB1cCB0byB0aGUgcm9vdCBwYXJlbnQgaW4gYSBjaHJvbm9sb2dpY2FsIG9yZGVyLiBJbmNsdWRlcyBhbGwgZGlyZWN0X3JlcGxpZXMgdG8gdGhlIGNhc3QgdXAgdG8gdGhlIHJlcGx5X2RlcHRoIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkgcGFyYW1ldGVyLlxuICAgICAqIEBzdW1tYXJ5IENvbnZlcnNhdGlvbiBmb3IgYSBjYXN0XG4gICAgICogQHBhcmFtIHtDYXN0QXBpTG9va3VwQ2FzdENvbnZlcnNhdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENhc3RBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb252ZXJzYXRpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDb252ZXJzYXRpb25gIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2FzdC1jb252ZXJzYXRpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBDYXN0Q29udmVyc2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DYXN0QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwQ2FzdENvbnZlcnNhdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5pZGVudGlmaWVyLCByZXF1ZXN0UGFyYW1ldGVycy50eXBlLCByZXF1ZXN0UGFyYW1ldGVycy5yZXBseURlcHRoLCByZXF1ZXN0UGFyYW1ldGVycy5pbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnNvcnRUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5mb2xkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zdHMgYSBjYXN0IG9yIGNhc3QgcmVwbHkuIFdvcmtzIHdpdGggbWVudGlvbnMgYW5kIGVtYmVkcy4gICAoSW4gb3JkZXIgdG8gcG9zdCBhIGNhc3QgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IFBvc3QgYSBjYXN0XG4gICAgICogQHBhcmFtIHtDYXN0QXBpUHVibGlzaENhc3RSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDYXN0QXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UG9zdENhc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFBvc3RDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLWNhc3QpXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaXNoQ2FzdChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnB1Ymxpc2hDYXN0KHJlcXVlc3RQYXJhbWV0ZXJzLnBvc3RDYXN0UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgY2FzdHMgYmFzZWQgb24gYSBxdWVyeSBzdHJpbmcsIHdpdGggb3B0aW9uYWwgQU5EIGZpbHRlcnNcbiAgICAgKiBAc3VtbWFyeSBTZWFyY2ggZm9yIGNhc3RzXG4gICAgICogQHBhcmFtIHtDYXN0QXBpU2VhcmNoQ2FzdHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDYXN0QXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2FzdHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hDYXN0cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnNlYXJjaENhc3RzKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLm1vZGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnNvcnRUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5hdXRob3JGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50VXJsLCByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnByaW9yaXR5TW9kZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYXN0QXBpID0gQ2FzdEFwaTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkZldGNoQnVsa0Nhc3RzU29ydFR5cGVFbnVtID0ge1xuICAgIFRyZW5kaW5nOiAndHJlbmRpbmcnLFxuICAgIExpa2VzOiAnbGlrZXMnLFxuICAgIFJlY2FzdHM6ICdyZWNhc3RzJyxcbiAgICBSZXBsaWVzOiAncmVwbGllcycsXG4gICAgUmVjZW50OiAncmVjZW50J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkxvb2t1cENhc3RDb252ZXJzYXRpb25Gb2xkRW51bSA9IHtcbiAgICBBYm92ZTogJ2Fib3ZlJyxcbiAgICBCZWxvdzogJ2JlbG93J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLlNlYXJjaENhc3RzTW9kZUVudW0gPSB7XG4gICAgTGl0ZXJhbDogJ2xpdGVyYWwnLFxuICAgIFNlbWFudGljOiAnc2VtYW50aWMnLFxuICAgIEh5YnJpZDogJ2h5YnJpZCdcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/cast-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/channel-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/channel-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchTrendingChannelsTimeWindowEnum = exports.ChannelApi = exports.ChannelApiFactory = exports.ChannelApiFp = exports.ChannelApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * ChannelApi - axios parameter creator\n * @export\n */\nconst ChannelApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Returns a list of all channels with their details\n         * @summary Fetch all channels with their details\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)\n         *\n         */\n        fetchAllChannels: async (limit, cursor, options = {}) => {\n            const localVarPath = `/farcaster/channel/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns details of multiple channels\n         * @summary Bulk fetch\n         * @param {string} ids Comma separated list of channel IDs or parent_urls, up to 100 at a time\n         * @param {ChannelType} [type] Type of identifier being used to query the channels. Defaults to ID.\n         * @param {number} [viewerFid] FID of the user viewing the channels.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)\n         *\n         */\n        fetchBulkChannels: async (ids, type, viewerFid, options = {}) => {\n            // verify required parameter 'ids' is not null or undefined\n            (0, common_1.assertParamExists)('fetchBulkChannels', 'ids', ids);\n            const localVarPath = `/farcaster/channel/bulk`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (ids !== undefined) {\n                localVarQueryParameter['ids'] = ids;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.\n         * @summary Open invites\n         * @param {string} [channelId] Channel ID for the channel being queried\n         * @param {number} [invitedFid] FID of the user being invited\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)\n         *\n         */\n        fetchChannelInvites: async (channelId, invitedFid, limit, cursor, options = {}) => {\n            const localVarPath = `/farcaster/channel/member/invite/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (invitedFid !== undefined) {\n                localVarQueryParameter['invited_fid'] = invitedFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of members in a channel\n         * @summary Fetch members\n         * @param {string} channelId Channel ID for the channel being queried\n         * @param {number} [fid] FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)\n         *\n         */\n        fetchChannelMembers: async (channelId, fid, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'channelId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchChannelMembers', 'channelId', channelId);\n            const localVarPath = `/farcaster/channel/member/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.\n         * @summary For channel\n         * @param {string} id Channel ID for the channel being queried\n         * @param {number} [viewerFid] Providing this will return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [limit] Number of followers to fetch  (Default: 25, Maximum: 1000)\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)\n         *\n         */\n        fetchFollowersForAChannel: async (id, viewerFid, cursor, limit, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'id' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFollowersForAChannel', 'id', id);\n            const localVarPath = `/farcaster/channel/followers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (id !== undefined) {\n                localVarQueryParameter['id'] = id;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \\\"X, Y, Z follow this channel\\\".\n         * @summary Relevant followers\n         * @param {string} id Channel ID being queried\n         * @param {number} viewerFid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)\n         *\n         */\n        fetchRelevantFollowersForAChannel: async (id, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'id' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFollowersForAChannel', 'id', id);\n            // verify required parameter 'viewerFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFollowersForAChannel', 'viewerFid', viewerFid);\n            const localVarPath = `/farcaster/channel/followers/relevant`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (id !== undefined) {\n                localVarQueryParameter['id'] = id;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of trending channels based on activity\n         * @summary Channels by activity\n         * @param {FetchTrendingChannelsTimeWindowEnum} [timeWindow]\n         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)\n         *\n         */\n        fetchTrendingChannels: async (timeWindow, limit, cursor, options = {}) => {\n            const localVarPath = `/farcaster/channel/trending`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (timeWindow !== undefined) {\n                localVarQueryParameter['time_window'] = timeWindow;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.\n         * @summary Member of\n         * @param {number} fid The FID of the user.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)\n         *\n         */\n        fetchUserChannelMemberships: async (fid, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserChannelMemberships', 'fid', fid);\n            const localVarPath = `/farcaster/user/memberships/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of all channels with their details that a FID follows.\n         * @summary Following\n         * @param {number} fid The FID of the user.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)\n         *\n         */\n        fetchUserChannels: async (fid, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserChannels', 'fid', fid);\n            const localVarPath = `/farcaster/user/channels`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all channels that a user has casted in, in reverse chronological order.\n         * @summary Fetch channels that user is active in\n         * @param {number} fid The user\\&#39;s FID (identifier)\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)\n         *\n         */\n        fetchUsersActiveChannels: async (fid, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsersActiveChannels', 'fid', fid);\n            const localVarPath = `/farcaster/channel/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Follow a channel\n         * @summary Follow a channel\n         * @param {ChannelFollowReqBody} channelFollowReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)\n         *\n         */\n        followChannel: async (channelFollowReqBody, options = {}) => {\n            // verify required parameter 'channelFollowReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('followChannel', 'channelFollowReqBody', channelFollowReqBody);\n            const localVarPath = `/farcaster/channel/follow`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channelFollowReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Invite a user to a channel\n         * @summary Invite\n         * @param {InviteChannelMemberReqBody} inviteChannelMemberReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)\n         *\n         */\n        inviteChannelMember: async (inviteChannelMemberReqBody, options = {}) => {\n            // verify required parameter 'inviteChannelMemberReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('inviteChannelMember', 'inviteChannelMemberReqBody', inviteChannelMemberReqBody);\n            const localVarPath = `/farcaster/channel/member/invite`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(inviteChannelMemberReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns details of a channel\n         * @summary By ID or parent_url\n         * @param {string} id Channel ID for the channel being queried\n         * @param {ChannelType} [type] Type of identifier being used to query the channel. Defaults to ID.\n         * @param {number} [viewerFid] FID of the user viewing the channel.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)\n         *\n         */\n        lookupChannel: async (id, type, viewerFid, options = {}) => {\n            // verify required parameter 'id' is not null or undefined\n            (0, common_1.assertParamExists)('lookupChannel', 'id', id);\n            const localVarPath = `/farcaster/channel`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (id !== undefined) {\n                localVarQueryParameter['id'] = id;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Remove a user from a channel or a user\\'s invite to a channel role\n         * @summary Remove user\n         * @param {RemoveChannelMemberReqBody} removeChannelMemberReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)\n         *\n         */\n        removeChannelMember: async (removeChannelMemberReqBody, options = {}) => {\n            // verify required parameter 'removeChannelMemberReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('removeChannelMember', 'removeChannelMemberReqBody', removeChannelMemberReqBody);\n            const localVarPath = `/farcaster/channel/member`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeChannelMemberReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Accept or reject a channel invite\n         * @summary Accept or reject an invite\n         * @param {RespondChannelInviteReqBody} respondChannelInviteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)\n         *\n         */\n        respondChannelInvite: async (respondChannelInviteReqBody, options = {}) => {\n            // verify required parameter 'respondChannelInviteReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('respondChannelInvite', 'respondChannelInviteReqBody', respondChannelInviteReqBody);\n            const localVarPath = `/farcaster/channel/member/invite`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(respondChannelInviteReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of channels based on ID or name\n         * @summary Search by ID or name\n         * @param {string} q Channel ID or name for the channel being queried\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)\n         *\n         */\n        searchChannels: async (q, limit, cursor, options = {}) => {\n            // verify required parameter 'q' is not null or undefined\n            (0, common_1.assertParamExists)('searchChannels', 'q', q);\n            const localVarPath = `/farcaster/channel/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (q !== undefined) {\n                localVarQueryParameter['q'] = q;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Unfollow a channel\n         * @summary Unfollow a channel\n         * @param {ChannelFollowReqBody} channelFollowReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)\n         *\n         */\n        unfollowChannel: async (channelFollowReqBody, options = {}) => {\n            // verify required parameter 'channelFollowReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('unfollowChannel', 'channelFollowReqBody', channelFollowReqBody);\n            const localVarPath = `/farcaster/channel/follow`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(channelFollowReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ChannelApiAxiosParamCreator = ChannelApiAxiosParamCreator;\n/**\n * ChannelApi - functional programming interface\n * @export\n */\nconst ChannelApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ChannelApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Returns a list of all channels with their details\n         * @summary Fetch all channels with their details\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)\n         *\n         */\n        async fetchAllChannels(limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAllChannels(limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchAllChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns details of multiple channels\n         * @summary Bulk fetch\n         * @param {string} ids Comma separated list of channel IDs or parent_urls, up to 100 at a time\n         * @param {ChannelType} [type] Type of identifier being used to query the channels. Defaults to ID.\n         * @param {number} [viewerFid] FID of the user viewing the channels.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)\n         *\n         */\n        async fetchBulkChannels(ids, type, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkChannels(ids, type, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchBulkChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.\n         * @summary Open invites\n         * @param {string} [channelId] Channel ID for the channel being queried\n         * @param {number} [invitedFid] FID of the user being invited\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)\n         *\n         */\n        async fetchChannelInvites(channelId, invitedFid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchChannelInvites(channelId, invitedFid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchChannelInvites']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of members in a channel\n         * @summary Fetch members\n         * @param {string} channelId Channel ID for the channel being queried\n         * @param {number} [fid] FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)\n         *\n         */\n        async fetchChannelMembers(channelId, fid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchChannelMembers(channelId, fid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchChannelMembers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.\n         * @summary For channel\n         * @param {string} id Channel ID for the channel being queried\n         * @param {number} [viewerFid] Providing this will return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [limit] Number of followers to fetch  (Default: 25, Maximum: 1000)\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)\n         *\n         */\n        async fetchFollowersForAChannel(id, viewerFid, cursor, limit, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFollowersForAChannel(id, viewerFid, cursor, limit, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchFollowersForAChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \\\"X, Y, Z follow this channel\\\".\n         * @summary Relevant followers\n         * @param {string} id Channel ID being queried\n         * @param {number} viewerFid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)\n         *\n         */\n        async fetchRelevantFollowersForAChannel(id, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFollowersForAChannel(id, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchRelevantFollowersForAChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of trending channels based on activity\n         * @summary Channels by activity\n         * @param {FetchTrendingChannelsTimeWindowEnum} [timeWindow]\n         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)\n         *\n         */\n        async fetchTrendingChannels(timeWindow, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchTrendingChannels(timeWindow, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchTrendingChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.\n         * @summary Member of\n         * @param {number} fid The FID of the user.\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)\n         *\n         */\n        async fetchUserChannelMemberships(fid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserChannelMemberships(fid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUserChannelMemberships']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of all channels with their details that a FID follows.\n         * @summary Following\n         * @param {number} fid The FID of the user.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)\n         *\n         */\n        async fetchUserChannels(fid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserChannels(fid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUserChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all channels that a user has casted in, in reverse chronological order.\n         * @summary Fetch channels that user is active in\n         * @param {number} fid The user\\&#39;s FID (identifier)\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)\n         *\n         */\n        async fetchUsersActiveChannels(fid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsersActiveChannels(fid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.fetchUsersActiveChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Follow a channel\n         * @summary Follow a channel\n         * @param {ChannelFollowReqBody} channelFollowReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)\n         *\n         */\n        async followChannel(channelFollowReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.followChannel(channelFollowReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.followChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Invite a user to a channel\n         * @summary Invite\n         * @param {InviteChannelMemberReqBody} inviteChannelMemberReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)\n         *\n         */\n        async inviteChannelMember(inviteChannelMemberReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteChannelMember(inviteChannelMemberReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.inviteChannelMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns details of a channel\n         * @summary By ID or parent_url\n         * @param {string} id Channel ID for the channel being queried\n         * @param {ChannelType} [type] Type of identifier being used to query the channel. Defaults to ID.\n         * @param {number} [viewerFid] FID of the user viewing the channel.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)\n         *\n         */\n        async lookupChannel(id, type, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupChannel(id, type, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.lookupChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Remove a user from a channel or a user\\'s invite to a channel role\n         * @summary Remove user\n         * @param {RemoveChannelMemberReqBody} removeChannelMemberReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)\n         *\n         */\n        async removeChannelMember(removeChannelMemberReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.removeChannelMember(removeChannelMemberReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.removeChannelMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Accept or reject a channel invite\n         * @summary Accept or reject an invite\n         * @param {RespondChannelInviteReqBody} respondChannelInviteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)\n         *\n         */\n        async respondChannelInvite(respondChannelInviteReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.respondChannelInvite(respondChannelInviteReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.respondChannelInvite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of channels based on ID or name\n         * @summary Search by ID or name\n         * @param {string} q Channel ID or name for the channel being queried\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 200)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)\n         *\n         */\n        async searchChannels(q, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChannels(q, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.searchChannels']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Unfollow a channel\n         * @summary Unfollow a channel\n         * @param {ChannelFollowReqBody} channelFollowReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)\n         *\n         */\n        async unfollowChannel(channelFollowReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowChannel(channelFollowReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ChannelApi.unfollowChannel']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ChannelApiFp = ChannelApiFp;\n/**\n * ChannelApi - factory interface\n * @export\n */\nconst ChannelApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ChannelApiFp)(configuration);\n    return {\n        /**\n         * Returns a list of all channels with their details\n         * @summary Fetch all channels with their details\n         * @param {ChannelApiFetchAllChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)\n         *\n         */\n        fetchAllChannels(requestParameters = {}, options) {\n            return localVarFp.fetchAllChannels(requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns details of multiple channels\n         * @summary Bulk fetch\n         * @param {ChannelApiFetchBulkChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)\n         *\n         */\n        fetchBulkChannels(requestParameters, options) {\n            return localVarFp.fetchBulkChannels(requestParameters.ids, requestParameters.type, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.\n         * @summary Open invites\n         * @param {ChannelApiFetchChannelInvitesRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)\n         *\n         */\n        fetchChannelInvites(requestParameters = {}, options) {\n            return localVarFp.fetchChannelInvites(requestParameters.channelId, requestParameters.invitedFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of members in a channel\n         * @summary Fetch members\n         * @param {ChannelApiFetchChannelMembersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)\n         *\n         */\n        fetchChannelMembers(requestParameters, options) {\n            return localVarFp.fetchChannelMembers(requestParameters.channelId, requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.\n         * @summary For channel\n         * @param {ChannelApiFetchFollowersForAChannelRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)\n         *\n         */\n        fetchFollowersForAChannel(requestParameters, options) {\n            return localVarFp.fetchFollowersForAChannel(requestParameters.id, requestParameters.viewerFid, requestParameters.cursor, requestParameters.limit, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \\\"X, Y, Z follow this channel\\\".\n         * @summary Relevant followers\n         * @param {ChannelApiFetchRelevantFollowersForAChannelRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)\n         *\n         */\n        fetchRelevantFollowersForAChannel(requestParameters, options) {\n            return localVarFp.fetchRelevantFollowersForAChannel(requestParameters.id, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of trending channels based on activity\n         * @summary Channels by activity\n         * @param {ChannelApiFetchTrendingChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)\n         *\n         */\n        fetchTrendingChannels(requestParameters = {}, options) {\n            return localVarFp.fetchTrendingChannels(requestParameters.timeWindow, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.\n         * @summary Member of\n         * @param {ChannelApiFetchUserChannelMembershipsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)\n         *\n         */\n        fetchUserChannelMemberships(requestParameters, options) {\n            return localVarFp.fetchUserChannelMemberships(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of all channels with their details that a FID follows.\n         * @summary Following\n         * @param {ChannelApiFetchUserChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)\n         *\n         */\n        fetchUserChannels(requestParameters, options) {\n            return localVarFp.fetchUserChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all channels that a user has casted in, in reverse chronological order.\n         * @summary Fetch channels that user is active in\n         * @param {ChannelApiFetchUsersActiveChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)\n         *\n         */\n        fetchUsersActiveChannels(requestParameters, options) {\n            return localVarFp.fetchUsersActiveChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Follow a channel\n         * @summary Follow a channel\n         * @param {ChannelApiFollowChannelRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)\n         *\n         */\n        followChannel(requestParameters, options) {\n            return localVarFp.followChannel(requestParameters.channelFollowReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Invite a user to a channel\n         * @summary Invite\n         * @param {ChannelApiInviteChannelMemberRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)\n         *\n         */\n        inviteChannelMember(requestParameters, options) {\n            return localVarFp.inviteChannelMember(requestParameters.inviteChannelMemberReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns details of a channel\n         * @summary By ID or parent_url\n         * @param {ChannelApiLookupChannelRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)\n         *\n         */\n        lookupChannel(requestParameters, options) {\n            return localVarFp.lookupChannel(requestParameters.id, requestParameters.type, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Remove a user from a channel or a user\\'s invite to a channel role\n         * @summary Remove user\n         * @param {ChannelApiRemoveChannelMemberRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)\n         *\n         */\n        removeChannelMember(requestParameters, options) {\n            return localVarFp.removeChannelMember(requestParameters.removeChannelMemberReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Accept or reject a channel invite\n         * @summary Accept or reject an invite\n         * @param {ChannelApiRespondChannelInviteRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)\n         *\n         */\n        respondChannelInvite(requestParameters, options) {\n            return localVarFp.respondChannelInvite(requestParameters.respondChannelInviteReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of channels based on ID or name\n         * @summary Search by ID or name\n         * @param {ChannelApiSearchChannelsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)\n         *\n         */\n        searchChannels(requestParameters, options) {\n            return localVarFp.searchChannels(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Unfollow a channel\n         * @summary Unfollow a channel\n         * @param {ChannelApiUnfollowChannelRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)\n         *\n         */\n        unfollowChannel(requestParameters, options) {\n            return localVarFp.unfollowChannel(requestParameters.channelFollowReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ChannelApiFactory = ChannelApiFactory;\n/**\n * ChannelApi - object-oriented interface\n * @export\n * @class ChannelApi\n * @extends {BaseAPI}\n */\nclass ChannelApi extends base_1.BaseAPI {\n    /**\n     * Returns a list of all channels with their details\n     * @summary Fetch all channels with their details\n     * @param {ChannelApiFetchAllChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)\n     *\n     */\n    fetchAllChannels(requestParameters = {}, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchAllChannels(requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns details of multiple channels\n     * @summary Bulk fetch\n     * @param {ChannelApiFetchBulkChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)\n     *\n     */\n    fetchBulkChannels(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchBulkChannels(requestParameters.ids, requestParameters.type, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.\n     * @summary Open invites\n     * @param {ChannelApiFetchChannelInvitesRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)\n     *\n     */\n    fetchChannelInvites(requestParameters = {}, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchChannelInvites(requestParameters.channelId, requestParameters.invitedFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of members in a channel\n     * @summary Fetch members\n     * @param {ChannelApiFetchChannelMembersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)\n     *\n     */\n    fetchChannelMembers(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchChannelMembers(requestParameters.channelId, requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.\n     * @summary For channel\n     * @param {ChannelApiFetchFollowersForAChannelRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)\n     *\n     */\n    fetchFollowersForAChannel(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchFollowersForAChannel(requestParameters.id, requestParameters.viewerFid, requestParameters.cursor, requestParameters.limit, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \\\"X, Y, Z follow this channel\\\".\n     * @summary Relevant followers\n     * @param {ChannelApiFetchRelevantFollowersForAChannelRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)\n     *\n     */\n    fetchRelevantFollowersForAChannel(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchRelevantFollowersForAChannel(requestParameters.id, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of trending channels based on activity\n     * @summary Channels by activity\n     * @param {ChannelApiFetchTrendingChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)\n     *\n     */\n    fetchTrendingChannels(requestParameters = {}, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchTrendingChannels(requestParameters.timeWindow, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.\n     * @summary Member of\n     * @param {ChannelApiFetchUserChannelMembershipsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)\n     *\n     */\n    fetchUserChannelMemberships(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchUserChannelMemberships(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of all channels with their details that a FID follows.\n     * @summary Following\n     * @param {ChannelApiFetchUserChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)\n     *\n     */\n    fetchUserChannels(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchUserChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all channels that a user has casted in, in reverse chronological order.\n     * @summary Fetch channels that user is active in\n     * @param {ChannelApiFetchUsersActiveChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)\n     *\n     */\n    fetchUsersActiveChannels(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).fetchUsersActiveChannels(requestParameters.fid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Follow a channel\n     * @summary Follow a channel\n     * @param {ChannelApiFollowChannelRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)\n     *\n     */\n    followChannel(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).followChannel(requestParameters.channelFollowReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Invite a user to a channel\n     * @summary Invite\n     * @param {ChannelApiInviteChannelMemberRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)\n     *\n     */\n    inviteChannelMember(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).inviteChannelMember(requestParameters.inviteChannelMemberReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns details of a channel\n     * @summary By ID or parent_url\n     * @param {ChannelApiLookupChannelRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)\n     *\n     */\n    lookupChannel(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).lookupChannel(requestParameters.id, requestParameters.type, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Remove a user from a channel or a user\\'s invite to a channel role\n     * @summary Remove user\n     * @param {ChannelApiRemoveChannelMemberRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)\n     *\n     */\n    removeChannelMember(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).removeChannelMember(requestParameters.removeChannelMemberReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Accept or reject a channel invite\n     * @summary Accept or reject an invite\n     * @param {ChannelApiRespondChannelInviteRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)\n     *\n     */\n    respondChannelInvite(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).respondChannelInvite(requestParameters.respondChannelInviteReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of channels based on ID or name\n     * @summary Search by ID or name\n     * @param {ChannelApiSearchChannelsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)\n     *\n     */\n    searchChannels(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).searchChannels(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Unfollow a channel\n     * @summary Unfollow a channel\n     * @param {ChannelApiUnfollowChannelRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ChannelApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)\n     *\n     */\n    unfollowChannel(requestParameters, options) {\n        return (0, exports.ChannelApiFp)(this.configuration).unfollowChannel(requestParameters.channelFollowReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ChannelApi = ChannelApi;\n/**\n * @export\n */\nexports.FetchTrendingChannelsTimeWindowEnum = {\n    _1d: '1d',\n    _7d: '7d',\n    _30d: '30d'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2NoYW5uZWwtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDekosZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixhQUFhO0FBQ2hDLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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L0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9jaGFubmVsLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2hUcmVuZGluZ0NoYW5uZWxzVGltZVdpbmRvd0VudW0gPSBleHBvcnRzLkNoYW5uZWxBcGkgPSBleHBvcnRzLkNoYW5uZWxBcGlGYWN0b3J5ID0gZXhwb3J0cy5DaGFubmVsQXBpRnAgPSBleHBvcnRzLkNoYW5uZWxBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIENoYW5uZWxBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMjAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hbGwtY2hhbm5lbHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEFsbENoYW5uZWxzOiBhc3luYyAobGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jaGFubmVsL2xpc3RgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBkZXRhaWxzIG9mIG11bHRpcGxlIGNoYW5uZWxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1bGsgZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkcyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjaGFubmVsIElEcyBvciBwYXJlbnRfdXJscywgdXAgdG8gMTAwIGF0IGEgdGltZVxuICAgICAgICAgKiBAcGFyYW0ge0NoYW5uZWxUeXBlfSBbdHlwZV0gVHlwZSBvZiBpZGVudGlmaWVyIGJlaW5nIHVzZWQgdG8gcXVlcnkgdGhlIGNoYW5uZWxzLiBEZWZhdWx0cyB0byBJRC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIEZJRCBvZiB0aGUgdXNlciB2aWV3aW5nIHRoZSBjaGFubmVscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFJlc3BvbnNlQnVsaz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxSZXNwb25zZUJ1bGtgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstY2hhbm5lbHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEJ1bGtDaGFubmVsczogYXN5bmMgKGlkcywgdHlwZSwgdmlld2VyRmlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2lkcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaEJ1bGtDaGFubmVscycsICdpZHMnLCBpZHMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC9idWxrYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnaWRzJ10gPSBpZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndHlwZSddID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBpbnZpdGVzLCBlaXRoZXIgaW4gYSBjaGFubmVsIG9yIGZvciBhIHVzZXIuIElmIGJvdGggYXJlIHByb3ZpZGVkLCBvcGVuIGNoYW5uZWwgaW52aXRlIGZvciB0aGF0IHVzZXIgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IE9wZW4gaW52aXRlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYW5uZWxJZF0gQ2hhbm5lbCBJRCBmb3IgdGhlIGNoYW5uZWwgYmVpbmcgcXVlcmllZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ludml0ZWRGaWRdIEZJRCBvZiB0aGUgdXNlciBiZWluZyBpbnZpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVySW52aXRlTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckludml0ZUxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2hhbm5lbC1pbnZpdGVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDaGFubmVsSW52aXRlczogYXN5bmMgKGNoYW5uZWxJZCwgaW52aXRlZEZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jaGFubmVsL21lbWJlci9pbnZpdGUvbGlzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2NoYW5uZWxfaWQnXSA9IGNoYW5uZWxJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZpdGVkRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydpbnZpdGVkX2ZpZCddID0gaW52aXRlZEZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgbWVtYmVycyBpbiBhIGNoYW5uZWxcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggbWVtYmVyc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbElkIENoYW5uZWwgSUQgZm9yIHRoZSBjaGFubmVsIGJlaW5nIHF1ZXJpZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtmaWRdIEZJRCBvZiB0aGUgdXNlciBiZWluZyBxdWVyaWVkLiBTcGVjaWZ5IHRoaXMgdG8gY2hlY2sgaWYgYSB1c2VyIGlzIGEgbWVtYmVyIG9mIHRoZSBjaGFubmVsIHdpdGhvdXQgcGFnaW5hdGluZyB0aHJvdWdoIGFsbCBtZW1iZXJzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtbWVtYmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2hhbm5lbE1lbWJlcnM6IGFzeW5jIChjaGFubmVsSWQsIGZpZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjaGFubmVsSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hDaGFubmVsTWVtYmVycycsICdjaGFubmVsSWQnLCBjaGFubmVsSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC9tZW1iZXIvbGlzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2NoYW5uZWxfaWQnXSA9IGNoYW5uZWxJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgY2hhbm5lbC4gTWF4IGxpbWl0IGlzIDEwMDAuIFVzZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciBjaGFubmVsXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDaGFubmVsIElEIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgZm9sbG93ZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIGZvbGxvd2VycyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDAwKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZm9sbG93ZXJzLWZvci1hLWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZvbGxvd2Vyc0ZvckFDaGFubmVsOiBhc3luYyAoaWQsIHZpZXdlckZpZCwgY3Vyc29yLCBsaW1pdCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaEZvbGxvd2Vyc0ZvckFDaGFubmVsJywgJ2lkJywgaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC9mb2xsb3dlcnNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2lkJ10gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcmVsZXZhbnQgY2hhbm5lbCBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELiBUaGlzIHVzdWFsbHkgc2hvd3Mgb24gYSBjaGFubmVsIGFzIFxcXCJYLCBZLCBaIGZvbGxvdyB0aGlzIGNoYW5uZWxcXFwiLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWxldmFudCBmb2xsb3dlcnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIENoYW5uZWwgSUQgYmVpbmcgcXVlcmllZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld2VyRmlkIFRoZSBGSUQgb2YgdGhlIHVzZXIgdG8gY3VzdG9taXplIHRoaXMgcmVzcG9uc2UgZm9yLiBQcm92aWRpbmcgdGhpcyB3aWxsIGFsc28gcmV0dXJuIGEgbGlzdCBvZiBmb2xsb3dlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2Vycy1mb3ItYS1jaGFubmVsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsOiBhc3luYyAoaWQsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwnLCAnaWQnLCBpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd2aWV3ZXJGaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsJywgJ3ZpZXdlckZpZCcsIHZpZXdlckZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jaGFubmVsL2ZvbGxvd2Vycy9yZWxldmFudGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnaWQnXSA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRyZW5kaW5nIGNoYW5uZWxzIGJhc2VkIG9uIGFjdGl2aXR5XG4gICAgICAgICAqIEBzdW1tYXJ5IENoYW5uZWxzIGJ5IGFjdGl2aXR5XG4gICAgICAgICAqIEBwYXJhbSB7RmV0Y2hUcmVuZGluZ0NoYW5uZWxzVGltZVdpbmRvd0VudW19IFt0aW1lV2luZG93XVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDEwLCBNYXhpbXVtOiAyNSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmVuZGluZ0NoYW5uZWxSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFRyZW5kaW5nQ2hhbm5lbFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC10cmVuZGluZy1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVHJlbmRpbmdDaGFubmVsczogYXN5bmMgKHRpbWVXaW5kb3csIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC90cmVuZGluZ2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aW1lV2luZG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0aW1lX3dpbmRvdyddID0gdGltZVdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzIHRoYXQgYW4gRklEIGlzIGEgbWVtYmVyIG9mLiBEYXRhIG1heSBoYXZlIGEgZGVsYXkgb2YgdXAgdG8gMSBob3VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBNZW1iZXIgb2ZcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItY2hhbm5lbC1tZW1iZXJzaGlwcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckNoYW5uZWxNZW1iZXJzaGlwczogYXN5bmMgKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL21lbWJlcnNoaXBzL2xpc3RgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzIHRoYXQgYSBGSUQgZm9sbG93cy5cbiAgICAgICAgICogQHN1bW1hcnkgRm9sbG93aW5nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgdXNlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWNoYW5uZWxzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyQ2hhbm5lbHM6IGFzeW5jIChmaWQsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlckNoYW5uZWxzJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2NoYW5uZWxzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgY2hhbm5lbHMgdGhhdCBhIHVzZXIgaGFzIGNhc3RlZCBpbiwgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBjaGFubmVscyB0aGF0IHVzZXIgaXMgYWN0aXZlIGluXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIHVzZXJcXCYjMzk7cyBGSUQgKGlkZW50aWZpZXIpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc0FjdGl2ZUNoYW5uZWxzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc0FjdGl2ZUNoYW5uZWxzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWFjdGl2ZS1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlcnNBY3RpdmVDaGFubmVsczogYXN5bmMgKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9jaGFubmVsL3VzZXJgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvdyBhIGNoYW5uZWxcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsRm9sbG93UmVxQm9keX0gY2hhbm5lbEZvbGxvd1JlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZm9sbG93LWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmb2xsb3dDaGFubmVsOiBhc3luYyAoY2hhbm5lbEZvbGxvd1JlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY2hhbm5lbEZvbGxvd1JlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZm9sbG93Q2hhbm5lbCcsICdjaGFubmVsRm9sbG93UmVxQm9keScsIGNoYW5uZWxGb2xsb3dSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2NoYW5uZWwvZm9sbG93YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY2hhbm5lbEZvbGxvd1JlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludml0ZSBhIHVzZXIgdG8gYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEludml0ZVxuICAgICAgICAgKiBAcGFyYW0ge0ludml0ZUNoYW5uZWxNZW1iZXJSZXFCb2R5fSBpbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9pbnZpdGUtY2hhbm5lbC1tZW1iZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpdGVDaGFubmVsTWVtYmVyOiBhc3luYyAoaW52aXRlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaW52aXRlQ2hhbm5lbE1lbWJlclJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnaW52aXRlQ2hhbm5lbE1lbWJlcicsICdpbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keScsIGludml0ZUNoYW5uZWxNZW1iZXJSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2NoYW5uZWwvbWVtYmVyL2ludml0ZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGludml0ZUNoYW5uZWxNZW1iZXJSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IElEIG9yIHBhcmVudF91cmxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIENoYW5uZWwgSUQgZm9yIHRoZSBjaGFubmVsIGJlaW5nIHF1ZXJpZWRcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsVHlwZX0gW3R5cGVdIFR5cGUgb2YgaWRlbnRpZmllciBiZWluZyB1c2VkIHRvIHF1ZXJ5IHRoZSBjaGFubmVsLiBEZWZhdWx0cyB0byBJRC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIEZJRCBvZiB0aGUgdXNlciB2aWV3aW5nIHRoZSBjaGFubmVsLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jaGFubmVsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2hhbm5lbDogYXN5bmMgKGlkLCB0eXBlLCB2aWV3ZXJGaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwQ2hhbm5lbCcsICdpZCcsIGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2NoYW5uZWxgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2lkJ10gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0eXBlJ10gPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGEgdXNlciBmcm9tIGEgY2hhbm5lbCBvciBhIHVzZXJcXCdzIGludml0ZSB0byBhIGNoYW5uZWwgcm9sZVxuICAgICAgICAgKiBAc3VtbWFyeSBSZW1vdmUgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge1JlbW92ZUNoYW5uZWxNZW1iZXJSZXFCb2R5fSByZW1vdmVDaGFubmVsTWVtYmVyUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZW1vdmUtY2hhbm5lbC1tZW1iZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDaGFubmVsTWVtYmVyOiBhc3luYyAocmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVtb3ZlQ2hhbm5lbE1lbWJlcicsICdyZW1vdmVDaGFubmVsTWVtYmVyUmVxQm9keScsIHJlbW92ZUNoYW5uZWxNZW1iZXJSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2NoYW5uZWwvbWVtYmVyYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZW1vdmVDaGFubmVsTWVtYmVyUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWNjZXB0IG9yIHJlamVjdCBhIGNoYW5uZWwgaW52aXRlXG4gICAgICAgICAqIEBzdW1tYXJ5IEFjY2VwdCBvciByZWplY3QgYW4gaW52aXRlXG4gICAgICAgICAqIEBwYXJhbSB7UmVzcG9uZENoYW5uZWxJbnZpdGVSZXFCb2R5fSByZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVzcG9uZC1jaGFubmVsLWludml0ZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbmRDaGFubmVsSW52aXRlOiBhc3luYyAocmVzcG9uZENoYW5uZWxJbnZpdGVSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3Jlc3BvbmRDaGFubmVsSW52aXRlUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXNwb25kQ2hhbm5lbEludml0ZScsICdyZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHknLCByZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC9tZW1iZXIvaW52aXRlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUFVUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5uZWxzIGJhc2VkIG9uIElEIG9yIG5hbWVcbiAgICAgICAgICogQHN1bW1hcnkgU2VhcmNoIGJ5IElEIG9yIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHEgQ2hhbm5lbCBJRCBvciBuYW1lIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDIwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlYXJjaC1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaENoYW5uZWxzOiBhc3luYyAocSwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdxJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3NlYXJjaENoYW5uZWxzJywgJ3EnLCBxKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2NoYW5uZWwvc2VhcmNoYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3EnXSA9IHE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVW5mb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IFVuZm9sbG93IGEgY2hhbm5lbFxuICAgICAgICAgKiBAcGFyYW0ge0NoYW5uZWxGb2xsb3dSZXFCb2R5fSBjaGFubmVsRm9sbG93UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91bmZvbGxvdy1jaGFubmVsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdW5mb2xsb3dDaGFubmVsOiBhc3luYyAoY2hhbm5lbEZvbGxvd1JlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY2hhbm5lbEZvbGxvd1JlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndW5mb2xsb3dDaGFubmVsJywgJ2NoYW5uZWxGb2xsb3dSZXFCb2R5JywgY2hhbm5lbEZvbGxvd1JlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvY2hhbm5lbC9mb2xsb3dgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdERUxFVEUnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNoYW5uZWxGb2xsb3dSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNoYW5uZWxBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENoYW5uZWxBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQ2hhbm5lbEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNoYW5uZWxBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHNcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYWxsIGNoYW5uZWxzIHdpdGggdGhlaXIgZGV0YWlsc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAyMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbExpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWFsbC1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQWxsQ2hhbm5lbHMobGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hBbGxDaGFubmVscyhsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5mZXRjaEFsbENoYW5uZWxzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgbXVsdGlwbGUgY2hhbm5lbHNcbiAgICAgICAgICogQHN1bW1hcnkgQnVsayBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRzIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGNoYW5uZWwgSURzIG9yIHBhcmVudF91cmxzLCB1cCB0byAxMDAgYXQgYSB0aW1lXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbFR5cGV9IFt0eXBlXSBUeXBlIG9mIGlkZW50aWZpZXIgYmVpbmcgdXNlZCB0byBxdWVyeSB0aGUgY2hhbm5lbHMuIERlZmF1bHRzIHRvIElELlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gRklEIG9mIHRoZSB1c2VyIHZpZXdpbmcgdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsUmVzcG9uc2VCdWxrPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbFJlc3BvbnNlQnVsa2Agb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQnVsa0NoYW5uZWxzKGlkcywgdHlwZSwgdmlld2VyRmlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEJ1bGtDaGFubmVscyhpZHMsIHR5cGUsIHZpZXdlckZpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkuZmV0Y2hCdWxrQ2hhbm5lbHMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBpbnZpdGVzLCBlaXRoZXIgaW4gYSBjaGFubmVsIG9yIGZvciBhIHVzZXIuIElmIGJvdGggYXJlIHByb3ZpZGVkLCBvcGVuIGNoYW5uZWwgaW52aXRlIGZvciB0aGF0IHVzZXIgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IE9wZW4gaW52aXRlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYW5uZWxJZF0gQ2hhbm5lbCBJRCBmb3IgdGhlIGNoYW5uZWwgYmVpbmcgcXVlcmllZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ludml0ZWRGaWRdIEZJRCBvZiB0aGUgdXNlciBiZWluZyBpbnZpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVySW52aXRlTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckludml0ZUxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2hhbm5lbC1pbnZpdGVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hDaGFubmVsSW52aXRlcyhjaGFubmVsSWQsIGludml0ZWRGaWQsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2hhbm5lbEludml0ZXMoY2hhbm5lbElkLCBpbnZpdGVkRmlkLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5mZXRjaENoYW5uZWxJbnZpdGVzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgbWVtYmVycyBpbiBhIGNoYW5uZWxcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggbWVtYmVyc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbElkIENoYW5uZWwgSUQgZm9yIHRoZSBjaGFubmVsIGJlaW5nIHF1ZXJpZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtmaWRdIEZJRCBvZiB0aGUgdXNlciBiZWluZyBxdWVyaWVkLiBTcGVjaWZ5IHRoaXMgdG8gY2hlY2sgaWYgYSB1c2VyIGlzIGEgbWVtYmVyIG9mIHRoZSBjaGFubmVsIHdpdGhvdXQgcGFnaW5hdGluZyB0aHJvdWdoIGFsbCBtZW1iZXJzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtbWVtYmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQ2hhbm5lbE1lbWJlcnMoY2hhbm5lbElkLCBmaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2hhbm5lbE1lbWJlcnMoY2hhbm5lbElkLCBmaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDaGFubmVsQXBpLmZldGNoQ2hhbm5lbE1lbWJlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBjaGFubmVsLiBNYXggbGltaXQgaXMgMTAwMC4gVXNlIGN1cnNvciBmb3IgcGFnaW5hdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgRm9yIGNoYW5uZWxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIENoYW5uZWwgSUQgZm9yIHRoZSBjaGFubmVsIGJlaW5nIHF1ZXJpZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBmb2xsb3dlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgZm9sbG93ZXJzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMDApXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3dlcnMtZm9yLWEtY2hhbm5lbClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWwoaWQsIHZpZXdlckZpZCwgY3Vyc29yLCBsaW1pdCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGb2xsb3dlcnNGb3JBQ2hhbm5lbChpZCwgdmlld2VyRmlkLCBjdXJzb3IsIGxpbWl0LCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5mZXRjaEZvbGxvd2Vyc0ZvckFDaGFubmVsJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiByZWxldmFudCBjaGFubmVsIGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGNoYW5uZWwgYXMgXFxcIlgsIFksIFogZm9sbG93IHRoaXMgY2hhbm5lbFxcXCIuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlbGV2YW50IGZvbGxvd2Vyc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQ2hhbm5lbCBJRCBiZWluZyBxdWVyaWVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3ZXJGaWQgVGhlIEZJRCBvZiB0aGUgdXNlciB0byBjdXN0b21pemUgdGhpcyByZXNwb25zZSBmb3IuIFByb3ZpZGluZyB0aGlzIHdpbGwgYWxzbyByZXR1cm4gYSBsaXN0IG9mIGZvbGxvd2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWxldmFudEZvbGxvd2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZm9sbG93ZXJzLWZvci1hLWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwoaWQsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsKGlkLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDaGFubmVsQXBpLmZldGNoUmVsZXZhbnRGb2xsb3dlcnNGb3JBQ2hhbm5lbCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgdHJlbmRpbmcgY2hhbm5lbHMgYmFzZWQgb24gYWN0aXZpdHlcbiAgICAgICAgICogQHN1bW1hcnkgQ2hhbm5lbHMgYnkgYWN0aXZpdHlcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFRyZW5kaW5nQ2hhbm5lbHNUaW1lV2luZG93RW51bX0gW3RpbWVXaW5kb3ddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMTAsIE1heGltdW06IDI1KVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyZW5kaW5nQ2hhbm5lbFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJlbmRpbmdDaGFubmVsUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWNoYW5uZWxzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hUcmVuZGluZ0NoYW5uZWxzKHRpbWVXaW5kb3csIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVHJlbmRpbmdDaGFubmVscyh0aW1lV2luZG93LCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5mZXRjaFRyZW5kaW5nQ2hhbm5lbHMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHMgdGhhdCBhbiBGSUQgaXMgYSBtZW1iZXIgb2YuIERhdGEgbWF5IGhhdmUgYSBkZWxheSBvZiB1cCB0byAxIGhvdXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IE1lbWJlciBvZlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgb2YgdGhlIHVzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVyTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1jaGFubmVsLW1lbWJlcnNoaXBzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkuZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzIHRoYXQgYSBGSUQgZm9sbG93cy5cbiAgICAgICAgICogQHN1bW1hcnkgRm9sbG93aW5nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgdXNlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWNoYW5uZWxzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyQ2hhbm5lbHMoZmlkLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJDaGFubmVscyhmaWQsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDaGFubmVsQXBpLmZldGNoVXNlckNoYW5uZWxzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGFsbCBjaGFubmVscyB0aGF0IGEgdXNlciBoYXMgY2FzdGVkIGluLCBpbiByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGNoYW5uZWxzIHRoYXQgdXNlciBpcyBhY3RpdmUgaW5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgdXNlclxcJiMzOTtzIEZJRCAoaWRlbnRpZmllcilcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzQWN0aXZlQ2hhbm5lbHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJzQWN0aXZlQ2hhbm5lbHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcnMtYWN0aXZlLWNoYW5uZWxzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzKGZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkuZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvdyBhIGNoYW5uZWxcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsRm9sbG93UmVxQm9keX0gY2hhbm5lbEZvbGxvd1JlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZm9sbG93LWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmb2xsb3dDaGFubmVsKGNoYW5uZWxGb2xsb3dSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mb2xsb3dDaGFubmVsKGNoYW5uZWxGb2xsb3dSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5mb2xsb3dDaGFubmVsJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZpdGUgYSB1c2VyIHRvIGEgY2hhbm5lbFxuICAgICAgICAgKiBAc3VtbWFyeSBJbnZpdGVcbiAgICAgICAgICogQHBhcmFtIHtJbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keX0gaW52aXRlQ2hhbm5lbE1lbWJlclJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvaW52aXRlLWNoYW5uZWwtbWVtYmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgaW52aXRlQ2hhbm5lbE1lbWJlcihpbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuaW52aXRlQ2hhbm5lbE1lbWJlcihpbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkuaW52aXRlQ2hhbm5lbE1lbWJlciddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBkZXRhaWxzIG9mIGEgY2hhbm5lbFxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBJRCBvciBwYXJlbnRfdXJsXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDaGFubmVsIElEIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbFR5cGV9IFt0eXBlXSBUeXBlIG9mIGlkZW50aWZpZXIgYmVpbmcgdXNlZCB0byBxdWVyeSB0aGUgY2hhbm5lbC4gRGVmYXVsdHMgdG8gSUQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBGSUQgb2YgdGhlIHVzZXIgdmlld2luZyB0aGUgY2hhbm5lbC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2hhbm5lbClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cENoYW5uZWwoaWQsIHR5cGUsIHZpZXdlckZpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwQ2hhbm5lbChpZCwgdHlwZSwgdmlld2VyRmlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2hhbm5lbEFwaS5sb29rdXBDaGFubmVsJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSB1c2VyIGZyb20gYSBjaGFubmVsIG9yIGEgdXNlclxcJ3MgaW52aXRlIHRvIGEgY2hhbm5lbCByb2xlXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlbW92ZSB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7UmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHl9IHJlbW92ZUNoYW5uZWxNZW1iZXJSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlbW92ZS1jaGFubmVsLW1lbWJlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlbW92ZUNoYW5uZWxNZW1iZXIocmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlbW92ZUNoYW5uZWxNZW1iZXIocmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDaGFubmVsQXBpLnJlbW92ZUNoYW5uZWxNZW1iZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2VwdCBvciByZWplY3QgYSBjaGFubmVsIGludml0ZVxuICAgICAgICAgKiBAc3VtbWFyeSBBY2NlcHQgb3IgcmVqZWN0IGFuIGludml0ZVxuICAgICAgICAgKiBAcGFyYW0ge1Jlc3BvbmRDaGFubmVsSW52aXRlUmVxQm9keX0gcmVzcG9uZENoYW5uZWxJbnZpdGVSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3Jlc3BvbmQtY2hhbm5lbC1pbnZpdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZXNwb25kQ2hhbm5lbEludml0ZShyZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlc3BvbmRDaGFubmVsSW52aXRlKHJlc3BvbmRDaGFubmVsSW52aXRlUmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkucmVzcG9uZENoYW5uZWxJbnZpdGUnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5uZWxzIGJhc2VkIG9uIElEIG9yIG5hbWVcbiAgICAgICAgICogQHN1bW1hcnkgU2VhcmNoIGJ5IElEIG9yIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHEgQ2hhbm5lbCBJRCBvciBuYW1lIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjAsIE1heGltdW06IDIwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlYXJjaC1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHNlYXJjaENoYW5uZWxzKHEsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnNlYXJjaENoYW5uZWxzKHEsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDaGFubmVsQXBpLnNlYXJjaENoYW5uZWxzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmZvbGxvdyBhIGNoYW5uZWxcbiAgICAgICAgICogQHN1bW1hcnkgVW5mb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEZvbGxvd1JlcUJvZHl9IGNoYW5uZWxGb2xsb3dSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1bmZvbGxvd0NoYW5uZWwoY2hhbm5lbEZvbGxvd1JlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnVuZm9sbG93Q2hhbm5lbChjaGFubmVsRm9sbG93UmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NoYW5uZWxBcGkudW5mb2xsb3dDaGFubmVsJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNoYW5uZWxBcGlGcCA9IENoYW5uZWxBcGlGcDtcbi8qKlxuICogQ2hhbm5lbEFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHNcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hBbGxDaGFubmVsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbExpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWFsbC1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQWxsQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hBbGxDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBkZXRhaWxzIG9mIG11bHRpcGxlIGNoYW5uZWxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1bGsgZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hCdWxrQ2hhbm5lbHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxSZXNwb25zZUJ1bGs+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsUmVzcG9uc2VCdWxrYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1idWxrLWNoYW5uZWxzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCdWxrQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQnVsa0NoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLmlkcywgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIGludml0ZXMsIGVpdGhlciBpbiBhIGNoYW5uZWwgb3IgZm9yIGEgdXNlci4gSWYgYm90aCBhcmUgcHJvdmlkZWQsIG9wZW4gY2hhbm5lbCBpbnZpdGUgZm9yIHRoYXQgdXNlciBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQHN1bW1hcnkgT3BlbiBpbnZpdGVzXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoQ2hhbm5lbEludml0ZXNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxNZW1iZXJJbnZpdGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTWVtYmVySW52aXRlTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jaGFubmVsLWludml0ZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENoYW5uZWxJbnZpdGVzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ2hhbm5lbEludml0ZXMocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkLCByZXF1ZXN0UGFyYW1ldGVycy5pbnZpdGVkRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIG1lbWJlcnMgaW4gYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIG1lbWJlcnNcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hDaGFubmVsTWVtYmVyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtbWVtYmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2hhbm5lbE1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ2hhbm5lbE1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkLCByZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgY2hhbm5lbC4gTWF4IGxpbWl0IGlzIDEwMDAuIFVzZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciBjaGFubmVsXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3dlcnMtZm9yLWEtY2hhbm5lbClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMuaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJlbGV2YW50IGNoYW5uZWwgZm9sbG93ZXJzIGZvciBhIHNwZWNpZmljIEZJRC4gVGhpcyB1c3VhbGx5IHNob3dzIG9uIGEgY2hhbm5lbCBhcyBcXFwiWCwgWSwgWiBmb2xsb3cgdGhpcyBjaGFubmVsXFxcIi5cbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgZm9sbG93ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoUmVsZXZhbnRGb2xsb3dlcnNGb3JBQ2hhbm5lbFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2Vycy1mb3ItYS1jaGFubmVsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMuaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRyZW5kaW5nIGNoYW5uZWxzIGJhc2VkIG9uIGFjdGl2aXR5XG4gICAgICAgICAqIEBzdW1tYXJ5IENoYW5uZWxzIGJ5IGFjdGl2aXR5XG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoVHJlbmRpbmdDaGFubmVsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJlbmRpbmdDaGFubmVsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmVuZGluZ0NoYW5uZWxSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdHJlbmRpbmctY2hhbm5lbHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFRyZW5kaW5nQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hUcmVuZGluZ0NoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLnRpbWVXaW5kb3csIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzIHRoYXQgYW4gRklEIGlzIGEgbWVtYmVyIG9mLiBEYXRhIG1heSBoYXZlIGEgZGVsYXkgb2YgdXAgdG8gMSBob3VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBNZW1iZXIgb2ZcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVyTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1jaGFubmVsLW1lbWJlcnNoaXBzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJDaGFubmVsTWVtYmVyc2hpcHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGNoYW5uZWxzIHdpdGggdGhlaXIgZGV0YWlscyB0aGF0IGEgRklEIGZvbGxvd3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvd2luZ1xuICAgICAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlGZXRjaFVzZXJDaGFubmVsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbExpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItY2hhbm5lbHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgY2hhbm5lbHMgdGhhdCBhIHVzZXIgaGFzIGNhc3RlZCBpbiwgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBjaGFubmVscyB0aGF0IHVzZXIgaXMgYWN0aXZlIGluXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoVXNlcnNBY3RpdmVDaGFubmVsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2Vycy1hY3RpdmUtY2hhbm5lbHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJzQWN0aXZlQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVXNlcnNBY3RpdmVDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvdyBhIGNoYW5uZWxcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpRm9sbG93Q2hhbm5lbFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZm9sbG93LWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmb2xsb3dDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mb2xsb3dDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxGb2xsb3dSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW52aXRlIGEgdXNlciB0byBhIGNoYW5uZWxcbiAgICAgICAgICogQHN1bW1hcnkgSW52aXRlXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUludml0ZUNoYW5uZWxNZW1iZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ludml0ZS1jaGFubmVsLW1lbWJlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGludml0ZUNoYW5uZWxNZW1iZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmludml0ZUNoYW5uZWxNZW1iZXIocmVxdWVzdFBhcmFtZXRlcnMuaW52aXRlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IElEIG9yIHBhcmVudF91cmxcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpTG9va3VwQ2hhbm5lbFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2hhbm5lbClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cENoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cENoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMuaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHVzZXIgZnJvbSBhIGNoYW5uZWwgb3IgYSB1c2VyXFwncyBpbnZpdGUgdG8gYSBjaGFubmVsIHJvbGVcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtDaGFubmVsQXBpUmVtb3ZlQ2hhbm5lbE1lbWJlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVtb3ZlLWNoYW5uZWwtbWVtYmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2hhbm5lbE1lbWJlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVtb3ZlQ2hhbm5lbE1lbWJlcihyZXF1ZXN0UGFyYW1ldGVycy5yZW1vdmVDaGFubmVsTWVtYmVyUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2VwdCBvciByZWplY3QgYSBjaGFubmVsIGludml0ZVxuICAgICAgICAgKiBAc3VtbWFyeSBBY2NlcHQgb3IgcmVqZWN0IGFuIGludml0ZVxuICAgICAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlSZXNwb25kQ2hhbm5lbEludml0ZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVzcG9uZC1jaGFubmVsLWludml0ZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbmRDaGFubmVsSW52aXRlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5yZXNwb25kQ2hhbm5lbEludml0ZShyZXF1ZXN0UGFyYW1ldGVycy5yZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFubmVscyBiYXNlZCBvbiBJRCBvciBuYW1lXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBieSBJRCBvciBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaVNlYXJjaENoYW5uZWxzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlYXJjaC1jaGFubmVscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaENoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5zZWFyY2hDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycy5xLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVW5mb2xsb3cgYSBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IFVuZm9sbG93IGEgY2hhbm5lbFxuICAgICAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlVbmZvbGxvd0NoYW5uZWxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LWNoYW5uZWwpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB1bmZvbGxvd0NoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnVuZm9sbG93Q2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsRm9sbG93UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ2hhbm5lbEFwaUZhY3RvcnkgPSBDaGFubmVsQXBpRmFjdG9yeTtcbi8qKlxuICogQ2hhbm5lbEFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBDaGFubmVsQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQ2hhbm5lbEFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYWxsIGNoYW5uZWxzIHdpdGggdGhlaXIgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoQWxsQ2hhbm5lbHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbExpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hbGwtY2hhbm5lbHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEFsbENoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEFsbENoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgbXVsdGlwbGUgY2hhbm5lbHNcbiAgICAgKiBAc3VtbWFyeSBCdWxrIGZldGNoXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hCdWxrQ2hhbm5lbHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFJlc3BvbnNlQnVsaz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxSZXNwb25zZUJ1bGtgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1idWxrLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hCdWxrQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEJ1bGtDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycy5pZHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBpbnZpdGVzLCBlaXRoZXIgaW4gYSBjaGFubmVsIG9yIGZvciBhIHVzZXIuIElmIGJvdGggYXJlIHByb3ZpZGVkLCBvcGVuIGNoYW5uZWwgaW52aXRlIGZvciB0aGF0IHVzZXIgaXMgcmV0dXJuZWQuXG4gICAgICogQHN1bW1hcnkgT3BlbiBpbnZpdGVzXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hDaGFubmVsSW52aXRlc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENoYW5uZWxBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVySW52aXRlTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckludml0ZUxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtaW52aXRlcylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoQ2hhbm5lbEludml0ZXMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2hhbm5lbEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoQ2hhbm5lbEludml0ZXMocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkLCByZXF1ZXN0UGFyYW1ldGVycy5pbnZpdGVkRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIG1lbWJlcnMgaW4gYSBjaGFubmVsXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggbWVtYmVyc1xuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoQ2hhbm5lbE1lbWJlcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jaGFubmVsLW1lbWJlcnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaENoYW5uZWxNZW1iZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hDaGFubmVsTWVtYmVycyhyZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBjaGFubmVsLiBNYXggbGltaXQgaXMgMTAwMC4gVXNlIGN1cnNvciBmb3IgcGFnaW5hdGlvbi5cbiAgICAgKiBAc3VtbWFyeSBGb3IgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3dlcnMtZm9yLWEtY2hhbm5lbClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEZvbGxvd2Vyc0ZvckFDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLmlkLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiByZWxldmFudCBjaGFubmVsIGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGNoYW5uZWwgYXMgXFxcIlgsIFksIFogZm9sbG93IHRoaXMgY2hhbm5lbFxcXCIuXG4gICAgICogQHN1bW1hcnkgUmVsZXZhbnQgZm9sbG93ZXJzXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2hhbm5lbEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWxldmFudEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZm9sbG93ZXJzLWZvci1hLWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMuaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRyZW5kaW5nIGNoYW5uZWxzIGJhc2VkIG9uIGFjdGl2aXR5XG4gICAgICogQHN1bW1hcnkgQ2hhbm5lbHMgYnkgYWN0aXZpdHlcbiAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlGZXRjaFRyZW5kaW5nQ2hhbm5lbHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJlbmRpbmdDaGFubmVsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmVuZGluZ0NoYW5uZWxSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hUcmVuZGluZ0NoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFRyZW5kaW5nQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMudGltZVdpbmRvdywgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHMgdGhhdCBhbiBGSUQgaXMgYSBtZW1iZXIgb2YuIERhdGEgbWF5IGhhdmUgYSBkZWxheSBvZiB1cCB0byAxIGhvdXIuXG4gICAgICogQHN1bW1hcnkgTWVtYmVyIG9mXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpRmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2hhbm5lbEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTWVtYmVyTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1jaGFubmVsLW1lbWJlcnNoaXBzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjaGFubmVscyB3aXRoIHRoZWlyIGRldGFpbHMgdGhhdCBhIEZJRCBmb2xsb3dzLlxuICAgICAqIEBzdW1tYXJ5IEZvbGxvd2luZ1xuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUZldGNoVXNlckNoYW5uZWxzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2hhbm5lbEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1jaGFubmVscylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlckNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgY2hhbm5lbHMgdGhhdCBhIHVzZXIgaGFzIGNhc3RlZCBpbiwgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGNoYW5uZWxzIHRoYXQgdXNlciBpcyBhY3RpdmUgaW5cbiAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlGZXRjaFVzZXJzQWN0aXZlQ2hhbm5lbHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcnMtYWN0aXZlLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvbGxvdyBhIGNoYW5uZWxcbiAgICAgKiBAc3VtbWFyeSBGb2xsb3cgYSBjaGFubmVsXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpRm9sbG93Q2hhbm5lbFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENoYW5uZWxBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZm9sbG93LWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICBmb2xsb3dDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZm9sbG93Q2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsRm9sbG93UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludml0ZSBhIHVzZXIgdG8gYSBjaGFubmVsXG4gICAgICogQHN1bW1hcnkgSW52aXRlXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpSW52aXRlQ2hhbm5lbE1lbWJlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENoYW5uZWxBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvaW52aXRlLWNoYW5uZWwtbWVtYmVyKVxuICAgICAqXG4gICAgICovXG4gICAgaW52aXRlQ2hhbm5lbE1lbWJlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2hhbm5lbEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmludml0ZUNoYW5uZWxNZW1iZXIocmVxdWVzdFBhcmFtZXRlcnMuaW52aXRlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgYSBjaGFubmVsXG4gICAgICogQHN1bW1hcnkgQnkgSUQgb3IgcGFyZW50X3VybFxuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaUxvb2t1cENoYW5uZWxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5DaGFubmVsQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycy5pZCwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdXNlciBmcm9tIGEgY2hhbm5lbCBvciBhIHVzZXJcXCdzIGludml0ZSB0byBhIGNoYW5uZWwgcm9sZVxuICAgICAqIEBzdW1tYXJ5IFJlbW92ZSB1c2VyXG4gICAgICogQHBhcmFtIHtDaGFubmVsQXBpUmVtb3ZlQ2hhbm5lbE1lbWJlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENoYW5uZWxBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVtb3ZlLWNoYW5uZWwtbWVtYmVyKVxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbm5lbE1lbWJlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2hhbm5lbEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlbW92ZUNoYW5uZWxNZW1iZXIocmVxdWVzdFBhcmFtZXRlcnMucmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHQgb3IgcmVqZWN0IGEgY2hhbm5lbCBpbnZpdGVcbiAgICAgKiBAc3VtbWFyeSBBY2NlcHQgb3IgcmVqZWN0IGFuIGludml0ZVxuICAgICAqIEBwYXJhbSB7Q2hhbm5lbEFwaVJlc3BvbmRDaGFubmVsSW52aXRlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2hhbm5lbEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZXNwb25kLWNoYW5uZWwtaW52aXRlKVxuICAgICAqXG4gICAgICovXG4gICAgcmVzcG9uZENoYW5uZWxJbnZpdGUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5yZXNwb25kQ2hhbm5lbEludml0ZShyZXF1ZXN0UGFyYW1ldGVycy5yZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFubmVscyBiYXNlZCBvbiBJRCBvciBuYW1lXG4gICAgICogQHN1bW1hcnkgU2VhcmNoIGJ5IElEIG9yIG5hbWVcbiAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlTZWFyY2hDaGFubmVsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENoYW5uZWxBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsU2VhcmNoUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsU2VhcmNoUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2hhbm5lbHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2hhbm5lbEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnNlYXJjaENoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZvbGxvdyBhIGNoYW5uZWxcbiAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyBhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge0NoYW5uZWxBcGlVbmZvbGxvd0NoYW5uZWxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDaGFubmVsQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICB1bmZvbGxvd0NoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNoYW5uZWxBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS51bmZvbGxvd0NoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEZvbGxvd1JlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEFwaSA9IENoYW5uZWxBcGk7XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5GZXRjaFRyZW5kaW5nQ2hhbm5lbHNUaW1lV2luZG93RW51bSA9IHtcbiAgICBfMWQ6ICcxZCcsXG4gICAgXzdkOiAnN2QnLFxuICAgIF8zMGQ6ICczMGQnXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/channel-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/feed-api.js":
/*!********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/feed-api.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchTrendingFeedTimeWindowEnum = exports.FetchRepliesAndRecastsForUserFilterEnum = exports.FeedApi = exports.FeedApiFactory = exports.FeedApiFp = exports.FeedApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * FeedApi - axios parameter creator\n * @export\n */\nconst FeedApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel\n         * @summary Chronologically\n         * @param {number} fid FID of user whose recent casts you want to fetch\n         * @param {number} [appFid] Optionally filter to casts created via a specific app FID, e.g. 9152 for Warpcast\n         * @param {number} [viewerFid] FID of the user viewing the feed\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 150)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [includeReplies] Include reply casts by the author in the response, true by default\n         * @param {string} [parentUrl] Parent URL to filter the feed; mutually exclusive with channel_id\n         * @param {string} [channelId] Channel ID to filter the feed; mutually exclusive with parent_url\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)\n         *\n         */\n        fetchCastsForUser: async (fid, appFid, viewerFid, limit, cursor, includeReplies, parentUrl, channelId, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastsForUser', 'fid', fid);\n            const localVarPath = `/farcaster/feed/user/casts`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (appFid !== undefined) {\n                localVarQueryParameter['app_fid'] = appFid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (includeReplies !== undefined) {\n                localVarQueryParameter['include_replies'] = includeReplies;\n            }\n            if (parentUrl !== undefined) {\n                localVarQueryParameter['parent_url'] = parentUrl;\n            }\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.\n         * @summary By filters\n         * @param {FeedType} feedType Defaults to following (requires FID or address). If set to filter (requires filter_type)\n         * @param {FilterType} [filterType] Used when feed_type&#x3D;filter. Can be set to FIDs (requires FIDs) or parent_url (requires parent_url) or channel_id (requires channel_id)\n         * @param {number} [fid] (Optional) FID of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type\n         * @param {string} [fids] Used when filter_type&#x3D;FIDs . Create a feed based on a list of FIDs. Max array size is 100. Requires feed_type and filter_type.\n         * @param {string} [parentUrl] Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type.\n         * @param {string} [channelId] Used when filter_type&#x3D;channel_id can be used to fetch casts under a channel. Requires feed_type and filter_type.\n         * @param {boolean} [membersOnly] Used when filter_type&#x3D;channel_id. Only include casts from members of the channel. True by default.\n         * @param {string} [embedUrl] Used when filter_type&#x3D;embed_url. Casts with embedded URLs prefixed by this embed_url param will be returned. We normalize your given URL prefix and prepend \\&#39;https://\\&#39; if no protocol is included. Requires feed_type and filter_type.\n         * @param {Array<EmbedType>} [embedTypes] Used when filter_type&#x3D;embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type.\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)\n         *\n         */\n        fetchFeed: async (feedType, filterType, fid, fids, parentUrl, channelId, membersOnly, embedUrl, embedTypes, withRecasts, limit, cursor, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'feedType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFeed', 'feedType', feedType);\n            const localVarPath = `/farcaster/feed`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (feedType !== undefined) {\n                localVarQueryParameter['feed_type'] = feedType;\n            }\n            if (filterType !== undefined) {\n                localVarQueryParameter['filter_type'] = filterType;\n            }\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (fids !== undefined) {\n                localVarQueryParameter['fids'] = fids;\n            }\n            if (parentUrl !== undefined) {\n                localVarQueryParameter['parent_url'] = parentUrl;\n            }\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (membersOnly !== undefined) {\n                localVarQueryParameter['members_only'] = membersOnly;\n            }\n            if (embedUrl !== undefined) {\n                localVarQueryParameter['embed_url'] = embedUrl;\n            }\n            if (embedTypes) {\n                localVarQueryParameter['embed_types'] = embedTypes.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (withRecasts !== undefined) {\n                localVarQueryParameter['with_recasts'] = withRecasts;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch feed based on channel IDs\n         * @summary By channel IDs\n         * @param {string} channelIds Comma separated list of up to 10 channel IDs e.g. neynar,farcaster\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withReplies] Include replies in the response, false by default\n         * @param {boolean} [membersOnly] Only include casts from members of the channel. True by default.\n         * @param {string} [fids] Comma separated list of FIDs to filter the feed by, up to 10 at a time\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [shouldModerate] If true, only casts that have been liked by the moderator (if one exists) will be returned.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)\n         *\n         */\n        fetchFeedByChannelIds: async (channelIds, withRecasts, viewerFid, withReplies, membersOnly, fids, limit, cursor, shouldModerate, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'channelIds' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFeedByChannelIds', 'channelIds', channelIds);\n            const localVarPath = `/farcaster/feed/channels`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (channelIds !== undefined) {\n                localVarQueryParameter['channel_ids'] = channelIds;\n            }\n            if (withRecasts !== undefined) {\n                localVarQueryParameter['with_recasts'] = withRecasts;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (withReplies !== undefined) {\n                localVarQueryParameter['with_replies'] = withReplies;\n            }\n            if (membersOnly !== undefined) {\n                localVarQueryParameter['members_only'] = membersOnly;\n            }\n            if (fids !== undefined) {\n                localVarQueryParameter['fids'] = fids;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (shouldModerate !== undefined) {\n                localVarQueryParameter['should_moderate'] = shouldModerate;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch feed based on parent URLs\n         * @summary By parent URLs\n         * @param {string} parentUrls Comma separated list of parent_urls\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withReplies] Include replies in the response, false by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)\n         *\n         */\n        fetchFeedByParentUrls: async (parentUrls, withRecasts, viewerFid, withReplies, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'parentUrls' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFeedByParentUrls', 'parentUrls', parentUrls);\n            const localVarPath = `/farcaster/feed/parent_urls`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (parentUrls !== undefined) {\n                localVarQueryParameter['parent_urls'] = parentUrls;\n            }\n            if (withRecasts !== undefined) {\n                localVarQueryParameter['with_recasts'] = withRecasts;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (withReplies !== undefined) {\n                localVarQueryParameter['with_replies'] = withReplies;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a personalized For You feed for a user\n         * @summary For you\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {ForYouProvider} [provider]\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {string} [providerMetadata] provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)\n         *\n         */\n        fetchFeedForYou: async (fid, viewerFid, provider, limit, cursor, providerMetadata, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFeedForYou', 'fid', fid);\n            const localVarPath = `/farcaster/feed/for_you`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (providerMetadata !== undefined) {\n                localVarQueryParameter['provider_metadata'] = providerMetadata;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch feed of casts with mini apps, reverse chronological order\n         * @summary Casts with mini apps\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)\n         *\n         */\n        fetchFramesOnlyFeed: async (limit, viewerFid, cursor, xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/feed/frames`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first\n         * @summary 10 most popular casts\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)\n         *\n         */\n        fetchPopularCastsByUser: async (fid, viewerFid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchPopularCastsByUser', 'fid', fid);\n            const localVarPath = `/farcaster/feed/user/popular`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch recent replies and recasts for a given user FID; sorted by most recent first\n         * @summary Replies and recasts\n         * @param {number} fid FID of user whose replies and recasts you want to fetch\n         * @param {FetchRepliesAndRecastsForUserFilterEnum} [filter] filter to fetch only replies or recasts\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)\n         *\n         */\n        fetchRepliesAndRecastsForUser: async (fid, filter, limit, cursor, viewerFid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRepliesAndRecastsForUser', 'fid', fid);\n            const localVarPath = `/farcaster/feed/user/replies_and_recasts`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (filter !== undefined) {\n                localVarQueryParameter['filter'] = filter;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.\n         * @summary Trending feeds\n         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 10)\n         * @param {string} [cursor] Pagination cursor\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FetchTrendingFeedTimeWindowEnum} [timeWindow] Time window for trending casts (7d window for channel feeds only)\n         * @param {string} [channelId] Channel ID to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.\n         * @param {string} [parentUrl] Parent URL to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.\n         * @param {FeedTrendingProvider} [provider] The provider of the trending casts feed.\n         * @param {string} [providerMetadata] provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)\n         *\n         */\n        fetchTrendingFeed: async (limit, cursor, viewerFid, timeWindow, channelId, parentUrl, provider, providerMetadata, xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/feed/trending`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (timeWindow !== undefined) {\n                localVarQueryParameter['time_window'] = timeWindow;\n            }\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (parentUrl !== undefined) {\n                localVarQueryParameter['parent_url'] = parentUrl;\n            }\n            if (provider !== undefined) {\n                localVarQueryParameter['provider'] = provider;\n            }\n            if (providerMetadata !== undefined) {\n                localVarQueryParameter['provider_metadata'] = providerMetadata;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch feed based on who a user is following\n         * @summary Following\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)\n         *\n         */\n        fetchUserFollowingFeed: async (fid, viewerFid, withRecasts, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserFollowingFeed', 'fid', fid);\n            const localVarPath = `/farcaster/feed/following`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (withRecasts !== undefined) {\n                localVarQueryParameter['with_recasts'] = withRecasts;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FeedApiAxiosParamCreator = FeedApiAxiosParamCreator;\n/**\n * FeedApi - functional programming interface\n * @export\n */\nconst FeedApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FeedApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel\n         * @summary Chronologically\n         * @param {number} fid FID of user whose recent casts you want to fetch\n         * @param {number} [appFid] Optionally filter to casts created via a specific app FID, e.g. 9152 for Warpcast\n         * @param {number} [viewerFid] FID of the user viewing the feed\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 150)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [includeReplies] Include reply casts by the author in the response, true by default\n         * @param {string} [parentUrl] Parent URL to filter the feed; mutually exclusive with channel_id\n         * @param {string} [channelId] Channel ID to filter the feed; mutually exclusive with parent_url\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)\n         *\n         */\n        async fetchCastsForUser(fid, appFid, viewerFid, limit, cursor, includeReplies, parentUrl, channelId, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastsForUser(fid, appFid, viewerFid, limit, cursor, includeReplies, parentUrl, channelId, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchCastsForUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.\n         * @summary By filters\n         * @param {FeedType} feedType Defaults to following (requires FID or address). If set to filter (requires filter_type)\n         * @param {FilterType} [filterType] Used when feed_type&#x3D;filter. Can be set to FIDs (requires FIDs) or parent_url (requires parent_url) or channel_id (requires channel_id)\n         * @param {number} [fid] (Optional) FID of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type\n         * @param {string} [fids] Used when filter_type&#x3D;FIDs . Create a feed based on a list of FIDs. Max array size is 100. Requires feed_type and filter_type.\n         * @param {string} [parentUrl] Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type.\n         * @param {string} [channelId] Used when filter_type&#x3D;channel_id can be used to fetch casts under a channel. Requires feed_type and filter_type.\n         * @param {boolean} [membersOnly] Used when filter_type&#x3D;channel_id. Only include casts from members of the channel. True by default.\n         * @param {string} [embedUrl] Used when filter_type&#x3D;embed_url. Casts with embedded URLs prefixed by this embed_url param will be returned. We normalize your given URL prefix and prepend \\&#39;https://\\&#39; if no protocol is included. Requires feed_type and filter_type.\n         * @param {Array<EmbedType>} [embedTypes] Used when filter_type&#x3D;embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type.\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)\n         *\n         */\n        async fetchFeed(feedType, filterType, fid, fids, parentUrl, channelId, membersOnly, embedUrl, embedTypes, withRecasts, limit, cursor, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFeed(feedType, filterType, fid, fids, parentUrl, channelId, membersOnly, embedUrl, embedTypes, withRecasts, limit, cursor, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchFeed']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch feed based on channel IDs\n         * @summary By channel IDs\n         * @param {string} channelIds Comma separated list of up to 10 channel IDs e.g. neynar,farcaster\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withReplies] Include replies in the response, false by default\n         * @param {boolean} [membersOnly] Only include casts from members of the channel. True by default.\n         * @param {string} [fids] Comma separated list of FIDs to filter the feed by, up to 10 at a time\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [shouldModerate] If true, only casts that have been liked by the moderator (if one exists) will be returned.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)\n         *\n         */\n        async fetchFeedByChannelIds(channelIds, withRecasts, viewerFid, withReplies, membersOnly, fids, limit, cursor, shouldModerate, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFeedByChannelIds(channelIds, withRecasts, viewerFid, withReplies, membersOnly, fids, limit, cursor, shouldModerate, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchFeedByChannelIds']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch feed based on parent URLs\n         * @summary By parent URLs\n         * @param {string} parentUrls Comma separated list of parent_urls\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withReplies] Include replies in the response, false by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)\n         *\n         */\n        async fetchFeedByParentUrls(parentUrls, withRecasts, viewerFid, withReplies, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFeedByParentUrls(parentUrls, withRecasts, viewerFid, withReplies, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchFeedByParentUrls']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a personalized For You feed for a user\n         * @summary For you\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {ForYouProvider} [provider]\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {string} [providerMetadata] provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)\n         *\n         */\n        async fetchFeedForYou(fid, viewerFid, provider, limit, cursor, providerMetadata, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFeedForYou(fid, viewerFid, provider, limit, cursor, providerMetadata, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchFeedForYou']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch feed of casts with mini apps, reverse chronological order\n         * @summary Casts with mini apps\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)\n         *\n         */\n        async fetchFramesOnlyFeed(limit, viewerFid, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFramesOnlyFeed(limit, viewerFid, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchFramesOnlyFeed']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first\n         * @summary 10 most popular casts\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)\n         *\n         */\n        async fetchPopularCastsByUser(fid, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPopularCastsByUser(fid, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchPopularCastsByUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch recent replies and recasts for a given user FID; sorted by most recent first\n         * @summary Replies and recasts\n         * @param {number} fid FID of user whose replies and recasts you want to fetch\n         * @param {FetchRepliesAndRecastsForUserFilterEnum} [filter] filter to fetch only replies or recasts\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 50)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)\n         *\n         */\n        async fetchRepliesAndRecastsForUser(fid, filter, limit, cursor, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRepliesAndRecastsForUser(fid, filter, limit, cursor, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchRepliesAndRecastsForUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.\n         * @summary Trending feeds\n         * @param {number} [limit] Number of results to fetch  (Default: 10, Maximum: 10)\n         * @param {string} [cursor] Pagination cursor\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FetchTrendingFeedTimeWindowEnum} [timeWindow] Time window for trending casts (7d window for channel feeds only)\n         * @param {string} [channelId] Channel ID to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.\n         * @param {string} [parentUrl] Parent URL to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.\n         * @param {FeedTrendingProvider} [provider] The provider of the trending casts feed.\n         * @param {string} [providerMetadata] provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)\n         *\n         */\n        async fetchTrendingFeed(limit, cursor, viewerFid, timeWindow, channelId, parentUrl, provider, providerMetadata, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchTrendingFeed(limit, cursor, viewerFid, timeWindow, channelId, parentUrl, provider, providerMetadata, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchTrendingFeed']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch feed based on who a user is following\n         * @summary Following\n         * @param {number} fid FID of user whose feed you want to create\n         * @param {number} [viewerFid] Providing this will return a feed that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [withRecasts] Include recasts in the response, true by default\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)\n         *\n         */\n        async fetchUserFollowingFeed(fid, viewerFid, withRecasts, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserFollowingFeed(fid, viewerFid, withRecasts, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FeedApi.fetchUserFollowingFeed']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FeedApiFp = FeedApiFp;\n/**\n * FeedApi - factory interface\n * @export\n */\nconst FeedApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FeedApiFp)(configuration);\n    return {\n        /**\n         * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel\n         * @summary Chronologically\n         * @param {FeedApiFetchCastsForUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)\n         *\n         */\n        fetchCastsForUser(requestParameters, options) {\n            return localVarFp.fetchCastsForUser(requestParameters.fid, requestParameters.appFid, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.includeReplies, requestParameters.parentUrl, requestParameters.channelId, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.\n         * @summary By filters\n         * @param {FeedApiFetchFeedRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)\n         *\n         */\n        fetchFeed(requestParameters, options) {\n            return localVarFp.fetchFeed(requestParameters.feedType, requestParameters.filterType, requestParameters.fid, requestParameters.fids, requestParameters.parentUrl, requestParameters.channelId, requestParameters.membersOnly, requestParameters.embedUrl, requestParameters.embedTypes, requestParameters.withRecasts, requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch feed based on channel IDs\n         * @summary By channel IDs\n         * @param {FeedApiFetchFeedByChannelIdsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)\n         *\n         */\n        fetchFeedByChannelIds(requestParameters, options) {\n            return localVarFp.fetchFeedByChannelIds(requestParameters.channelIds, requestParameters.withRecasts, requestParameters.viewerFid, requestParameters.withReplies, requestParameters.membersOnly, requestParameters.fids, requestParameters.limit, requestParameters.cursor, requestParameters.shouldModerate, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch feed based on parent URLs\n         * @summary By parent URLs\n         * @param {FeedApiFetchFeedByParentUrlsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)\n         *\n         */\n        fetchFeedByParentUrls(requestParameters, options) {\n            return localVarFp.fetchFeedByParentUrls(requestParameters.parentUrls, requestParameters.withRecasts, requestParameters.viewerFid, requestParameters.withReplies, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a personalized For You feed for a user\n         * @summary For you\n         * @param {FeedApiFetchFeedForYouRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)\n         *\n         */\n        fetchFeedForYou(requestParameters, options) {\n            return localVarFp.fetchFeedForYou(requestParameters.fid, requestParameters.viewerFid, requestParameters.provider, requestParameters.limit, requestParameters.cursor, requestParameters.providerMetadata, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch feed of casts with mini apps, reverse chronological order\n         * @summary Casts with mini apps\n         * @param {FeedApiFetchFramesOnlyFeedRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)\n         *\n         */\n        fetchFramesOnlyFeed(requestParameters = {}, options) {\n            return localVarFp.fetchFramesOnlyFeed(requestParameters.limit, requestParameters.viewerFid, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first\n         * @summary 10 most popular casts\n         * @param {FeedApiFetchPopularCastsByUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)\n         *\n         */\n        fetchPopularCastsByUser(requestParameters, options) {\n            return localVarFp.fetchPopularCastsByUser(requestParameters.fid, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch recent replies and recasts for a given user FID; sorted by most recent first\n         * @summary Replies and recasts\n         * @param {FeedApiFetchRepliesAndRecastsForUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)\n         *\n         */\n        fetchRepliesAndRecastsForUser(requestParameters, options) {\n            return localVarFp.fetchRepliesAndRecastsForUser(requestParameters.fid, requestParameters.filter, requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.\n         * @summary Trending feeds\n         * @param {FeedApiFetchTrendingFeedRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)\n         *\n         */\n        fetchTrendingFeed(requestParameters = {}, options) {\n            return localVarFp.fetchTrendingFeed(requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.channelId, requestParameters.parentUrl, requestParameters.provider, requestParameters.providerMetadata, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch feed based on who a user is following\n         * @summary Following\n         * @param {FeedApiFetchUserFollowingFeedRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)\n         *\n         */\n        fetchUserFollowingFeed(requestParameters, options) {\n            return localVarFp.fetchUserFollowingFeed(requestParameters.fid, requestParameters.viewerFid, requestParameters.withRecasts, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FeedApiFactory = FeedApiFactory;\n/**\n * FeedApi - object-oriented interface\n * @export\n * @class FeedApi\n * @extends {BaseAPI}\n */\nclass FeedApi extends base_1.BaseAPI {\n    /**\n     * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel\n     * @summary Chronologically\n     * @param {FeedApiFetchCastsForUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)\n     *\n     */\n    fetchCastsForUser(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchCastsForUser(requestParameters.fid, requestParameters.appFid, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.includeReplies, requestParameters.parentUrl, requestParameters.channelId, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.\n     * @summary By filters\n     * @param {FeedApiFetchFeedRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)\n     *\n     */\n    fetchFeed(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchFeed(requestParameters.feedType, requestParameters.filterType, requestParameters.fid, requestParameters.fids, requestParameters.parentUrl, requestParameters.channelId, requestParameters.membersOnly, requestParameters.embedUrl, requestParameters.embedTypes, requestParameters.withRecasts, requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch feed based on channel IDs\n     * @summary By channel IDs\n     * @param {FeedApiFetchFeedByChannelIdsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)\n     *\n     */\n    fetchFeedByChannelIds(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchFeedByChannelIds(requestParameters.channelIds, requestParameters.withRecasts, requestParameters.viewerFid, requestParameters.withReplies, requestParameters.membersOnly, requestParameters.fids, requestParameters.limit, requestParameters.cursor, requestParameters.shouldModerate, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch feed based on parent URLs\n     * @summary By parent URLs\n     * @param {FeedApiFetchFeedByParentUrlsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)\n     *\n     */\n    fetchFeedByParentUrls(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchFeedByParentUrls(requestParameters.parentUrls, requestParameters.withRecasts, requestParameters.viewerFid, requestParameters.withReplies, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a personalized For You feed for a user\n     * @summary For you\n     * @param {FeedApiFetchFeedForYouRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)\n     *\n     */\n    fetchFeedForYou(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchFeedForYou(requestParameters.fid, requestParameters.viewerFid, requestParameters.provider, requestParameters.limit, requestParameters.cursor, requestParameters.providerMetadata, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch feed of casts with mini apps, reverse chronological order\n     * @summary Casts with mini apps\n     * @param {FeedApiFetchFramesOnlyFeedRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)\n     *\n     */\n    fetchFramesOnlyFeed(requestParameters = {}, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchFramesOnlyFeed(requestParameters.limit, requestParameters.viewerFid, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first\n     * @summary 10 most popular casts\n     * @param {FeedApiFetchPopularCastsByUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)\n     *\n     */\n    fetchPopularCastsByUser(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchPopularCastsByUser(requestParameters.fid, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch recent replies and recasts for a given user FID; sorted by most recent first\n     * @summary Replies and recasts\n     * @param {FeedApiFetchRepliesAndRecastsForUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)\n     *\n     */\n    fetchRepliesAndRecastsForUser(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchRepliesAndRecastsForUser(requestParameters.fid, requestParameters.filter, requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.\n     * @summary Trending feeds\n     * @param {FeedApiFetchTrendingFeedRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)\n     *\n     */\n    fetchTrendingFeed(requestParameters = {}, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchTrendingFeed(requestParameters.limit, requestParameters.cursor, requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.channelId, requestParameters.parentUrl, requestParameters.provider, requestParameters.providerMetadata, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch feed based on who a user is following\n     * @summary Following\n     * @param {FeedApiFetchUserFollowingFeedRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FeedApi\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)\n     *\n     */\n    fetchUserFollowingFeed(requestParameters, options) {\n        return (0, exports.FeedApiFp)(this.configuration).fetchUserFollowingFeed(requestParameters.fid, requestParameters.viewerFid, requestParameters.withRecasts, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FeedApi = FeedApi;\n/**\n * @export\n */\nexports.FetchRepliesAndRecastsForUserFilterEnum = {\n    Replies: 'replies',\n    Recasts: 'recasts',\n    All: 'all'\n};\n/**\n * @export\n */\nexports.FetchTrendingFeedTimeWindowEnum = {\n    _1h: '1h',\n    _6h: '6h',\n    _12h: '12h',\n    _24h: '24h',\n    _7d: '7d'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZlZWQtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1Q0FBdUMsR0FBRywrQ0FBK0MsR0FBRyxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsZ0NBQWdDO0FBQzNMLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsUUFBUSwyQ0FBMkM7QUFDdEUsbUJBQW1CLFFBQVEsMkNBQTJDO0FBQ3RFLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0pBQWdKO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGVBQWUsNkNBQTZDO0FBQzVELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0NBQXNDO0FBQ3JELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9mZWVkLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2hUcmVuZGluZ0ZlZWRUaW1lV2luZG93RW51bSA9IGV4cG9ydHMuRmV0Y2hSZXBsaWVzQW5kUmVjYXN0c0ZvclVzZXJGaWx0ZXJFbnVtID0gZXhwb3J0cy5GZWVkQXBpID0gZXhwb3J0cy5GZWVkQXBpRmFjdG9yeSA9IGV4cG9ydHMuRmVlZEFwaUZwID0gZXhwb3J0cy5GZWVkQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBGZWVkQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRmVlZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggY2FzdHMgZm9yIGEgZ2l2ZW4gdXNlciBGSUQgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLiBBbHNvIGFsbG93cyBmaWx0ZXJpbmcgYnkgcGFyZW50X3VybCBhbmQgY2hhbm5lbFxuICAgICAgICAgKiBAc3VtbWFyeSBDaHJvbm9sb2dpY2FsbHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdXNlciB3aG9zZSByZWNlbnQgY2FzdHMgeW91IHdhbnQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcHBGaWRdIE9wdGlvbmFsbHkgZmlsdGVyIHRvIGNhc3RzIGNyZWF0ZWQgdmlhIGEgc3BlY2lmaWMgYXBwIEZJRCwgZS5nLiA5MTUyIGZvciBXYXJwY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gRklEIG9mIHRoZSB1c2VyIHZpZXdpbmcgdGhlIGZlZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTUwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZVJlcGxpZXNdIEluY2x1ZGUgcmVwbHkgY2FzdHMgYnkgdGhlIGF1dGhvciBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmVudFVybF0gUGFyZW50IFVSTCB0byBmaWx0ZXIgdGhlIGZlZWQ7IG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGNoYW5uZWxfaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFubmVsSWRdIENoYW5uZWwgSUQgdG8gZmlsdGVyIHRoZSBmZWVkOyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBwYXJlbnRfdXJsXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtZm9yLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENhc3RzRm9yVXNlcjogYXN5bmMgKGZpZCwgYXBwRmlkLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIGluY2x1ZGVSZXBsaWVzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hDYXN0c0ZvclVzZXInLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZlZWQvdXNlci9jYXN0c2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFwcEZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYXBwX2ZpZCddID0gYXBwRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlUmVwbGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnaW5jbHVkZV9yZXBsaWVzJ10gPSBpbmNsdWRlUmVwbGllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhcmVudF91cmwnXSA9IHBhcmVudFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFubmVsSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2NoYW5uZWxfaWQnXSA9IGNoYW5uZWxJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBjYXN0cyBiYXNlZCBvbiBmaWx0ZXJzLiBFbnN1cmUgc2V0dGluZyB0aGUgY29ycmVjdCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBmaWx0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RmVlZFR5cGV9IGZlZWRUeXBlIERlZmF1bHRzIHRvIGZvbGxvd2luZyAocmVxdWlyZXMgRklEIG9yIGFkZHJlc3MpLiBJZiBzZXQgdG8gZmlsdGVyIChyZXF1aXJlcyBmaWx0ZXJfdHlwZSlcbiAgICAgICAgICogQHBhcmFtIHtGaWx0ZXJUeXBlfSBbZmlsdGVyVHlwZV0gVXNlZCB3aGVuIGZlZWRfdHlwZSYjeDNEO2ZpbHRlci4gQ2FuIGJlIHNldCB0byBGSURzIChyZXF1aXJlcyBGSURzKSBvciBwYXJlbnRfdXJsIChyZXF1aXJlcyBwYXJlbnRfdXJsKSBvciBjaGFubmVsX2lkIChyZXF1aXJlcyBjaGFubmVsX2lkKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2ZpZF0gKE9wdGlvbmFsKSBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZS4gQnkgZGVmYXVsdCwgdGhlIEFQSSBleHBlY3RzIHRoaXMgZmllbGQsIGV4Y2VwdCBpZiB5b3UgcGFzcyBhIGZpbHRlcl90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlkc10gVXNlZCB3aGVuIGZpbHRlcl90eXBlJiN4M0Q7RklEcyAuIENyZWF0ZSBhIGZlZWQgYmFzZWQgb24gYSBsaXN0IG9mIEZJRHMuIE1heCBhcnJheSBzaXplIGlzIDEwMC4gUmVxdWlyZXMgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJlbnRVcmxdIFVzZWQgd2hlbiBmaWx0ZXJfdHlwZSYjeDNEO3BhcmVudF91cmwgY2FuIGJlIHVzZWQgdG8gZmV0Y2ggY29udGVudCB1bmRlciBhbnkgcGFyZW50IHVybCBlLmcuIEZJUC0yIGNoYW5uZWxzIG9uIFdhcnBjYXN0LiBSZXF1aXJlcyBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYW5uZWxJZF0gVXNlZCB3aGVuIGZpbHRlcl90eXBlJiN4M0Q7Y2hhbm5lbF9pZCBjYW4gYmUgdXNlZCB0byBmZXRjaCBjYXN0cyB1bmRlciBhIGNoYW5uZWwuIFJlcXVpcmVzIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21lbWJlcnNPbmx5XSBVc2VkIHdoZW4gZmlsdGVyX3R5cGUmI3gzRDtjaGFubmVsX2lkLiBPbmx5IGluY2x1ZGUgY2FzdHMgZnJvbSBtZW1iZXJzIG9mIHRoZSBjaGFubmVsLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW1iZWRVcmxdIFVzZWQgd2hlbiBmaWx0ZXJfdHlwZSYjeDNEO2VtYmVkX3VybC4gQ2FzdHMgd2l0aCBlbWJlZGRlZCBVUkxzIHByZWZpeGVkIGJ5IHRoaXMgZW1iZWRfdXJsIHBhcmFtIHdpbGwgYmUgcmV0dXJuZWQuIFdlIG5vcm1hbGl6ZSB5b3VyIGdpdmVuIFVSTCBwcmVmaXggYW5kIHByZXBlbmQgXFwmIzM5O2h0dHBzOi8vXFwmIzM5OyBpZiBubyBwcm90b2NvbCBpcyBpbmNsdWRlZC4gUmVxdWlyZXMgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbWJlZFR5cGU+fSBbZW1iZWRUeXBlc10gVXNlZCB3aGVuIGZpbHRlcl90eXBlJiN4M0Q7ZW1iZWRfdHlwZXMgY2FuIGJlIHVzZWQgdG8gZmV0Y2ggYWxsIGNhc3RzIHdpdGggbWF0Y2hpbmcgY29udGVudCB0eXBlcy4gUmVxdWlyZXMgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlY2FzdHNdIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZlZWQ6IGFzeW5jIChmZWVkVHlwZSwgZmlsdGVyVHlwZSwgZmlkLCBmaWRzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgbWVtYmVyc09ubHksIGVtYmVkVXJsLCBlbWJlZFR5cGVzLCB3aXRoUmVjYXN0cywgbGltaXQsIGN1cnNvciwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZlZWRUeXBlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoRmVlZCcsICdmZWVkVHlwZScsIGZlZWRUeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZlZWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmVlZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZlZWRfdHlwZSddID0gZmVlZFR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlsdGVyX3R5cGUnXSA9IGZpbHRlclR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWRzJ10gPSBmaWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFyZW50X3VybCddID0gcGFyZW50VXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5uZWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY2hhbm5lbF9pZCddID0gY2hhbm5lbElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lbWJlcnNPbmx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydtZW1iZXJzX29ubHknXSA9IG1lbWJlcnNPbmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtYmVkVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydlbWJlZF91cmwnXSA9IGVtYmVkVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtYmVkVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydlbWJlZF90eXBlcyddID0gZW1iZWRUeXBlcy5qb2luKGJhc2VfMS5DT0xMRUNUSU9OX0ZPUk1BVFMuY3N2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aXRoUmVjYXN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnd2l0aF9yZWNhc3RzJ10gPSB3aXRoUmVjYXN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiBjaGFubmVsIElEc1xuICAgICAgICAgKiBAc3VtbWFyeSBCeSBjaGFubmVsIElEc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbElkcyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiB1cCB0byAxMCBjaGFubmVsIElEcyBlLmcuIG5leW5hcixmYXJjYXN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlY2FzdHNdIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhSZXBsaWVzXSBJbmNsdWRlIHJlcGxpZXMgaW4gdGhlIHJlc3BvbnNlLCBmYWxzZSBieSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21lbWJlcnNPbmx5XSBPbmx5IGluY2x1ZGUgY2FzdHMgZnJvbSBtZW1iZXJzIG9mIHRoZSBjaGFubmVsLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlkc10gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRklEcyB0byBmaWx0ZXIgdGhlIGZlZWQgYnksIHVwIHRvIDEwIGF0IGEgdGltZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkTW9kZXJhdGVdIElmIHRydWUsIG9ubHkgY2FzdHMgdGhhdCBoYXZlIGJlZW4gbGlrZWQgYnkgdGhlIG1vZGVyYXRvciAoaWYgb25lIGV4aXN0cykgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mZWVkLWJ5LWNoYW5uZWwtaWRzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGZWVkQnlDaGFubmVsSWRzOiBhc3luYyAoY2hhbm5lbElkcywgd2l0aFJlY2FzdHMsIHZpZXdlckZpZCwgd2l0aFJlcGxpZXMsIG1lbWJlcnNPbmx5LCBmaWRzLCBsaW1pdCwgY3Vyc29yLCBzaG91bGRNb2RlcmF0ZSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjaGFubmVsSWRzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoRmVlZEJ5Q2hhbm5lbElkcycsICdjaGFubmVsSWRzJywgY2hhbm5lbElkcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mZWVkL2NoYW5uZWxzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWxJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2NoYW5uZWxfaWRzJ10gPSBjaGFubmVsSWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpdGhSZWNhc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd3aXRoX3JlY2FzdHMnXSA9IHdpdGhSZWNhc3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpdGhSZXBsaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd3aXRoX3JlcGxpZXMnXSA9IHdpdGhSZXBsaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lbWJlcnNPbmx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydtZW1iZXJzX29ubHknXSA9IG1lbWJlcnNPbmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZHMnXSA9IGZpZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZE1vZGVyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzaG91bGRfbW9kZXJhdGUnXSA9IHNob3VsZE1vZGVyYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGZlZWQgYmFzZWQgb24gcGFyZW50IFVSTHNcbiAgICAgICAgICogQHN1bW1hcnkgQnkgcGFyZW50IFVSTHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFVybHMgQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgcGFyZW50X3VybHNcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlY2FzdHNdIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhSZXBsaWVzXSBJbmNsdWRlIHJlcGxpZXMgaW4gdGhlIHJlc3BvbnNlLCBmYWxzZSBieSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtYnktcGFyZW50LXVybHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZlZWRCeVBhcmVudFVybHM6IGFzeW5jIChwYXJlbnRVcmxzLCB3aXRoUmVjYXN0cywgdmlld2VyRmlkLCB3aXRoUmVwbGllcywgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdwYXJlbnRVcmxzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoRmVlZEJ5UGFyZW50VXJscycsICdwYXJlbnRVcmxzJywgcGFyZW50VXJscyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mZWVkL3BhcmVudF91cmxzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHBhcmVudFVybHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhcmVudF91cmxzJ10gPSBwYXJlbnRVcmxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpdGhSZWNhc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd3aXRoX3JlY2FzdHMnXSA9IHdpdGhSZWNhc3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpdGhSZXBsaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd3aXRoX3JlcGxpZXMnXSA9IHdpdGhSZXBsaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIHBlcnNvbmFsaXplZCBGb3IgWW91IGZlZWQgZm9yIGEgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBGb3IgeW91XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHVzZXIgd2hvc2UgZmVlZCB5b3Ugd2FudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge0ZvcllvdVByb3ZpZGVyfSBbcHJvdmlkZXJdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDUwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdmlkZXJNZXRhZGF0YV0gcHJvdmlkZXJfbWV0YWRhdGEgaXMgYSBVUkktZW5jb2RlZCBzdHJpbmdpZmllZCBKU09OIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhc3MgYWRkaXRpb25hbCBtZXRhZGF0YSB0byB0aGUgcHJvdmlkZXIuIE9ubHkgYXZhaWxhYmxlIGZvciBtYmQgcHJvdmlkZXIgcmlnaHQgbm93LiBTZWUgW2hlcmVdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmVlZC1mb3IteW91LXctZXh0ZXJuYWwtcHJvdmlkZXJzKSBvbiBob3cgdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtZm9yLXlvdSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoRmVlZEZvcllvdTogYXN5bmMgKGZpZCwgdmlld2VyRmlkLCBwcm92aWRlciwgbGltaXQsIGN1cnNvciwgcHJvdmlkZXJNZXRhZGF0YSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hGZWVkRm9yWW91JywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mZWVkL2Zvcl95b3VgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJvdmlkZXInXSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlck1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwcm92aWRlcl9tZXRhZGF0YSddID0gcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBmZWVkIG9mIGNhc3RzIHdpdGggbWluaSBhcHBzLCByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ2FzdHMgd2l0aCBtaW5pIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mcmFtZXMtb25seS1mZWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGcmFtZXNPbmx5RmVlZDogYXN5bmMgKGxpbWl0LCB2aWV3ZXJGaWQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mZWVkL2ZyYW1lc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggMTAgbW9zdCBwb3B1bGFyIGNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBwb3B1bGFyaXR5IGJhc2VkIG9uIHJlcGxpZXMsIGxpa2VzIGFuZCByZWNhc3RzOyBzb3J0ZWQgYnkgbW9zdCBwb3B1bGFyIGZpcnN0XG4gICAgICAgICAqIEBzdW1tYXJ5IDEwIG1vc3QgcG9wdWxhciBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB1c2VyIHdob3NlIGZlZWQgeW91IHdhbnQgdG8gY3JlYXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrQ2FzdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtDYXN0c1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1wb3B1bGFyLWNhc3RzLWJ5LXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFBvcHVsYXJDYXN0c0J5VXNlcjogYXN5bmMgKGZpZCwgdmlld2VyRmlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFBvcHVsYXJDYXN0c0J5VXNlcicsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZmVlZC91c2VyL3BvcHVsYXJgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHJlY2VudCByZXBsaWVzIGFuZCByZWNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBzb3J0ZWQgYnkgbW9zdCByZWNlbnQgZmlyc3RcbiAgICAgICAgICogQHN1bW1hcnkgUmVwbGllcyBhbmQgcmVjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB1c2VyIHdob3NlIHJlcGxpZXMgYW5kIHJlY2FzdHMgeW91IHdhbnQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlckZpbHRlckVudW19IFtmaWx0ZXJdIGZpbHRlciB0byBmZXRjaCBvbmx5IHJlcGxpZXMgb3IgcmVjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiA1MClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVwbGllcy1hbmQtcmVjYXN0cy1mb3ItdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyOiBhc3luYyAoZmlkLCBmaWx0ZXIsIGxpbWl0LCBjdXJzb3IsIHZpZXdlckZpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hSZXBsaWVzQW5kUmVjYXN0c0ZvclVzZXInLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZlZWQvdXNlci9yZXBsaWVzX2FuZF9yZWNhc3RzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWx0ZXInXSA9IGZpbHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB0cmVuZGluZyBjYXN0cyBvciBvbiB0aGUgZ2xvYmFsIGZlZWQgb3IgY2hhbm5lbHMgZmVlZHMuIDdkIHRpbWUgd2luZG93IGF2YWlsYWJsZSBmb3IgY2hhbm5lbCBmZWVkcyBvbmx5LlxuICAgICAgICAgKiBAc3VtbWFyeSBUcmVuZGluZyBmZWVkc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDEwLCBNYXhpbXVtOiAxMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFRyZW5kaW5nRmVlZFRpbWVXaW5kb3dFbnVtfSBbdGltZVdpbmRvd10gVGltZSB3aW5kb3cgZm9yIHRyZW5kaW5nIGNhc3RzICg3ZCB3aW5kb3cgZm9yIGNoYW5uZWwgZmVlZHMgb25seSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFubmVsSWRdIENoYW5uZWwgSUQgdG8gZmlsdGVyIHRyZW5kaW5nIGNhc3RzLiBMZXNzIGFjdGl2ZSBjaGFubmVscyBtaWdodCBoYXZlIG5vIGNhc3RzIGluIHRoZSB0aW1lIHdpbmRvdyBzZWxlY3RlZC4gUHJvdmlkZSBlaXRoZXIgJiN4NjA7Y2hhbm5lbF9pZCYjeDYwOyBvciAmI3g2MDtwYXJlbnRfdXJsJiN4NjA7LCBub3QgYm90aC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJlbnRVcmxdIFBhcmVudCBVUkwgdG8gZmlsdGVyIHRyZW5kaW5nIGNhc3RzLiBMZXNzIGFjdGl2ZSBjaGFubmVscyBtaWdodCBoYXZlIG5vIGNhc3RzIGluIHRoZSB0aW1lIHdpbmRvdyBzZWxlY3RlZC4gUHJvdmlkZSBlaXRoZXIgJiN4NjA7Y2hhbm5lbF9pZCYjeDYwOyBvciAmI3g2MDtwYXJlbnRfdXJsJiN4NjA7LCBub3QgYm90aC5cbiAgICAgICAgICogQHBhcmFtIHtGZWVkVHJlbmRpbmdQcm92aWRlcn0gW3Byb3ZpZGVyXSBUaGUgcHJvdmlkZXIgb2YgdGhlIHRyZW5kaW5nIGNhc3RzIGZlZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdmlkZXJNZXRhZGF0YV0gcHJvdmlkZXJfbWV0YWRhdGEgaXMgYSBVUkktZW5jb2RlZCBzdHJpbmdpZmllZCBKU09OIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhc3MgYWRkaXRpb25hbCBtZXRhZGF0YSB0byB0aGUgcHJvdmlkZXIuIE9ubHkgYXZhaWxhYmxlIGZvciBtYmQgcHJvdmlkZXIgcmlnaHQgbm93LiBTZWUgW2hlcmVdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmVlZC1mb3IteW91LXctZXh0ZXJuYWwtcHJvdmlkZXJzKSBvbiBob3cgdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWZlZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFRyZW5kaW5nRmVlZDogYXN5bmMgKGxpbWl0LCBjdXJzb3IsIHZpZXdlckZpZCwgdGltZVdpbmRvdywgY2hhbm5lbElkLCBwYXJlbnRVcmwsIHByb3ZpZGVyLCBwcm92aWRlck1ldGFkYXRhLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZlZWQvdHJlbmRpbmdgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVXaW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RpbWVfd2luZG93J10gPSB0aW1lV2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5uZWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY2hhbm5lbF9pZCddID0gY2hhbm5lbElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFyZW50X3VybCddID0gcGFyZW50VXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwcm92aWRlciddID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJNZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJvdmlkZXJfbWV0YWRhdGEnXSA9IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiB3aG8gYSB1c2VyIGlzIGZvbGxvd2luZ1xuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhSZWNhc3RzXSBJbmNsdWRlIHJlY2FzdHMgaW4gdGhlIHJlc3BvbnNlLCB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dpbmctZmVlZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckZvbGxvd2luZ0ZlZWQ6IGFzeW5jIChmaWQsIHZpZXdlckZpZCwgd2l0aFJlY2FzdHMsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlckZvbGxvd2luZ0ZlZWQnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZlZWQvZm9sbG93aW5nYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2l0aFJlY2FzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3dpdGhfcmVjYXN0cyddID0gd2l0aFJlY2FzdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRmVlZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gRmVlZEFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBGZWVkQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRmVlZEFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuRmVlZEFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggY2FzdHMgZm9yIGEgZ2l2ZW4gdXNlciBGSUQgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLiBBbHNvIGFsbG93cyBmaWx0ZXJpbmcgYnkgcGFyZW50X3VybCBhbmQgY2hhbm5lbFxuICAgICAgICAgKiBAc3VtbWFyeSBDaHJvbm9sb2dpY2FsbHlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdXNlciB3aG9zZSByZWNlbnQgY2FzdHMgeW91IHdhbnQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcHBGaWRdIE9wdGlvbmFsbHkgZmlsdGVyIHRvIGNhc3RzIGNyZWF0ZWQgdmlhIGEgc3BlY2lmaWMgYXBwIEZJRCwgZS5nLiA5MTUyIGZvciBXYXJwY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gRklEIG9mIHRoZSB1c2VyIHZpZXdpbmcgdGhlIGZlZWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTUwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZVJlcGxpZXNdIEluY2x1ZGUgcmVwbHkgY2FzdHMgYnkgdGhlIGF1dGhvciBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmVudFVybF0gUGFyZW50IFVSTCB0byBmaWx0ZXIgdGhlIGZlZWQ7IG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGNoYW5uZWxfaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFubmVsSWRdIENoYW5uZWwgSUQgdG8gZmlsdGVyIHRoZSBmZWVkOyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBwYXJlbnRfdXJsXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtZm9yLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaENhc3RzRm9yVXNlcihmaWQsIGFwcEZpZCwgdmlld2VyRmlkLCBsaW1pdCwgY3Vyc29yLCBpbmNsdWRlUmVwbGllcywgcGFyZW50VXJsLCBjaGFubmVsSWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2FzdHNGb3JVc2VyKGZpZCwgYXBwRmlkLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIGluY2x1ZGVSZXBsaWVzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZlZWRBcGkuZmV0Y2hDYXN0c0ZvclVzZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGNhc3RzIGJhc2VkIG9uIGZpbHRlcnMuIEVuc3VyZSBzZXR0aW5nIHRoZSBjb3JyZWN0IHBhcmFtZXRlcnMgYmFzZWQgb24gdGhlIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGZpbHRlcnNcbiAgICAgICAgICogQHBhcmFtIHtGZWVkVHlwZX0gZmVlZFR5cGUgRGVmYXVsdHMgdG8gZm9sbG93aW5nIChyZXF1aXJlcyBGSUQgb3IgYWRkcmVzcykuIElmIHNldCB0byBmaWx0ZXIgKHJlcXVpcmVzIGZpbHRlcl90eXBlKVxuICAgICAgICAgKiBAcGFyYW0ge0ZpbHRlclR5cGV9IFtmaWx0ZXJUeXBlXSBVc2VkIHdoZW4gZmVlZF90eXBlJiN4M0Q7ZmlsdGVyLiBDYW4gYmUgc2V0IHRvIEZJRHMgKHJlcXVpcmVzIEZJRHMpIG9yIHBhcmVudF91cmwgKHJlcXVpcmVzIHBhcmVudF91cmwpIG9yIGNoYW5uZWxfaWQgKHJlcXVpcmVzIGNoYW5uZWxfaWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmlkXSAoT3B0aW9uYWwpIEZJRCBvZiB1c2VyIHdob3NlIGZlZWQgeW91IHdhbnQgdG8gY3JlYXRlLiBCeSBkZWZhdWx0LCB0aGUgQVBJIGV4cGVjdHMgdGhpcyBmaWVsZCwgZXhjZXB0IGlmIHlvdSBwYXNzIGEgZmlsdGVyX3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWRzXSBVc2VkIHdoZW4gZmlsdGVyX3R5cGUmI3gzRDtGSURzIC4gQ3JlYXRlIGEgZmVlZCBiYXNlZCBvbiBhIGxpc3Qgb2YgRklEcy4gTWF4IGFycmF5IHNpemUgaXMgMTAwLiBSZXF1aXJlcyBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmVudFVybF0gVXNlZCB3aGVuIGZpbHRlcl90eXBlJiN4M0Q7cGFyZW50X3VybCBjYW4gYmUgdXNlZCB0byBmZXRjaCBjb250ZW50IHVuZGVyIGFueSBwYXJlbnQgdXJsIGUuZy4gRklQLTIgY2hhbm5lbHMgb24gV2FycGNhc3QuIFJlcXVpcmVzIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhbm5lbElkXSBVc2VkIHdoZW4gZmlsdGVyX3R5cGUmI3gzRDtjaGFubmVsX2lkIGNhbiBiZSB1c2VkIHRvIGZldGNoIGNhc3RzIHVuZGVyIGEgY2hhbm5lbC4gUmVxdWlyZXMgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbWVtYmVyc09ubHldIFVzZWQgd2hlbiBmaWx0ZXJfdHlwZSYjeDNEO2NoYW5uZWxfaWQuIE9ubHkgaW5jbHVkZSBjYXN0cyBmcm9tIG1lbWJlcnMgb2YgdGhlIGNoYW5uZWwuIFRydWUgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlbWJlZFVybF0gVXNlZCB3aGVuIGZpbHRlcl90eXBlJiN4M0Q7ZW1iZWRfdXJsLiBDYXN0cyB3aXRoIGVtYmVkZGVkIFVSTHMgcHJlZml4ZWQgYnkgdGhpcyBlbWJlZF91cmwgcGFyYW0gd2lsbCBiZSByZXR1cm5lZC4gV2Ugbm9ybWFsaXplIHlvdXIgZ2l2ZW4gVVJMIHByZWZpeCBhbmQgcHJlcGVuZCBcXCYjMzk7aHR0cHM6Ly9cXCYjMzk7IGlmIG5vIHByb3RvY29sIGlzIGluY2x1ZGVkLiBSZXF1aXJlcyBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEVtYmVkVHlwZT59IFtlbWJlZFR5cGVzXSBVc2VkIHdoZW4gZmlsdGVyX3R5cGUmI3gzRDtlbWJlZF90eXBlcyBjYW4gYmUgdXNlZCB0byBmZXRjaCBhbGwgY2FzdHMgd2l0aCBtYXRjaGluZyBjb250ZW50IHR5cGVzLiBSZXF1aXJlcyBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoUmVjYXN0c10gSW5jbHVkZSByZWNhc3RzIGluIHRoZSByZXNwb25zZSwgdHJ1ZSBieSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoRmVlZChmZWVkVHlwZSwgZmlsdGVyVHlwZSwgZmlkLCBmaWRzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgbWVtYmVyc09ubHksIGVtYmVkVXJsLCBlbWJlZFR5cGVzLCB3aXRoUmVjYXN0cywgbGltaXQsIGN1cnNvciwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEZlZWQoZmVlZFR5cGUsIGZpbHRlclR5cGUsIGZpZCwgZmlkcywgcGFyZW50VXJsLCBjaGFubmVsSWQsIG1lbWJlcnNPbmx5LCBlbWJlZFVybCwgZW1iZWRUeXBlcywgd2l0aFJlY2FzdHMsIGxpbWl0LCBjdXJzb3IsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZlZWRBcGkuZmV0Y2hGZWVkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBmZWVkIGJhc2VkIG9uIGNoYW5uZWwgSURzXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGNoYW5uZWwgSURzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsSWRzIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHVwIHRvIDEwIGNoYW5uZWwgSURzIGUuZy4gbmV5bmFyLGZhcmNhc3RlclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoUmVjYXN0c10gSW5jbHVkZSByZWNhc3RzIGluIHRoZSByZXNwb25zZSwgdHJ1ZSBieSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlcGxpZXNdIEluY2x1ZGUgcmVwbGllcyBpbiB0aGUgcmVzcG9uc2UsIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbWVtYmVyc09ubHldIE9ubHkgaW5jbHVkZSBjYXN0cyBmcm9tIG1lbWJlcnMgb2YgdGhlIGNoYW5uZWwuIFRydWUgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWRzXSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBGSURzIHRvIGZpbHRlciB0aGUgZmVlZCBieSwgdXAgdG8gMTAgYXQgYSB0aW1lXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG91bGRNb2RlcmF0ZV0gSWYgdHJ1ZSwgb25seSBjYXN0cyB0aGF0IGhhdmUgYmVlbiBsaWtlZCBieSB0aGUgbW9kZXJhdG9yIChpZiBvbmUgZXhpc3RzKSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtYnktY2hhbm5lbC1pZHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEZlZWRCeUNoYW5uZWxJZHMoY2hhbm5lbElkcywgd2l0aFJlY2FzdHMsIHZpZXdlckZpZCwgd2l0aFJlcGxpZXMsIG1lbWJlcnNPbmx5LCBmaWRzLCBsaW1pdCwgY3Vyc29yLCBzaG91bGRNb2RlcmF0ZSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGZWVkQnlDaGFubmVsSWRzKGNoYW5uZWxJZHMsIHdpdGhSZWNhc3RzLCB2aWV3ZXJGaWQsIHdpdGhSZXBsaWVzLCBtZW1iZXJzT25seSwgZmlkcywgbGltaXQsIGN1cnNvciwgc2hvdWxkTW9kZXJhdGUsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGZWVkQXBpLmZldGNoRmVlZEJ5Q2hhbm5lbElkcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiBwYXJlbnQgVVJMc1xuICAgICAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgVVJMc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50VXJscyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBwYXJlbnRfdXJsc1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoUmVjYXN0c10gSW5jbHVkZSByZWNhc3RzIGluIHRoZSByZXNwb25zZSwgdHJ1ZSBieSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlcGxpZXNdIEluY2x1ZGUgcmVwbGllcyBpbiB0aGUgcmVzcG9uc2UsIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZC1ieS1wYXJlbnQtdXJscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoRmVlZEJ5UGFyZW50VXJscyhwYXJlbnRVcmxzLCB3aXRoUmVjYXN0cywgdmlld2VyRmlkLCB3aXRoUmVwbGllcywgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGZWVkQnlQYXJlbnRVcmxzKHBhcmVudFVybHMsIHdpdGhSZWNhc3RzLCB2aWV3ZXJGaWQsIHdpdGhSZXBsaWVzLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRmVlZEFwaS5mZXRjaEZlZWRCeVBhcmVudFVybHMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgcGVyc29uYWxpemVkIEZvciBZb3UgZmVlZCBmb3IgYSB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB5b3VcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Rm9yWW91UHJvdmlkZXJ9IFtwcm92aWRlcl1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogNTApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcm92aWRlck1ldGFkYXRhXSBwcm92aWRlcl9tZXRhZGF0YSBpcyBhIFVSSS1lbmNvZGVkIHN0cmluZ2lmaWVkIEpTT04gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcGFzcyBhZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHRoZSBwcm92aWRlci4gT25seSBhdmFpbGFibGUgZm9yIG1iZCBwcm92aWRlciByaWdodCBub3cuIFNlZSBbaGVyZV0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vZG9jcy9mZWVkLWZvci15b3Utdy1leHRlcm5hbC1wcm92aWRlcnMpIG9uIGhvdyB0byB1c2UuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZC1mb3IteW91KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hGZWVkRm9yWW91KGZpZCwgdmlld2VyRmlkLCBwcm92aWRlciwgbGltaXQsIGN1cnNvciwgcHJvdmlkZXJNZXRhZGF0YSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGZWVkRm9yWW91KGZpZCwgdmlld2VyRmlkLCBwcm92aWRlciwgbGltaXQsIGN1cnNvciwgcHJvdmlkZXJNZXRhZGF0YSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZlZWRBcGkuZmV0Y2hGZWVkRm9yWW91J10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBmZWVkIG9mIGNhc3RzIHdpdGggbWluaSBhcHBzLCByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ2FzdHMgd2l0aCBtaW5pIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mcmFtZXMtb25seS1mZWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hGcmFtZXNPbmx5RmVlZChsaW1pdCwgdmlld2VyRmlkLCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoRnJhbWVzT25seUZlZWQobGltaXQsIHZpZXdlckZpZCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRmVlZEFwaS5mZXRjaEZyYW1lc09ubHlGZWVkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCAxMCBtb3N0IHBvcHVsYXIgY2FzdHMgZm9yIGEgZ2l2ZW4gdXNlciBGSUQ7IHBvcHVsYXJpdHkgYmFzZWQgb24gcmVwbGllcywgbGlrZXMgYW5kIHJlY2FzdHM7IHNvcnRlZCBieSBtb3N0IHBvcHVsYXIgZmlyc3RcbiAgICAgICAgICogQHN1bW1hcnkgMTAgbW9zdCBwb3B1bGFyIGNhc3RzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHVzZXIgd2hvc2UgZmVlZCB5b3Ugd2FudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtDYXN0c1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0Nhc3RzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvcHVsYXItY2FzdHMtYnktdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoUG9wdWxhckNhc3RzQnlVc2VyKGZpZCwgdmlld2VyRmlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFBvcHVsYXJDYXN0c0J5VXNlcihmaWQsIHZpZXdlckZpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZlZWRBcGkuZmV0Y2hQb3B1bGFyQ2FzdHNCeVVzZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHJlY2VudCByZXBsaWVzIGFuZCByZWNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBzb3J0ZWQgYnkgbW9zdCByZWNlbnQgZmlyc3RcbiAgICAgICAgICogQHN1bW1hcnkgUmVwbGllcyBhbmQgcmVjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB1c2VyIHdob3NlIHJlcGxpZXMgYW5kIHJlY2FzdHMgeW91IHdhbnQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlckZpbHRlckVudW19IFtmaWx0ZXJdIGZpbHRlciB0byBmZXRjaCBvbmx5IHJlcGxpZXMgb3IgcmVjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiA1MClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVwbGllcy1hbmQtcmVjYXN0cy1mb3ItdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKGZpZCwgZmlsdGVyLCBsaW1pdCwgY3Vyc29yLCB2aWV3ZXJGaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKGZpZCwgZmlsdGVyLCBsaW1pdCwgY3Vyc29yLCB2aWV3ZXJGaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGZWVkQXBpLmZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB0cmVuZGluZyBjYXN0cyBvciBvbiB0aGUgZ2xvYmFsIGZlZWQgb3IgY2hhbm5lbHMgZmVlZHMuIDdkIHRpbWUgd2luZG93IGF2YWlsYWJsZSBmb3IgY2hhbm5lbCBmZWVkcyBvbmx5LlxuICAgICAgICAgKiBAc3VtbWFyeSBUcmVuZGluZyBmZWVkc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDEwLCBNYXhpbXVtOiAxMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFRyZW5kaW5nRmVlZFRpbWVXaW5kb3dFbnVtfSBbdGltZVdpbmRvd10gVGltZSB3aW5kb3cgZm9yIHRyZW5kaW5nIGNhc3RzICg3ZCB3aW5kb3cgZm9yIGNoYW5uZWwgZmVlZHMgb25seSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFubmVsSWRdIENoYW5uZWwgSUQgdG8gZmlsdGVyIHRyZW5kaW5nIGNhc3RzLiBMZXNzIGFjdGl2ZSBjaGFubmVscyBtaWdodCBoYXZlIG5vIGNhc3RzIGluIHRoZSB0aW1lIHdpbmRvdyBzZWxlY3RlZC4gUHJvdmlkZSBlaXRoZXIgJiN4NjA7Y2hhbm5lbF9pZCYjeDYwOyBvciAmI3g2MDtwYXJlbnRfdXJsJiN4NjA7LCBub3QgYm90aC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJlbnRVcmxdIFBhcmVudCBVUkwgdG8gZmlsdGVyIHRyZW5kaW5nIGNhc3RzLiBMZXNzIGFjdGl2ZSBjaGFubmVscyBtaWdodCBoYXZlIG5vIGNhc3RzIGluIHRoZSB0aW1lIHdpbmRvdyBzZWxlY3RlZC4gUHJvdmlkZSBlaXRoZXIgJiN4NjA7Y2hhbm5lbF9pZCYjeDYwOyBvciAmI3g2MDtwYXJlbnRfdXJsJiN4NjA7LCBub3QgYm90aC5cbiAgICAgICAgICogQHBhcmFtIHtGZWVkVHJlbmRpbmdQcm92aWRlcn0gW3Byb3ZpZGVyXSBUaGUgcHJvdmlkZXIgb2YgdGhlIHRyZW5kaW5nIGNhc3RzIGZlZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdmlkZXJNZXRhZGF0YV0gcHJvdmlkZXJfbWV0YWRhdGEgaXMgYSBVUkktZW5jb2RlZCBzdHJpbmdpZmllZCBKU09OIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhc3MgYWRkaXRpb25hbCBtZXRhZGF0YSB0byB0aGUgcHJvdmlkZXIuIE9ubHkgYXZhaWxhYmxlIGZvciBtYmQgcHJvdmlkZXIgcmlnaHQgbm93LiBTZWUgW2hlcmVdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmVlZC1mb3IteW91LXctZXh0ZXJuYWwtcHJvdmlkZXJzKSBvbiBob3cgdG8gdXNlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWZlZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFRyZW5kaW5nRmVlZChsaW1pdCwgY3Vyc29yLCB2aWV3ZXJGaWQsIHRpbWVXaW5kb3csIGNoYW5uZWxJZCwgcGFyZW50VXJsLCBwcm92aWRlciwgcHJvdmlkZXJNZXRhZGF0YSwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hUcmVuZGluZ0ZlZWQobGltaXQsIGN1cnNvciwgdmlld2VyRmlkLCB0aW1lV2luZG93LCBjaGFubmVsSWQsIHBhcmVudFVybCwgcHJvdmlkZXIsIHByb3ZpZGVyTWV0YWRhdGEsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGZWVkQXBpLmZldGNoVHJlbmRpbmdGZWVkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBmZWVkIGJhc2VkIG9uIHdobyBhIHVzZXIgaXMgZm9sbG93aW5nXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvd2luZ1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB1c2VyIHdob3NlIGZlZWQgeW91IHdhbnQgdG8gY3JlYXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aFJlY2FzdHNdIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZy1mZWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93aW5nRmVlZChmaWQsIHZpZXdlckZpZCwgd2l0aFJlY2FzdHMsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlckZvbGxvd2luZ0ZlZWQoZmlkLCB2aWV3ZXJGaWQsIHdpdGhSZWNhc3RzLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRmVlZEFwaS5mZXRjaFVzZXJGb2xsb3dpbmdGZWVkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZlZWRBcGlGcCA9IEZlZWRBcGlGcDtcbi8qKlxuICogRmVlZEFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEZlZWRBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5GZWVkQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBjYXN0cyBmb3IgYSBnaXZlbiB1c2VyIEZJRCBpbiByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXIuIEFsc28gYWxsb3dzIGZpbHRlcmluZyBieSBwYXJlbnRfdXJsIGFuZCBjaGFubmVsXG4gICAgICAgICAqIEBzdW1tYXJ5IENocm9ub2xvZ2ljYWxseVxuICAgICAgICAgKiBAcGFyYW0ge0ZlZWRBcGlGZXRjaENhc3RzRm9yVXNlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0cy1mb3ItdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2FzdHNGb3JVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaENhc3RzRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmFwcEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy5pbmNsdWRlUmVwbGllcywgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50VXJsLCByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBjYXN0cyBiYXNlZCBvbiBmaWx0ZXJzLiBFbnN1cmUgc2V0dGluZyB0aGUgY29ycmVjdCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBmaWx0ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoRmVlZFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mZWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGZWVkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEZlZWQocmVxdWVzdFBhcmFtZXRlcnMuZmVlZFR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbHRlclR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuZmlkcywgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50VXJsLCByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLm1lbWJlcnNPbmx5LCByZXF1ZXN0UGFyYW1ldGVycy5lbWJlZFVybCwgcmVxdWVzdFBhcmFtZXRlcnMuZW1iZWRUeXBlcywgcmVxdWVzdFBhcmFtZXRlcnMud2l0aFJlY2FzdHMsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGZlZWQgYmFzZWQgb24gY2hhbm5lbCBJRHNcbiAgICAgICAgICogQHN1bW1hcnkgQnkgY2hhbm5lbCBJRHNcbiAgICAgICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hGZWVkQnlDaGFubmVsSWRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtYnktY2hhbm5lbC1pZHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZlZWRCeUNoYW5uZWxJZHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoRmVlZEJ5Q2hhbm5lbElkcyhyZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWRzLCByZXF1ZXN0UGFyYW1ldGVycy53aXRoUmVjYXN0cywgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy53aXRoUmVwbGllcywgcmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc09ubHksIHJlcXVlc3RQYXJhbWV0ZXJzLmZpZHMsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnNob3VsZE1vZGVyYXRlLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiBwYXJlbnQgVVJMc1xuICAgICAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgVVJMc1xuICAgICAgICAgKiBAcGFyYW0ge0ZlZWRBcGlGZXRjaEZlZWRCeVBhcmVudFVybHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZC1ieS1wYXJlbnQtdXJscylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoRmVlZEJ5UGFyZW50VXJscyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hGZWVkQnlQYXJlbnRVcmxzKHJlcXVlc3RQYXJhbWV0ZXJzLnBhcmVudFVybHMsIHJlcXVlc3RQYXJhbWV0ZXJzLndpdGhSZWNhc3RzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLndpdGhSZXBsaWVzLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBwZXJzb25hbGl6ZWQgRm9yIFlvdSBmZWVkIGZvciBhIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgRm9yIHlvdVxuICAgICAgICAgKiBAcGFyYW0ge0ZlZWRBcGlGZXRjaEZlZWRGb3JZb3VSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZC1mb3IteW91KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGZWVkRm9yWW91KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEZlZWRGb3JZb3UocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnByb3ZpZGVyLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy5wcm92aWRlck1ldGFkYXRhLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBvZiBjYXN0cyB3aXRoIG1pbmkgYXBwcywgcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyXG4gICAgICAgICAqIEBzdW1tYXJ5IENhc3RzIHdpdGggbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoRnJhbWVzT25seUZlZWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZnJhbWVzLW9ubHktZmVlZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoRnJhbWVzT25seUZlZWQocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hGcmFtZXNPbmx5RmVlZChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCAxMCBtb3N0IHBvcHVsYXIgY2FzdHMgZm9yIGEgZ2l2ZW4gdXNlciBGSUQ7IHBvcHVsYXJpdHkgYmFzZWQgb24gcmVwbGllcywgbGlrZXMgYW5kIHJlY2FzdHM7IHNvcnRlZCBieSBtb3N0IHBvcHVsYXIgZmlyc3RcbiAgICAgICAgICogQHN1bW1hcnkgMTAgbW9zdCBwb3B1bGFyIGNhc3RzXG4gICAgICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoUG9wdWxhckNhc3RzQnlVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrQ2FzdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtDYXN0c1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1wb3B1bGFyLWNhc3RzLWJ5LXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFBvcHVsYXJDYXN0c0J5VXNlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hQb3B1bGFyQ2FzdHNCeVVzZXIocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCByZWNlbnQgcmVwbGllcyBhbmQgcmVjYXN0cyBmb3IgYSBnaXZlbiB1c2VyIEZJRDsgc29ydGVkIGJ5IG1vc3QgcmVjZW50IGZpcnN0XG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcGxpZXMgYW5kIHJlY2FzdHNcbiAgICAgICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hSZXBsaWVzQW5kUmVjYXN0c0ZvclVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVwbGllcy1hbmQtcmVjYXN0cy1mb3ItdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbHRlciwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggdHJlbmRpbmcgY2FzdHMgb3Igb24gdGhlIGdsb2JhbCBmZWVkIG9yIGNoYW5uZWxzIGZlZWRzLiA3ZCB0aW1lIHdpbmRvdyBhdmFpbGFibGUgZm9yIGNoYW5uZWwgZmVlZHMgb25seS5cbiAgICAgICAgICogQHN1bW1hcnkgVHJlbmRpbmcgZmVlZHNcbiAgICAgICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hUcmVuZGluZ0ZlZWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdHJlbmRpbmctZmVlZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVHJlbmRpbmdGZWVkKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVHJlbmRpbmdGZWVkKHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudGltZVdpbmRvdywgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkLCByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRVcmwsIHJlcXVlc3RQYXJhbWV0ZXJzLnByb3ZpZGVyLCByZXF1ZXN0UGFyYW1ldGVycy5wcm92aWRlck1ldGFkYXRhLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiB3aG8gYSB1c2VyIGlzIGZvbGxvd2luZ1xuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hVc2VyRm9sbG93aW5nRmVlZFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZy1mZWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyRm9sbG93aW5nRmVlZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyRm9sbG93aW5nRmVlZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMud2l0aFJlY2FzdHMsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZlZWRBcGlGYWN0b3J5ID0gRmVlZEFwaUZhY3Rvcnk7XG4vKipcbiAqIEZlZWRBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRmVlZEFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEZlZWRBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY2FzdHMgZm9yIGEgZ2l2ZW4gdXNlciBGSUQgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLiBBbHNvIGFsbG93cyBmaWx0ZXJpbmcgYnkgcGFyZW50X3VybCBhbmQgY2hhbm5lbFxuICAgICAqIEBzdW1tYXJ5IENocm9ub2xvZ2ljYWxseVxuICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoQ2FzdHNGb3JVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmVlZEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3RzLWZvci11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hDYXN0c0ZvclVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZlZWRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaENhc3RzRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmFwcEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy5pbmNsdWRlUmVwbGllcywgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50VXJsLCByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBjYXN0cyBiYXNlZCBvbiBmaWx0ZXJzLiBFbnN1cmUgc2V0dGluZyB0aGUgY29ycmVjdCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHRoZSBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAqIEBzdW1tYXJ5IEJ5IGZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0ZlZWRBcGlGZXRjaEZlZWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGZWVkQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmVlZClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRmVlZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRmVlZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoRmVlZChyZXF1ZXN0UGFyYW1ldGVycy5mZWVkVHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMuZmlsdGVyVHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5maWRzLCByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRVcmwsIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxJZCwgcmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc09ubHksIHJlcXVlc3RQYXJhbWV0ZXJzLmVtYmVkVXJsLCByZXF1ZXN0UGFyYW1ldGVycy5lbWJlZFR5cGVzLCByZXF1ZXN0UGFyYW1ldGVycy53aXRoUmVjYXN0cywgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggZmVlZCBiYXNlZCBvbiBjaGFubmVsIElEc1xuICAgICAqIEBzdW1tYXJ5IEJ5IGNoYW5uZWwgSURzXG4gICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hGZWVkQnlDaGFubmVsSWRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmVlZEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtYnktY2hhbm5lbC1pZHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEZlZWRCeUNoYW5uZWxJZHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZlZWRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEZlZWRCeUNoYW5uZWxJZHMocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkcywgcmVxdWVzdFBhcmFtZXRlcnMud2l0aFJlY2FzdHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMud2l0aFJlcGxpZXMsIHJlcXVlc3RQYXJhbWV0ZXJzLm1lbWJlcnNPbmx5LCByZXF1ZXN0UGFyYW1ldGVycy5maWRzLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy5zaG91bGRNb2RlcmF0ZSwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGZlZWQgYmFzZWQgb24gcGFyZW50IFVSTHNcbiAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgVVJMc1xuICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoRmVlZEJ5UGFyZW50VXJsc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZlZWRBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mZWVkLWJ5LXBhcmVudC11cmxzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hGZWVkQnlQYXJlbnRVcmxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GZWVkQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hGZWVkQnlQYXJlbnRVcmxzKHJlcXVlc3RQYXJhbWV0ZXJzLnBhcmVudFVybHMsIHJlcXVlc3RQYXJhbWV0ZXJzLndpdGhSZWNhc3RzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLndpdGhSZXBsaWVzLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBwZXJzb25hbGl6ZWQgRm9yIFlvdSBmZWVkIGZvciBhIHVzZXJcbiAgICAgKiBAc3VtbWFyeSBGb3IgeW91XG4gICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hGZWVkRm9yWW91UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmVlZEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtZm9yLXlvdSlcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRmVlZEZvcllvdShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRmVlZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoRmVlZEZvcllvdShyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMucHJvdmlkZXIsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnByb3ZpZGVyTWV0YWRhdGEsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBmZWVkIG9mIGNhc3RzIHdpdGggbWluaSBhcHBzLCByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgKiBAc3VtbWFyeSBDYXN0cyB3aXRoIG1pbmkgYXBwc1xuICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoRnJhbWVzT25seUZlZWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGZWVkQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZnJhbWVzLW9ubHktZmVlZClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRnJhbWVzT25seUZlZWQocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRmVlZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoRnJhbWVzT25seUZlZWQocmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggMTAgbW9zdCBwb3B1bGFyIGNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBwb3B1bGFyaXR5IGJhc2VkIG9uIHJlcGxpZXMsIGxpa2VzIGFuZCByZWNhc3RzOyBzb3J0ZWQgYnkgbW9zdCBwb3B1bGFyIGZpcnN0XG4gICAgICogQHN1bW1hcnkgMTAgbW9zdCBwb3B1bGFyIGNhc3RzXG4gICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hQb3B1bGFyQ2FzdHNCeVVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGZWVkQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa0Nhc3RzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrQ2FzdHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvcHVsYXItY2FzdHMtYnktdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoUG9wdWxhckNhc3RzQnlVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GZWVkQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hQb3B1bGFyQ2FzdHNCeVVzZXIocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCByZWNlbnQgcmVwbGllcyBhbmQgcmVjYXN0cyBmb3IgYSBnaXZlbiB1c2VyIEZJRDsgc29ydGVkIGJ5IG1vc3QgcmVjZW50IGZpcnN0XG4gICAgICogQHN1bW1hcnkgUmVwbGllcyBhbmQgcmVjYXN0c1xuICAgICAqIEBwYXJhbSB7RmVlZEFwaUZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmVlZEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlcGxpZXMtYW5kLXJlY2FzdHMtZm9yLXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRmVlZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuZmlsdGVyLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0cmVuZGluZyBjYXN0cyBvciBvbiB0aGUgZ2xvYmFsIGZlZWQgb3IgY2hhbm5lbHMgZmVlZHMuIDdkIHRpbWUgd2luZG93IGF2YWlsYWJsZSBmb3IgY2hhbm5lbCBmZWVkcyBvbmx5LlxuICAgICAqIEBzdW1tYXJ5IFRyZW5kaW5nIGZlZWRzXG4gICAgICogQHBhcmFtIHtGZWVkQXBpRmV0Y2hUcmVuZGluZ0ZlZWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGZWVkQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdHJlbmRpbmctZmVlZClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVHJlbmRpbmdGZWVkKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZlZWRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFRyZW5kaW5nRmVlZChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnRpbWVXaW5kb3csIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxJZCwgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50VXJsLCByZXF1ZXN0UGFyYW1ldGVycy5wcm92aWRlciwgcmVxdWVzdFBhcmFtZXRlcnMucHJvdmlkZXJNZXRhZGF0YSwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGZlZWQgYmFzZWQgb24gd2hvIGEgdXNlciBpcyBmb2xsb3dpbmdcbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgKiBAcGFyYW0ge0ZlZWRBcGlGZXRjaFVzZXJGb2xsb3dpbmdGZWVkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmVlZEFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93aW5nLWZlZWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFVzZXJGb2xsb3dpbmdGZWVkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GZWVkQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyRm9sbG93aW5nRmVlZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMud2l0aFJlY2FzdHMsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmVlZEFwaSA9IEZlZWRBcGk7XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5GZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlckZpbHRlckVudW0gPSB7XG4gICAgUmVwbGllczogJ3JlcGxpZXMnLFxuICAgIFJlY2FzdHM6ICdyZWNhc3RzJyxcbiAgICBBbGw6ICdhbGwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRmV0Y2hUcmVuZGluZ0ZlZWRUaW1lV2luZG93RW51bSA9IHtcbiAgICBfMWg6ICcxaCcsXG4gICAgXzZoOiAnNmgnLFxuICAgIF8xMmg6ICcxMmgnLFxuICAgIF8yNGg6ICcyNGgnLFxuICAgIF83ZDogJzdkJ1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/feed-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/fname-api.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/fname-api.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FnameApi = exports.FnameApiFactory = exports.FnameApiFp = exports.FnameApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * FnameApi - axios parameter creator\n * @export\n */\nconst FnameApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Check if a given fname is available\n         * @summary Check fname availability\n         * @param {string} fname\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)\n         *\n         */\n        isFnameAvailable: async (fname, options = {}) => {\n            // verify required parameter 'fname' is not null or undefined\n            (0, common_1.assertParamExists)('isFnameAvailable', 'fname', fname);\n            const localVarPath = `/farcaster/fname/availability`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fname !== undefined) {\n                localVarQueryParameter['fname'] = fname;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FnameApiAxiosParamCreator = FnameApiAxiosParamCreator;\n/**\n * FnameApi - functional programming interface\n * @export\n */\nconst FnameApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FnameApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Check if a given fname is available\n         * @summary Check fname availability\n         * @param {string} fname\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)\n         *\n         */\n        async isFnameAvailable(fname, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.isFnameAvailable(fname, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FnameApi.isFnameAvailable']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FnameApiFp = FnameApiFp;\n/**\n * FnameApi - factory interface\n * @export\n */\nconst FnameApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FnameApiFp)(configuration);\n    return {\n        /**\n         * Check if a given fname is available\n         * @summary Check fname availability\n         * @param {FnameApiIsFnameAvailableRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)\n         *\n         */\n        isFnameAvailable(requestParameters, options) {\n            return localVarFp.isFnameAvailable(requestParameters.fname, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FnameApiFactory = FnameApiFactory;\n/**\n * FnameApi - object-oriented interface\n * @export\n * @class FnameApi\n * @extends {BaseAPI}\n */\nclass FnameApi extends base_1.BaseAPI {\n    /**\n     * Check if a given fname is available\n     * @summary Check fname availability\n     * @param {FnameApiIsFnameAvailableRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FnameApi\n     * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)\n     *\n     */\n    isFnameAvailable(requestParameters, options) {\n        return (0, exports.FnameApiFp)(this.configuration).isFnameAvailable(requestParameters.fname, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FnameApi = FnameApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZuYW1lLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDO0FBQ25HLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZuYW1lLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm5hbWVBcGkgPSBleHBvcnRzLkZuYW1lQXBpRmFjdG9yeSA9IGV4cG9ydHMuRm5hbWVBcGlGcCA9IGV4cG9ydHMuRm5hbWVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEZuYW1lQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRm5hbWVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gZm5hbWUgaXMgYXZhaWxhYmxlXG4gICAgICAgICAqIEBzdW1tYXJ5IENoZWNrIGZuYW1lIGF2YWlsYWJpbGl0eVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm5hbWVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Rm5hbWVBdmFpbGFiaWxpdHlSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZuYW1lQXZhaWxhYmlsaXR5UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2lzLWZuYW1lLWF2YWlsYWJsZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGlzRm5hbWVBdmFpbGFibGU6IGFzeW5jIChmbmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmbmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdpc0ZuYW1lQXZhaWxhYmxlJywgJ2ZuYW1lJywgZm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZm5hbWUvYXZhaWxhYmlsaXR5YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmbmFtZSddID0gZm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZuYW1lQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBGbmFtZUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBGbmFtZUFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEZuYW1lQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5GbmFtZUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBnaXZlbiBmbmFtZSBpcyBhdmFpbGFibGVcbiAgICAgICAgICogQHN1bW1hcnkgQ2hlY2sgZm5hbWUgYXZhaWxhYmlsaXR5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmbmFtZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGbmFtZUF2YWlsYWJpbGl0eVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRm5hbWVBdmFpbGFiaWxpdHlSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvaXMtZm5hbWUtYXZhaWxhYmxlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgaXNGbmFtZUF2YWlsYWJsZShmbmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuaXNGbmFtZUF2YWlsYWJsZShmbmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZuYW1lQXBpLmlzRm5hbWVBdmFpbGFibGUnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRm5hbWVBcGlGcCA9IEZuYW1lQXBpRnA7XG4vKipcbiAqIEZuYW1lQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRm5hbWVBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5GbmFtZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBnaXZlbiBmbmFtZSBpcyBhdmFpbGFibGVcbiAgICAgICAgICogQHN1bW1hcnkgQ2hlY2sgZm5hbWUgYXZhaWxhYmlsaXR5XG4gICAgICAgICAqIEBwYXJhbSB7Rm5hbWVBcGlJc0ZuYW1lQXZhaWxhYmxlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGbmFtZUF2YWlsYWJpbGl0eVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRm5hbWVBdmFpbGFiaWxpdHlSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvaXMtZm5hbWUtYXZhaWxhYmxlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaXNGbmFtZUF2YWlsYWJsZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuaXNGbmFtZUF2YWlsYWJsZShyZXF1ZXN0UGFyYW1ldGVycy5mbmFtZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRm5hbWVBcGlGYWN0b3J5ID0gRm5hbWVBcGlGYWN0b3J5O1xuLyoqXG4gKiBGbmFtZUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBGbmFtZUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEZuYW1lQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gZm5hbWUgaXMgYXZhaWxhYmxlXG4gICAgICogQHN1bW1hcnkgQ2hlY2sgZm5hbWUgYXZhaWxhYmlsaXR5XG4gICAgICogQHBhcmFtIHtGbmFtZUFwaUlzRm5hbWVBdmFpbGFibGVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGbmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZuYW1lQXZhaWxhYmlsaXR5UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGbmFtZUF2YWlsYWJpbGl0eVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvaXMtZm5hbWUtYXZhaWxhYmxlKVxuICAgICAqXG4gICAgICovXG4gICAgaXNGbmFtZUF2YWlsYWJsZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRm5hbWVBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5pc0ZuYW1lQXZhaWxhYmxlKHJlcXVlc3RQYXJhbWV0ZXJzLmZuYW1lLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkZuYW1lQXBpID0gRm5hbWVBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/fname-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/follows-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/follows-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FollowsApi = exports.FollowsApiFactory = exports.FollowsApiFp = exports.FollowsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * FollowsApi - axios parameter creator\n * @export\n */\nconst FollowsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a list of suggested users to follow. Used to help users discover new users to follow\n         * @summary Suggest Follows\n         * @param {number} fid FID of the user whose following you want to fetch.\n         * @param {number} [viewerFid] Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)\n         *\n         */\n        fetchFollowSuggestions: async (fid, viewerFid, limit, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFollowSuggestions', 'fid', fid);\n            const localVarPath = `/farcaster/following/suggested`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \\\"X, Y and Z follow this user\\\".\n         * @summary Relevant followers\n         * @param {number} targetFid User who\\&#39;s profile you are looking at\n         * @param {number} viewerFid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)\n         *\n         */\n        fetchRelevantFollowers: async (targetFid, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'targetFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFollowers', 'targetFid', targetFid);\n            // verify required parameter 'viewerFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFollowers', 'viewerFid', viewerFid);\n            const localVarPath = `/farcaster/followers/relevant`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (targetFid !== undefined) {\n                localVarQueryParameter['target_fid'] = targetFid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of followers for a specific FID.\n         * @summary Followers\n         * @param {number} fid User who\\&#39;s profile you are looking at\n         * @param {number} [viewerFid] Providing this will return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FollowSortType} [sortType] Sort type for fetch followers. Default is &#x60;desc_chron&#x60;\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        fetchUserFollowers: async (fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserFollowers', 'fid', fid);\n            const localVarPath = `/farcaster/followers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (sortType !== undefined) {\n                localVarQueryParameter['sort_type'] = sortType;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.\n         * @summary Following\n         * @param {number} fid FID of the user whose following you want to fetch.\n         * @param {number} [viewerFid] Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FollowSortType} [sortType] Optional parameter to sort the users based on different criteria.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        fetchUserFollowing: async (fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserFollowing', 'fid', fid);\n            const localVarPath = `/farcaster/following`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (sortType !== undefined) {\n                localVarQueryParameter['sort_type'] = sortType;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FollowsApiAxiosParamCreator = FollowsApiAxiosParamCreator;\n/**\n * FollowsApi - functional programming interface\n * @export\n */\nconst FollowsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FollowsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a list of suggested users to follow. Used to help users discover new users to follow\n         * @summary Suggest Follows\n         * @param {number} fid FID of the user whose following you want to fetch.\n         * @param {number} [viewerFid] Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)\n         *\n         */\n        async fetchFollowSuggestions(fid, viewerFid, limit, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFollowSuggestions(fid, viewerFid, limit, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FollowsApi.fetchFollowSuggestions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \\\"X, Y and Z follow this user\\\".\n         * @summary Relevant followers\n         * @param {number} targetFid User who\\&#39;s profile you are looking at\n         * @param {number} viewerFid The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)\n         *\n         */\n        async fetchRelevantFollowers(targetFid, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFollowers(targetFid, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FollowsApi.fetchRelevantFollowers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of followers for a specific FID.\n         * @summary Followers\n         * @param {number} fid User who\\&#39;s profile you are looking at\n         * @param {number} [viewerFid] Providing this will return a list of followers that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FollowSortType} [sortType] Sort type for fetch followers. Default is &#x60;desc_chron&#x60;\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        async fetchUserFollowers(fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserFollowers(fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FollowsApi.fetchUserFollowers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.\n         * @summary Following\n         * @param {number} fid FID of the user whose following you want to fetch.\n         * @param {number} [viewerFid] Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {FollowSortType} [sortType] Optional parameter to sort the users based on different criteria.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        async fetchUserFollowing(fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserFollowing(fid, viewerFid, sortType, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FollowsApi.fetchUserFollowing']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FollowsApiFp = FollowsApiFp;\n/**\n * FollowsApi - factory interface\n * @export\n */\nconst FollowsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FollowsApiFp)(configuration);\n    return {\n        /**\n         * Fetch a list of suggested users to follow. Used to help users discover new users to follow\n         * @summary Suggest Follows\n         * @param {FollowsApiFetchFollowSuggestionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)\n         *\n         */\n        fetchFollowSuggestions(requestParameters, options) {\n            return localVarFp.fetchFollowSuggestions(requestParameters.fid, requestParameters.viewerFid, requestParameters.limit, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \\\"X, Y and Z follow this user\\\".\n         * @summary Relevant followers\n         * @param {FollowsApiFetchRelevantFollowersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)\n         *\n         */\n        fetchRelevantFollowers(requestParameters, options) {\n            return localVarFp.fetchRelevantFollowers(requestParameters.targetFid, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of followers for a specific FID.\n         * @summary Followers\n         * @param {FollowsApiFetchUserFollowersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        fetchUserFollowers(requestParameters, options) {\n            return localVarFp.fetchUserFollowers(requestParameters.fid, requestParameters.viewerFid, requestParameters.sortType, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.\n         * @summary Following\n         * @param {FollowsApiFetchUserFollowingRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        fetchUserFollowing(requestParameters, options) {\n            return localVarFp.fetchUserFollowing(requestParameters.fid, requestParameters.viewerFid, requestParameters.sortType, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FollowsApiFactory = FollowsApiFactory;\n/**\n * FollowsApi - object-oriented interface\n * @export\n * @class FollowsApi\n * @extends {BaseAPI}\n */\nclass FollowsApi extends base_1.BaseAPI {\n    /**\n     * Fetch a list of suggested users to follow. Used to help users discover new users to follow\n     * @summary Suggest Follows\n     * @param {FollowsApiFetchFollowSuggestionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FollowsApi\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)\n     *\n     */\n    fetchFollowSuggestions(requestParameters, options) {\n        return (0, exports.FollowsApiFp)(this.configuration).fetchFollowSuggestions(requestParameters.fid, requestParameters.viewerFid, requestParameters.limit, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \\\"X, Y and Z follow this user\\\".\n     * @summary Relevant followers\n     * @param {FollowsApiFetchRelevantFollowersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FollowsApi\n     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)\n     *\n     */\n    fetchRelevantFollowers(requestParameters, options) {\n        return (0, exports.FollowsApiFp)(this.configuration).fetchRelevantFollowers(requestParameters.targetFid, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of followers for a specific FID.\n     * @summary Followers\n     * @param {FollowsApiFetchUserFollowersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FollowsApi\n     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n     *\n     */\n    fetchUserFollowers(requestParameters, options) {\n        return (0, exports.FollowsApiFp)(this.configuration).fetchUserFollowers(requestParameters.fid, requestParameters.viewerFid, requestParameters.sortType, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.\n     * @summary Following\n     * @param {FollowsApiFetchUserFollowingRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FollowsApi\n     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n     *\n     */\n    fetchUserFollowing(requestParameters, options) {\n        return (0, exports.FollowsApiFp)(this.configuration).fetchUserFollowing(requestParameters.fid, requestParameters.viewerFid, requestParameters.sortType, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FollowsApi = FollowsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZvbGxvd3MtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDM0csZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLG9GQUFvRixzQ0FBc0Msb0JBQW9CO0FBQ3pLLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsd0JBQXdCO0FBQ25ELG1CQUFtQixRQUFRLCtJQUErSSxzQ0FBc0Msb0JBQW9CO0FBQ3BPLG1CQUFtQixTQUFT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QSxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZvbGxvd3MtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gb2xsb3dzQXBpID0gZXhwb3J0cy5Gb2xsb3dzQXBpRmFjdG9yeSA9IGV4cG9ydHMuRm9sbG93c0FwaUZwID0gZXhwb3J0cy5Gb2xsb3dzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBGb2xsb3dzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRm9sbG93c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHN1Z2dlc3RlZCB1c2VycyB0byBmb2xsb3cuIFVzZWQgdG8gaGVscCB1c2VycyBkaXNjb3ZlciBuZXcgdXNlcnMgdG8gZm9sbG93XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Z2dlc3QgRm9sbG93c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB0aGUgdXNlciB3aG9zZSBmb2xsb3dpbmcgeW91IHdhbnQgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgdXNlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZm9sbG93LXN1Z2dlc3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGb2xsb3dTdWdnZXN0aW9uczogYXN5bmMgKGZpZCwgdmlld2VyRmlkLCBsaW1pdCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hGb2xsb3dTdWdnZXN0aW9ucycsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZm9sbG93aW5nL3N1Z2dlc3RlZGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcmVsZXZhbnQgZm9sbG93ZXJzIGZvciBhIHNwZWNpZmljIEZJRC4gVGhpcyB1c3VhbGx5IHNob3dzIG9uIGEgcHJvZmlsZSBhcyBcXFwiWCwgWSBhbmQgWiBmb2xsb3cgdGhpcyB1c2VyXFxcIi5cbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgZm9sbG93ZXJzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRGaWQgVXNlciB3aG9cXCYjMzk7cyBwcm9maWxlIHlvdSBhcmUgbG9va2luZyBhdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld2VyRmlkIFRoZSBGSUQgb2YgdGhlIHVzZXIgdG8gY3VzdG9taXplIHRoaXMgcmVzcG9uc2UgZm9yLiBQcm92aWRpbmcgdGhpcyB3aWxsIGFsc28gcmV0dXJuIGEgbGlzdCBvZiBmb2xsb3dlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVsZXZhbnRGb2xsb3dlcnM6IGFzeW5jICh0YXJnZXRGaWQsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRGaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hSZWxldmFudEZvbGxvd2VycycsICd0YXJnZXRGaWQnLCB0YXJnZXRGaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndmlld2VyRmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoUmVsZXZhbnRGb2xsb3dlcnMnLCAndmlld2VyRmlkJywgdmlld2VyRmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZvbGxvd2Vycy9yZWxldmFudGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RhcmdldF9maWQnXSA9IHRhcmdldEZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3dlcnNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBVc2VyIHdob1xcJiMzOTtzIHByb2ZpbGUgeW91IGFyZSBsb29raW5nIGF0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgZm9sbG93ZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93U29ydFR5cGV9IFtzb3J0VHlwZV0gU29ydCB0eXBlIGZvciBmZXRjaCBmb2xsb3dlcnMuIERlZmF1bHQgaXMgJiN4NjA7ZGVzY19jaHJvbiYjeDYwO1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJGb2xsb3dlcnM6IGFzeW5jIChmaWQsIHZpZXdlckZpZCwgc29ydFR5cGUsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlckZvbGxvd2VycycsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZm9sbG93ZXJzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc29ydFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3NvcnRfdHlwZSddID0gc29ydFR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB3aG8gYSBnaXZlbiB1c2VyIGlzIGZvbGxvd2luZy4gQ2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhIHZpZXdlcl9maWQgYW5kIHNvcnRfdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgRm9sbG93aW5nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHdob3NlIGZvbGxvd2luZyB5b3Ugd2FudCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiB1c2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge0ZvbGxvd1NvcnRUeXBlfSBbc29ydFR5cGVdIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzb3J0IHRoZSB1c2VycyBiYXNlZCBvbiBkaWZmZXJlbnQgY3JpdGVyaWEuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckZvbGxvd2luZzogYXN5bmMgKGZpZCwgdmlld2VyRmlkLCBzb3J0VHlwZSwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyRm9sbG93aW5nJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mb2xsb3dpbmdgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc29ydF90eXBlJ10gPSBzb3J0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Gb2xsb3dzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBGb2xsb3dzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEZvbGxvd3NBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBGb2xsb3dzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Gb2xsb3dzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2Ygc3VnZ2VzdGVkIHVzZXJzIHRvIGZvbGxvdy4gVXNlZCB0byBoZWxwIHVzZXJzIGRpc2NvdmVyIG5ldyB1c2VycyB0byBmb2xsb3dcbiAgICAgICAgICogQHN1bW1hcnkgU3VnZ2VzdCBGb2xsb3dzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHdob3NlIGZvbGxvd2luZyB5b3Ugd2FudCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiB1c2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3ctc3VnZ2VzdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEZvbGxvd1N1Z2dlc3Rpb25zKGZpZCwgdmlld2VyRmlkLCBsaW1pdCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGb2xsb3dTdWdnZXN0aW9ucyhmaWQsIHZpZXdlckZpZCwgbGltaXQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGb2xsb3dzQXBpLmZldGNoRm9sbG93U3VnZ2VzdGlvbnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJlbGV2YW50IGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIHByb2ZpbGUgYXMgXFxcIlgsIFkgYW5kIFogZm9sbG93IHRoaXMgdXNlclxcXCIuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlbGV2YW50IGZvbGxvd2Vyc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0RmlkIFVzZXIgd2hvXFwmIzM5O3MgcHJvZmlsZSB5b3UgYXJlIGxvb2tpbmcgYXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdlckZpZCBUaGUgRklEIG9mIHRoZSB1c2VyIHRvIGN1c3RvbWl6ZSB0aGlzIHJlc3BvbnNlIGZvci4gUHJvdmlkaW5nIHRoaXMgd2lsbCBhbHNvIHJldHVybiBhIGxpc3Qgb2YgZm9sbG93ZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWxldmFudEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1yZWxldmFudC1mb2xsb3dlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFJlbGV2YW50Rm9sbG93ZXJzKHRhcmdldEZpZCwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzKHRhcmdldEZpZCwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRm9sbG93c0FwaS5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3dlcnNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBVc2VyIHdob1xcJiMzOTtzIHByb2ZpbGUgeW91IGFyZSBsb29raW5nIGF0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgZm9sbG93ZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93U29ydFR5cGV9IFtzb3J0VHlwZV0gU29ydCB0eXBlIGZvciBmZXRjaCBmb2xsb3dlcnMuIERlZmF1bHQgaXMgJiN4NjA7ZGVzY19jaHJvbiYjeDYwO1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJGb2xsb3dlcnMoZmlkLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJGb2xsb3dlcnMoZmlkLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRm9sbG93c0FwaS5mZXRjaFVzZXJGb2xsb3dlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB3aG8gYSBnaXZlbiB1c2VyIGlzIGZvbGxvd2luZy4gQ2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhIHZpZXdlcl9maWQgYW5kIHNvcnRfdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgRm9sbG93aW5nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHdob3NlIGZvbGxvd2luZyB5b3Ugd2FudCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiB1c2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge0ZvbGxvd1NvcnRUeXBlfSBbc29ydFR5cGVdIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzb3J0IHRoZSB1c2VycyBiYXNlZCBvbiBkaWZmZXJlbnQgY3JpdGVyaWEuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoVXNlckZvbGxvd2luZyhmaWQsIHZpZXdlckZpZCwgc29ydFR5cGUsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlckZvbGxvd2luZyhmaWQsIHZpZXdlckZpZCwgc29ydFR5cGUsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGb2xsb3dzQXBpLmZldGNoVXNlckZvbGxvd2luZyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Gb2xsb3dzQXBpRnAgPSBGb2xsb3dzQXBpRnA7XG4vKipcbiAqIEZvbGxvd3NBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBGb2xsb3dzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuRm9sbG93c0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHN1Z2dlc3RlZCB1c2VycyB0byBmb2xsb3cuIFVzZWQgdG8gaGVscCB1c2VycyBkaXNjb3ZlciBuZXcgdXNlcnMgdG8gZm9sbG93XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Z2dlc3QgRm9sbG93c1xuICAgICAgICAgKiBAcGFyYW0ge0ZvbGxvd3NBcGlGZXRjaEZvbGxvd1N1Z2dlc3Rpb25zUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZm9sbG93LXN1Z2dlc3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGb2xsb3dTdWdnZXN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hGb2xsb3dTdWdnZXN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiByZWxldmFudCBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELiBUaGlzIHVzdWFsbHkgc2hvd3Mgb24gYSBwcm9maWxlIGFzIFxcXCJYLCBZIGFuZCBaIGZvbGxvdyB0aGlzIHVzZXJcXFwiLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWxldmFudCBmb2xsb3dlcnNcbiAgICAgICAgICogQHBhcmFtIHtGb2xsb3dzQXBpRmV0Y2hSZWxldmFudEZvbGxvd2Vyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVsZXZhbnRGb2xsb3dlcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoUmVsZXZhbnRGb2xsb3dlcnMocmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0RmlkLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3dlcnNcbiAgICAgICAgICogQHBhcmFtIHtGb2xsb3dzQXBpRmV0Y2hVc2VyRm9sbG93ZXJzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckZvbGxvd2VycyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyRm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zb3J0VHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB3aG8gYSBnaXZlbiB1c2VyIGlzIGZvbGxvd2luZy4gQ2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhIHZpZXdlcl9maWQgYW5kIHNvcnRfdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgRm9sbG93aW5nXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93c0FwaUZldGNoVXNlckZvbGxvd2luZ1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dpbmcpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJGb2xsb3dpbmcocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVXNlckZvbGxvd2luZyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuc29ydFR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZvbGxvd3NBcGlGYWN0b3J5ID0gRm9sbG93c0FwaUZhY3Rvcnk7XG4vKipcbiAqIEZvbGxvd3NBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRm9sbG93c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEZvbGxvd3NBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIHN1Z2dlc3RlZCB1c2VycyB0byBmb2xsb3cuIFVzZWQgdG8gaGVscCB1c2VycyBkaXNjb3ZlciBuZXcgdXNlcnMgdG8gZm9sbG93XG4gICAgICogQHN1bW1hcnkgU3VnZ2VzdCBGb2xsb3dzXG4gICAgICogQHBhcmFtIHtGb2xsb3dzQXBpRmV0Y2hGb2xsb3dTdWdnZXN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZvbGxvd3NBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZvbGxvdy1zdWdnZXN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRm9sbG93U3VnZ2VzdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZvbGxvd3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEZvbGxvd1N1Z2dlc3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJlbGV2YW50IGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIHByb2ZpbGUgYXMgXFxcIlgsIFkgYW5kIFogZm9sbG93IHRoaXMgdXNlclxcXCIuXG4gICAgICogQHN1bW1hcnkgUmVsZXZhbnQgZm9sbG93ZXJzXG4gICAgICogQHBhcmFtIHtGb2xsb3dzQXBpRmV0Y2hSZWxldmFudEZvbGxvd2Vyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZvbGxvd3NBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWxldmFudEZvbGxvd2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoUmVsZXZhbnRGb2xsb3dlcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZvbGxvd3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZm9sbG93ZXJzIGZvciBhIHNwZWNpZmljIEZJRC5cbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dlcnNcbiAgICAgKiBAcGFyYW0ge0ZvbGxvd3NBcGlGZXRjaFVzZXJGb2xsb3dlcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGb2xsb3dzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93ZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VyRm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Gb2xsb3dzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyRm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zb3J0VHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB3aG8gYSBnaXZlbiB1c2VyIGlzIGZvbGxvd2luZy4gQ2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhIHZpZXdlcl9maWQgYW5kIHNvcnRfdHlwZS5cbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgKiBAcGFyYW0ge0ZvbGxvd3NBcGlGZXRjaFVzZXJGb2xsb3dpbmdSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGb2xsb3dzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93aW5nKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VyRm9sbG93aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Gb2xsb3dzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyRm9sbG93aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zb3J0VHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Gb2xsb3dzQXBpID0gRm9sbG93c0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/follows-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/frame-api.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/frame-api.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchFrameCatalogCategoriesEnum = exports.FrameApi = exports.FrameApiFactory = exports.FrameApiFp = exports.FrameApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * FrameApi - axios parameter creator\n * @export\n */\nconst FrameApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Delete an existing mini app, if it was made by the developer (identified by API key)\n         * @summary Delete mini app\n         * @param {DeleteFrameReqBody} deleteFrameReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)\n         *\n         */\n        deleteNeynarFrame: async (deleteFrameReqBody, options = {}) => {\n            // verify required parameter 'deleteFrameReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteNeynarFrame', 'deleteFrameReqBody', deleteFrameReqBody);\n            const localVarPath = `/farcaster/frame`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteFrameReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * A curated list of featured mini apps\n         * @summary Mini apps catalog\n         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {MiniAppTimeWindow} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results\n         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results.  Includes all if left blank.  Example: &#x60;categories&#x3D;games,social&#x60; OR: &#x60;categories&#x3D;games&amp;categories&#x3D;social&#x60;\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         */\n        fetchFrameCatalog: async (limit, cursor, timeWindow, categories, options = {}) => {\n            const localVarPath = `/farcaster/frame/catalog`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (timeWindow !== undefined) {\n                localVarQueryParameter['time_window'] = timeWindow;\n            }\n            if (categories) {\n                localVarQueryParameter['categories'] = categories.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches the mini app meta tags from the URL\n         * @summary Meta tags from URL\n         * @param {string} url The mini app URL to crawl\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)\n         *\n         */\n        fetchFrameMetaTagsFromUrl: async (url, options = {}) => {\n            // verify required parameter 'url' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFrameMetaTagsFromUrl', 'url', url);\n            const localVarPath = `/farcaster/frame/crawl`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (url !== undefined) {\n                localVarQueryParameter['url'] = url;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of mini apps made by the developer (identified by API key)\n         * @summary List of mini apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)\n         *\n         */\n        fetchNeynarFrames: async (options = {}) => {\n            const localVarPath = `/farcaster/frame/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of notifications tokens related to a mini app\n         * @summary List of mini app notification tokens\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)\n         *\n         */\n        fetchNotificationTokens: async (limit, fids, cursor, options = {}) => {\n            const localVarPath = `/farcaster/frame/notification_tokens`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (fids !== undefined) {\n                localVarQueryParameter['fids'] = fids;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user\n         * @summary Relevant mini apps\n         * @param {number} viewerFid FID of the user to fetch relevant mini apps for\n         * @param {MiniAppTimeWindow} [timeWindow] Time window used to limit statistics used to calculate mini app relevance\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)\n         *\n         */\n        fetchRelevantFrames: async (viewerFid, timeWindow, options = {}) => {\n            // verify required parameter 'viewerFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFrames', 'viewerFid', viewerFid);\n            const localVarPath = `/farcaster/frame/relevant`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (timeWindow !== undefined) {\n                localVarQueryParameter['time_window'] = timeWindow;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.\n         * @summary Analytics for the mini app\n         * @param {string} frameUrl\n         * @param {ValidateFrameAnalyticsType} analyticsType\n         * @param {string} start\n         * @param {string} stop\n         * @param {ValidateFrameAggregateWindow} [aggregateWindow] Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)\n         *\n         */\n        fetchValidateFrameAnalytics: async (frameUrl, analyticsType, start, stop, aggregateWindow, options = {}) => {\n            // verify required parameter 'frameUrl' is not null or undefined\n            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'frameUrl', frameUrl);\n            // verify required parameter 'analyticsType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'analyticsType', analyticsType);\n            // verify required parameter 'start' is not null or undefined\n            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'start', start);\n            // verify required parameter 'stop' is not null or undefined\n            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'stop', stop);\n            const localVarPath = `/farcaster/frame/validate/analytics`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (frameUrl !== undefined) {\n                localVarQueryParameter['frame_url'] = frameUrl;\n            }\n            if (analyticsType !== undefined) {\n                localVarQueryParameter['analytics_type'] = analyticsType;\n            }\n            if (start !== undefined) {\n                localVarQueryParameter['start'] = (start instanceof Date) ?\n                    start.toISOString() :\n                    start;\n            }\n            if (stop !== undefined) {\n                localVarQueryParameter['stop'] = (stop instanceof Date) ?\n                    stop.toISOString() :\n                    stop;\n            }\n            if (aggregateWindow !== undefined) {\n                localVarQueryParameter['aggregate_window'] = aggregateWindow;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of all the mini apps validated by a user\n         * @summary All mini apps validated by user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)\n         *\n         */\n        fetchValidateFrameList: async (options = {}) => {\n            const localVarPath = `/farcaster/frame/validate/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Retrieve notification delivery and opened stats for notification campaigns\n         * @summary Get notification campaign stats\n         * @param {string} [campaignId] An ID of a specific notification campaign to query\n         * @param {number} [limit] The number of results to return  (Default: 100,\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object\n         *\n         */\n        getNotificationCampaignStats: async (campaignId, limit, cursor, options = {}) => {\n            const localVarPath = `/farcaster/frame/notifications`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (campaignId !== undefined) {\n                localVarQueryParameter['campaign_id'] = campaignId;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Retrieves details about a transaction pay mini app by ID\n         * @summary Get transaction pay mini app\n         * @param {string} id ID of the transaction mini app to retrieve\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        getTransactionPayFrame: async (id, options = {}) => {\n            // verify required parameter 'id' is not null or undefined\n            (0, common_1.assertParamExists)('getTransactionPayFrame', 'id', id);\n            const localVarPath = `/farcaster/frame/transaction/pay`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (id !== undefined) {\n                localVarQueryParameter['id'] = id;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a mini app either by UUID or Neynar URL\n         * @summary Mini app by UUID or URL\n         * @param {FrameType} type\n         * @param {string} [uuid] UUID of the mini app to fetch\n         * @param {string} [url] URL of the Neynar mini app to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)\n         *\n         */\n        lookupNeynarFrame: async (type, uuid, url, options = {}) => {\n            // verify required parameter 'type' is not null or undefined\n            (0, common_1.assertParamExists)('lookupNeynarFrame', 'type', type);\n            const localVarPath = `/farcaster/frame`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (uuid !== undefined) {\n                localVarQueryParameter['uuid'] = uuid;\n            }\n            if (url !== undefined) {\n                localVarQueryParameter['url'] = url;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Post mini app actions, cast actions or cast composer actions to the server  \\\\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.\n         * @summary Post a mini app action, cast action or a cast composer action\n         * @param {FrameActionReqBody} frameActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)\n         *\n         */\n        postFrameAction: async (frameActionReqBody, options = {}) => {\n            // verify required parameter 'frameActionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('postFrameAction', 'frameActionReqBody', frameActionReqBody);\n            const localVarPath = `/farcaster/frame/action`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(frameActionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.\n         * @summary Signature packet\n         * @param {FrameDeveloperManagedActionReqBody} frameDeveloperManagedActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)\n         *\n         */\n        postFrameActionDeveloperManaged: async (frameDeveloperManagedActionReqBody, options = {}) => {\n            // verify required parameter 'frameDeveloperManagedActionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('postFrameActionDeveloperManaged', 'frameDeveloperManagedActionReqBody', frameDeveloperManagedActionReqBody);\n            const localVarPath = `/farcaster/frame/developer_managed/action`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(frameDeveloperManagedActionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Send notifications to interactors of a mini app\n         * @summary Send notifications\n         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)\n         *\n         */\n        publishFrameNotifications: async (sendFrameNotificationsReqBody, options = {}) => {\n            // verify required parameter 'sendFrameNotificationsReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishFrameNotifications', 'sendFrameNotificationsReqBody', sendFrameNotificationsReqBody);\n            const localVarPath = `/farcaster/frame/notifications`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sendFrameNotificationsReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new mini app with a list of pages.\n         * @summary Create mini app\n         * @param {NeynarFrameCreationReqBody} neynarFrameCreationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)\n         *\n         */\n        publishNeynarFrame: async (neynarFrameCreationReqBody, options = {}) => {\n            // verify required parameter 'neynarFrameCreationReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishNeynarFrame', 'neynarFrameCreationReqBody', neynarFrameCreationReqBody);\n            const localVarPath = `/farcaster/frame`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(neynarFrameCreationReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Search for mini apps based on a query string\n         * @summary Search mini apps\n         * @param {string} q Query string to search for mini apps\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)\n         *\n         */\n        searchFrames: async (q, limit, cursor, options = {}) => {\n            // verify required parameter 'q' is not null or undefined\n            (0, common_1.assertParamExists)('searchFrames', 'q', q);\n            const localVarPath = `/farcaster/frame/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (q !== undefined) {\n                localVarQueryParameter['q'] = q;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)\n         * @summary Update mini app\n         * @param {NeynarFrameUpdateReqBody} neynarFrameUpdateReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)\n         *\n         */\n        updateNeynarFrame: async (neynarFrameUpdateReqBody, options = {}) => {\n            // verify required parameter 'neynarFrameUpdateReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('updateNeynarFrame', 'neynarFrameUpdateReqBody', neynarFrameUpdateReqBody);\n            const localVarPath = `/farcaster/frame`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(neynarFrameUpdateReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Validates a mini app against by an interacting user against a Farcaster Hub \\\\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)\n         * @summary Validate mini app action\n         * @param {ValidateFrameActionReqBody} validateFrameActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)\n         *\n         */\n        validateFrameAction: async (validateFrameActionReqBody, options = {}) => {\n            // verify required parameter 'validateFrameActionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('validateFrameAction', 'validateFrameActionReqBody', validateFrameActionReqBody);\n            const localVarPath = `/farcaster/frame/validate`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validateFrameActionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FrameApiAxiosParamCreator = FrameApiAxiosParamCreator;\n/**\n * FrameApi - functional programming interface\n * @export\n */\nconst FrameApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FrameApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Delete an existing mini app, if it was made by the developer (identified by API key)\n         * @summary Delete mini app\n         * @param {DeleteFrameReqBody} deleteFrameReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)\n         *\n         */\n        async deleteNeynarFrame(deleteFrameReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNeynarFrame(deleteFrameReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.deleteNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * A curated list of featured mini apps\n         * @summary Mini apps catalog\n         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {MiniAppTimeWindow} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results\n         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results.  Includes all if left blank.  Example: &#x60;categories&#x3D;games,social&#x60; OR: &#x60;categories&#x3D;games&amp;categories&#x3D;social&#x60;\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         */\n        async fetchFrameCatalog(limit, cursor, timeWindow, categories, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameCatalog(limit, cursor, timeWindow, categories, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchFrameCatalog']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches the mini app meta tags from the URL\n         * @summary Meta tags from URL\n         * @param {string} url The mini app URL to crawl\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)\n         *\n         */\n        async fetchFrameMetaTagsFromUrl(url, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameMetaTagsFromUrl(url, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchFrameMetaTagsFromUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of mini apps made by the developer (identified by API key)\n         * @summary List of mini apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)\n         *\n         */\n        async fetchNeynarFrames(options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNeynarFrames(options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchNeynarFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of notifications tokens related to a mini app\n         * @summary List of mini app notification tokens\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)\n         *\n         */\n        async fetchNotificationTokens(limit, fids, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNotificationTokens(limit, fids, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchNotificationTokens']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user\n         * @summary Relevant mini apps\n         * @param {number} viewerFid FID of the user to fetch relevant mini apps for\n         * @param {MiniAppTimeWindow} [timeWindow] Time window used to limit statistics used to calculate mini app relevance\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)\n         *\n         */\n        async fetchRelevantFrames(viewerFid, timeWindow, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFrames(viewerFid, timeWindow, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchRelevantFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.\n         * @summary Analytics for the mini app\n         * @param {string} frameUrl\n         * @param {ValidateFrameAnalyticsType} analyticsType\n         * @param {string} start\n         * @param {string} stop\n         * @param {ValidateFrameAggregateWindow} [aggregateWindow] Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)\n         *\n         */\n        async fetchValidateFrameAnalytics(frameUrl, analyticsType, start, stop, aggregateWindow, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchValidateFrameAnalytics(frameUrl, analyticsType, start, stop, aggregateWindow, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchValidateFrameAnalytics']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of all the mini apps validated by a user\n         * @summary All mini apps validated by user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)\n         *\n         */\n        async fetchValidateFrameList(options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchValidateFrameList(options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchValidateFrameList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Retrieve notification delivery and opened stats for notification campaigns\n         * @summary Get notification campaign stats\n         * @param {string} [campaignId] An ID of a specific notification campaign to query\n         * @param {number} [limit] The number of results to return  (Default: 100,\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object\n         *\n         */\n        async getNotificationCampaignStats(campaignId, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationCampaignStats(campaignId, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getNotificationCampaignStats']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Retrieves details about a transaction pay mini app by ID\n         * @summary Get transaction pay mini app\n         * @param {string} id ID of the transaction mini app to retrieve\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        async getTransactionPayFrame(id, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionPayFrame(id, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getTransactionPayFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a mini app either by UUID or Neynar URL\n         * @summary Mini app by UUID or URL\n         * @param {FrameType} type\n         * @param {string} [uuid] UUID of the mini app to fetch\n         * @param {string} [url] URL of the Neynar mini app to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)\n         *\n         */\n        async lookupNeynarFrame(type, uuid, url, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupNeynarFrame(type, uuid, url, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.lookupNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Post mini app actions, cast actions or cast composer actions to the server  \\\\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.\n         * @summary Post a mini app action, cast action or a cast composer action\n         * @param {FrameActionReqBody} frameActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)\n         *\n         */\n        async postFrameAction(frameActionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.postFrameAction(frameActionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.postFrameAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.\n         * @summary Signature packet\n         * @param {FrameDeveloperManagedActionReqBody} frameDeveloperManagedActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)\n         *\n         */\n        async postFrameActionDeveloperManaged(frameDeveloperManagedActionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.postFrameActionDeveloperManaged(frameDeveloperManagedActionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.postFrameActionDeveloperManaged']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Send notifications to interactors of a mini app\n         * @summary Send notifications\n         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)\n         *\n         */\n        async publishFrameNotifications(sendFrameNotificationsReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFrameNotifications(sendFrameNotificationsReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.publishFrameNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new mini app with a list of pages.\n         * @summary Create mini app\n         * @param {NeynarFrameCreationReqBody} neynarFrameCreationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)\n         *\n         */\n        async publishNeynarFrame(neynarFrameCreationReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishNeynarFrame(neynarFrameCreationReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.publishNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Search for mini apps based on a query string\n         * @summary Search mini apps\n         * @param {string} q Query string to search for mini apps\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)\n         *\n         */\n        async searchFrames(q, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFrames(q, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.searchFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)\n         * @summary Update mini app\n         * @param {NeynarFrameUpdateReqBody} neynarFrameUpdateReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)\n         *\n         */\n        async updateNeynarFrame(neynarFrameUpdateReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNeynarFrame(neynarFrameUpdateReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.updateNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Validates a mini app against by an interacting user against a Farcaster Hub \\\\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)\n         * @summary Validate mini app action\n         * @param {ValidateFrameActionReqBody} validateFrameActionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)\n         *\n         */\n        async validateFrameAction(validateFrameActionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.validateFrameAction(validateFrameActionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.validateFrameAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FrameApiFp = FrameApiFp;\n/**\n * FrameApi - factory interface\n * @export\n */\nconst FrameApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FrameApiFp)(configuration);\n    return {\n        /**\n         * Delete an existing mini app, if it was made by the developer (identified by API key)\n         * @summary Delete mini app\n         * @param {FrameApiDeleteNeynarFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)\n         *\n         */\n        deleteNeynarFrame(requestParameters, options) {\n            return localVarFp.deleteNeynarFrame(requestParameters.deleteFrameReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * A curated list of featured mini apps\n         * @summary Mini apps catalog\n         * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         */\n        fetchFrameCatalog(requestParameters = {}, options) {\n            return localVarFp.fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches the mini app meta tags from the URL\n         * @summary Meta tags from URL\n         * @param {FrameApiFetchFrameMetaTagsFromUrlRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)\n         *\n         */\n        fetchFrameMetaTagsFromUrl(requestParameters, options) {\n            return localVarFp.fetchFrameMetaTagsFromUrl(requestParameters.url, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of mini apps made by the developer (identified by API key)\n         * @summary List of mini apps\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)\n         *\n         */\n        fetchNeynarFrames(options) {\n            return localVarFp.fetchNeynarFrames(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of notifications tokens related to a mini app\n         * @summary List of mini app notification tokens\n         * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)\n         *\n         */\n        fetchNotificationTokens(requestParameters = {}, options) {\n            return localVarFp.fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user\n         * @summary Relevant mini apps\n         * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)\n         *\n         */\n        fetchRelevantFrames(requestParameters, options) {\n            return localVarFp.fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.\n         * @summary Analytics for the mini app\n         * @param {FrameApiFetchValidateFrameAnalyticsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)\n         *\n         */\n        fetchValidateFrameAnalytics(requestParameters, options) {\n            return localVarFp.fetchValidateFrameAnalytics(requestParameters.frameUrl, requestParameters.analyticsType, requestParameters.start, requestParameters.stop, requestParameters.aggregateWindow, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of all the mini apps validated by a user\n         * @summary All mini apps validated by user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)\n         *\n         */\n        fetchValidateFrameList(options) {\n            return localVarFp.fetchValidateFrameList(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve notification delivery and opened stats for notification campaigns\n         * @summary Get notification campaign stats\n         * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object\n         *\n         */\n        getNotificationCampaignStats(requestParameters = {}, options) {\n            return localVarFp.getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieves details about a transaction pay mini app by ID\n         * @summary Get transaction pay mini app\n         * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n         *\n         */\n        getTransactionPayFrame(requestParameters, options) {\n            return localVarFp.getTransactionPayFrame(requestParameters.id, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a mini app either by UUID or Neynar URL\n         * @summary Mini app by UUID or URL\n         * @param {FrameApiLookupNeynarFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)\n         *\n         */\n        lookupNeynarFrame(requestParameters, options) {\n            return localVarFp.lookupNeynarFrame(requestParameters.type, requestParameters.uuid, requestParameters.url, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Post mini app actions, cast actions or cast composer actions to the server  \\\\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.\n         * @summary Post a mini app action, cast action or a cast composer action\n         * @param {FrameApiPostFrameActionRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)\n         *\n         */\n        postFrameAction(requestParameters, options) {\n            return localVarFp.postFrameAction(requestParameters.frameActionReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.\n         * @summary Signature packet\n         * @param {FrameApiPostFrameActionDeveloperManagedRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)\n         *\n         */\n        postFrameActionDeveloperManaged(requestParameters, options) {\n            return localVarFp.postFrameActionDeveloperManaged(requestParameters.frameDeveloperManagedActionReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Send notifications to interactors of a mini app\n         * @summary Send notifications\n         * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)\n         *\n         */\n        publishFrameNotifications(requestParameters, options) {\n            return localVarFp.publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new mini app with a list of pages.\n         * @summary Create mini app\n         * @param {FrameApiPublishNeynarFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)\n         *\n         */\n        publishNeynarFrame(requestParameters, options) {\n            return localVarFp.publishNeynarFrame(requestParameters.neynarFrameCreationReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Search for mini apps based on a query string\n         * @summary Search mini apps\n         * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)\n         *\n         */\n        searchFrames(requestParameters, options) {\n            return localVarFp.searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)\n         * @summary Update mini app\n         * @param {FrameApiUpdateNeynarFrameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)\n         *\n         */\n        updateNeynarFrame(requestParameters, options) {\n            return localVarFp.updateNeynarFrame(requestParameters.neynarFrameUpdateReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Validates a mini app against by an interacting user against a Farcaster Hub \\\\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)\n         * @summary Validate mini app action\n         * @param {FrameApiValidateFrameActionRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)\n         *\n         */\n        validateFrameAction(requestParameters, options) {\n            return localVarFp.validateFrameAction(requestParameters.validateFrameActionReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FrameApiFactory = FrameApiFactory;\n/**\n * FrameApi - object-oriented interface\n * @export\n * @class FrameApi\n * @extends {BaseAPI}\n */\nclass FrameApi extends base_1.BaseAPI {\n    /**\n     * Delete an existing mini app, if it was made by the developer (identified by API key)\n     * @summary Delete mini app\n     * @param {FrameApiDeleteNeynarFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)\n     *\n     */\n    deleteNeynarFrame(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).deleteNeynarFrame(requestParameters.deleteFrameReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * A curated list of featured mini apps\n     * @summary Mini apps catalog\n     * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n     *\n     */\n    fetchFrameCatalog(requestParameters = {}, options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches the mini app meta tags from the URL\n     * @summary Meta tags from URL\n     * @param {FrameApiFetchFrameMetaTagsFromUrlRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)\n     *\n     */\n    fetchFrameMetaTagsFromUrl(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchFrameMetaTagsFromUrl(requestParameters.url, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of mini apps made by the developer (identified by API key)\n     * @summary List of mini apps\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)\n     *\n     */\n    fetchNeynarFrames(options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchNeynarFrames(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of notifications tokens related to a mini app\n     * @summary List of mini app notification tokens\n     * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)\n     *\n     */\n    fetchNotificationTokens(requestParameters = {}, options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user\n     * @summary Relevant mini apps\n     * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)\n     *\n     */\n    fetchRelevantFrames(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.\n     * @summary Analytics for the mini app\n     * @param {FrameApiFetchValidateFrameAnalyticsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)\n     *\n     */\n    fetchValidateFrameAnalytics(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchValidateFrameAnalytics(requestParameters.frameUrl, requestParameters.analyticsType, requestParameters.start, requestParameters.stop, requestParameters.aggregateWindow, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of all the mini apps validated by a user\n     * @summary All mini apps validated by user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)\n     *\n     */\n    fetchValidateFrameList(options) {\n        return (0, exports.FrameApiFp)(this.configuration).fetchValidateFrameList(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Retrieve notification delivery and opened stats for notification campaigns\n     * @summary Get notification campaign stats\n     * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object\n     *\n     */\n    getNotificationCampaignStats(requestParameters = {}, options) {\n        return (0, exports.FrameApiFp)(this.configuration).getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Retrieves details about a transaction pay mini app by ID\n     * @summary Get transaction pay mini app\n     * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object\n     *\n     */\n    getTransactionPayFrame(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).getTransactionPayFrame(requestParameters.id, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a mini app either by UUID or Neynar URL\n     * @summary Mini app by UUID or URL\n     * @param {FrameApiLookupNeynarFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)\n     *\n     */\n    lookupNeynarFrame(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).lookupNeynarFrame(requestParameters.type, requestParameters.uuid, requestParameters.url, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Post mini app actions, cast actions or cast composer actions to the server  \\\\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.\n     * @summary Post a mini app action, cast action or a cast composer action\n     * @param {FrameApiPostFrameActionRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)\n     *\n     */\n    postFrameAction(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).postFrameAction(requestParameters.frameActionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.\n     * @summary Signature packet\n     * @param {FrameApiPostFrameActionDeveloperManagedRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)\n     *\n     */\n    postFrameActionDeveloperManaged(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).postFrameActionDeveloperManaged(requestParameters.frameDeveloperManagedActionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Send notifications to interactors of a mini app\n     * @summary Send notifications\n     * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)\n     *\n     */\n    publishFrameNotifications(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new mini app with a list of pages.\n     * @summary Create mini app\n     * @param {FrameApiPublishNeynarFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)\n     *\n     */\n    publishNeynarFrame(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).publishNeynarFrame(requestParameters.neynarFrameCreationReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Search for mini apps based on a query string\n     * @summary Search mini apps\n     * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)\n     *\n     */\n    searchFrames(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)\n     * @summary Update mini app\n     * @param {FrameApiUpdateNeynarFrameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)\n     *\n     */\n    updateNeynarFrame(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).updateNeynarFrame(requestParameters.neynarFrameUpdateReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Validates a mini app against by an interacting user against a Farcaster Hub \\\\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)\n     * @summary Validate mini app action\n     * @param {FrameApiValidateFrameActionRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FrameApi\n     * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)\n     *\n     */\n    validateFrameAction(requestParameters, options) {\n        return (0, exports.FrameApiFp)(this.configuration).validateFrameAction(requestParameters.validateFrameActionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FrameApi = FrameApi;\n/**\n * @export\n */\nexports.FetchFrameCatalogCategoriesEnum = {\n    Games: 'games',\n    Social: 'social',\n    Finance: 'finance',\n    Utility: 'utility',\n    Productivity: 'productivity',\n    HealthFitness: 'health-fitness',\n    NewsMedia: 'news-media',\n    Music: 'music',\n    Shopping: 'shopping',\n    Education: 'education',\n    DeveloperTools: 'developer-tools',\n    Entertainment: 'entertainment',\n    ArtCreativity: 'art-creativity'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZyYW1lLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDO0FBQzdJLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQix3Q0FBd0Msd0hBQXdILGdCQUFnQixtQkFBbUIsVUFBVSxnQkFBZ0IsVUFBVSxnQkFBZ0I7QUFDMVEsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEseUpBQXlKO0FBQ3BMLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsa0NBQWtDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDhCQUE4QixxQ0FBcUMsb0JBQW9CO0FBQzFHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsa0RBQWtEO0FBQ3ZFO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG1CQUFtQjtBQUN0QyxtQkFBbUIsd0NBQXdDLHdIQUF3SCxnQkFBZ0IsbUJBQW1CLFVBQVUsZ0JBQWdCLFVBQVUsZ0JBQWdCO0FBQzFRLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEseUpBQXlKO0FBQ3BMLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsa0NBQWtDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsOEJBQThCLHFDQUFxQyxvQkFBb0I7QUFDMUcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixrREFBa0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0QsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixrQ0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixvQ0FBb0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEUsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixrREFBa0Q7QUFDdkU7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZ0Q7QUFDbkUsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0QsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHlDQUF5QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQTRDO0FBQzNELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIseUNBQXlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9ELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBMEM7QUFDekQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQix5Q0FBeUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHNDQUFzQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2ZyYW1lLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmV0Y2hGcmFtZUNhdGFsb2dDYXRlZ29yaWVzRW51bSA9IGV4cG9ydHMuRnJhbWVBcGkgPSBleHBvcnRzLkZyYW1lQXBpRmFjdG9yeSA9IGV4cG9ydHMuRnJhbWVBcGlGcCA9IGV4cG9ydHMuRnJhbWVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEZyYW1lQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnJhbWVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBtaW5pIGFwcCwgaWYgaXQgd2FzIG1hZGUgYnkgdGhlIGRldmVsb3BlciAoaWRlbnRpZmllZCBieSBBUEkga2V5KVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgbWluaSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtEZWxldGVGcmFtZVJlcUJvZHl9IGRlbGV0ZUZyYW1lUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVGcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRGVsZXRlRnJhbWVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLW5leW5hci1mcmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZU5leW5hckZyYW1lOiBhc3luYyAoZGVsZXRlRnJhbWVSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RlbGV0ZUZyYW1lUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZWxldGVOZXluYXJGcmFtZScsICdkZWxldGVGcmFtZVJlcUJvZHknLCBkZWxldGVGcmFtZVJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdERUxFVEUnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGRlbGV0ZUZyYW1lUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXJhdGVkIGxpc3Qgb2YgZmVhdHVyZWQgbWluaSBhcHBzXG4gICAgICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwcyBjYXRhbG9nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMTAwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge01pbmlBcHBUaW1lV2luZG93fSBbdGltZVdpbmRvd10gVGltZSB3aW5kb3cgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGNoYW5nZSBpbiB0cmVuZGluZyBzY29yZSBmb3IgZWFjaCBtaW5pIGFwcCwgdXNlZCB0byBzb3J0IG1pbmkgYXBwIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxGZXRjaEZyYW1lQ2F0YWxvZ0NhdGVnb3JpZXNFbnVtPn0gW2NhdGVnb3JpZXNdIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGNhdGVnb3JpZXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0cy4gIEluY2x1ZGVzIGFsbCBpZiBsZWZ0IGJsYW5rLiAgRXhhbXBsZTogJiN4NjA7Y2F0ZWdvcmllcyYjeDNEO2dhbWVzLHNvY2lhbCYjeDYwOyBPUjogJiN4NjA7Y2F0ZWdvcmllcyYjeDNEO2dhbWVzJmFtcDtjYXRlZ29yaWVzJiN4M0Q7c29jaWFsJiN4NjA7XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lQ2F0YWxvZ1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVDYXRhbG9nUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGcmFtZUNhdGFsb2c6IGFzeW5jIChsaW1pdCwgY3Vyc29yLCB0aW1lV2luZG93LCBjYXRlZ29yaWVzLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lL2NhdGFsb2dgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVXaW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RpbWVfd2luZG93J10gPSB0aW1lV2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjYXRlZ29yaWVzJ10gPSBjYXRlZ29yaWVzLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyB0aGUgbWluaSBhcHAgbWV0YSB0YWdzIGZyb20gdGhlIFVSTFxuICAgICAgICAgKiBAc3VtbWFyeSBNZXRhIHRhZ3MgZnJvbSBVUkxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgbWluaSBhcHAgVVJMIHRvIGNyYXdsXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZnJhbWUtbWV0YS10YWdzLWZyb20tdXJsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybDogYXN5bmMgKHVybCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd1cmwnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybCcsICd1cmwnLCB1cmwpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWUvY3Jhd2xgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd1cmwnXSA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBtaW5pIGFwcHMgbWFkZSBieSB0aGUgZGV2ZWxvcGVyIChpZGVudGlmaWVkIGJ5IEFQSSBrZXkpXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE5leW5hckZyYW1lPj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFycmF5PE5leW5hckZyYW1lPmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbmV5bmFyLWZyYW1lcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoTmV5bmFyRnJhbWVzOiBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mcmFtZS9saXN0YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyB0b2tlbnMgcmVsYXRlZCB0byBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHAgbm90aWZpY2F0aW9uIHRva2Vuc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlkc10gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRklEcywgdXAgdG8gMTAwIGF0IGEgdGltZS4gSWYgeW91IHBhc3MgaW4gRklEcywgeW91IHdpbGwgZ2V0IGJhY2sgdGhlIG5vdGlmaWNhdGlvbiB0b2tlbnMgZm9yIHRob3NlIEZJRHMuIElmIHlvdSBkb25cXCYjMzk7dCBwYXNzIGluIEZJRHMsIHlvdSB3aWxsIGdldCBiYWNrIGFsbCB0aGUgbm90aWZpY2F0aW9uIHRva2VucyBmb3IgdGhlIG1pbmkgYXBwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVOb3RpZmljYXRpb25Ub2tlbnM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZU5vdGlmaWNhdGlvblRva2Vuc2Agb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbm90aWZpY2F0aW9uLXRva2VucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoTm90aWZpY2F0aW9uVG9rZW5zOiBhc3luYyAobGltaXQsIGZpZHMsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mcmFtZS9ub3RpZmljYXRpb25fdG9rZW5zYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkcyddID0gZmlkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIG1pbmkgYXBwcyByZWxldmFudCB0byB0aGUgdXNlciBiYXNlZCBvbiBjYXN0cyBieSB1c2VycyB3aXRoIHN0cm9uZyBhZmZpbml0eSBzY29yZSBmb3IgdGhlIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3ZXJGaWQgRklEIG9mIHRoZSB1c2VyIHRvIGZldGNoIHJlbGV2YW50IG1pbmkgYXBwcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtNaW5pQXBwVGltZVdpbmRvd30gW3RpbWVXaW5kb3ddIFRpbWUgd2luZG93IHVzZWQgdG8gbGltaXQgc3RhdGlzdGljcyB1c2VkIHRvIGNhbGN1bGF0ZSBtaW5pIGFwcCByZWxldmFuY2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZWxldmFudEZyYW1lczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hSZWxldmFudEZyYW1lczIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mcmFtZS1yZWxldmFudClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVsZXZhbnRGcmFtZXM6IGFzeW5jICh2aWV3ZXJGaWQsIHRpbWVXaW5kb3csIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndmlld2VyRmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoUmVsZXZhbnRGcmFtZXMnLCAndmlld2VyRmlkJywgdmlld2VyRmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lL3JlbGV2YW50YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVXaW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RpbWVfd2luZG93J10gPSB0aW1lV2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYW5hbHl0aWNzIGZvciB0b3RhbC1pbnRlcmFjdG9ycywgaW50ZXJhY3RvcnMsIG50ZXJhY3Rpb25zLXBlci1jYXN0IGFuZCBpbnB1dC10ZXh0LlxuICAgICAgICAgKiBAc3VtbWFyeSBBbmFseXRpY3MgZm9yIHRoZSBtaW5pIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhbWVVcmxcbiAgICAgICAgICogQHBhcmFtIHtWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzVHlwZX0gYW5hbHl0aWNzVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3BcbiAgICAgICAgICogQHBhcmFtIHtWYWxpZGF0ZUZyYW1lQWdncmVnYXRlV2luZG93fSBbYWdncmVnYXRlV2luZG93XSBSZXF1aXJlZCBmb3IgJiN4NjA7YW5hbHl0aWNzX3R5cGUmI3gzRDtpbnRlcmFjdGlvbnMtcGVyLWNhc3QmI3g2MDtcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVWYWxpZGF0ZUFuYWx5dGljc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVWYWxpZGF0ZUFuYWx5dGljc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12YWxpZGF0ZS1mcmFtZS1hbmFseXRpY3MpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3M6IGFzeW5jIChmcmFtZVVybCwgYW5hbHl0aWNzVHlwZSwgc3RhcnQsIHN0b3AsIGFnZ3JlZ2F0ZVdpbmRvdywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZVVybCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MnLCAnZnJhbWVVcmwnLCBmcmFtZVVybCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhbmFseXRpY3NUeXBlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVmFsaWRhdGVGcmFtZUFuYWx5dGljcycsICdhbmFseXRpY3NUeXBlJywgYW5hbHl0aWNzVHlwZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFydCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MnLCAnc3RhcnQnLCBzdGFydCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzdG9wJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVmFsaWRhdGVGcmFtZUFuYWx5dGljcycsICdzdG9wJywgc3RvcCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mcmFtZS92YWxpZGF0ZS9hbmFseXRpY3NgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZnJhbWVVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZyYW1lX3VybCddID0gZnJhbWVVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW5hbHl0aWNzVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYW5hbHl0aWNzX3R5cGUnXSA9IGFuYWx5dGljc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N0YXJ0J10gPSAoc3RhcnQgaW5zdGFuY2VvZiBEYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LnRvSVNPU3RyaW5nKCkgOlxuICAgICAgICAgICAgICAgICAgICBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzdG9wJ10gPSAoc3RvcCBpbnN0YW5jZW9mIERhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgc3RvcC50b0lTT1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgc3RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVXaW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2FnZ3JlZ2F0ZV93aW5kb3cnXSA9IGFnZ3JlZ2F0ZVdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIG1pbmkgYXBwcyB2YWxpZGF0ZWQgYnkgYSB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEFsbCBtaW5pIGFwcHMgdmFsaWRhdGVkIGJ5IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVWYWxpZGF0ZUxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lVmFsaWRhdGVMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXZhbGlkYXRlLWZyYW1lLWxpc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFZhbGlkYXRlRnJhbWVMaXN0OiBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mcmFtZS92YWxpZGF0ZS9saXN0YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgbm90aWZpY2F0aW9uIGRlbGl2ZXJ5IGFuZCBvcGVuZWQgc3RhdHMgZm9yIG5vdGlmaWNhdGlvbiBjYW1wYWlnbnNcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IG5vdGlmaWNhdGlvbiBjYW1wYWlnbiBzdGF0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NhbXBhaWduSWRdIEFuIElEIG9mIGEgc3BlY2lmaWMgbm90aWZpY2F0aW9uIGNhbXBhaWduIHRvIHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4gIChEZWZhdWx0OiAxMDAsXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0czogYXN5bmMgKGNhbXBhaWduSWQsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWUvbm90aWZpY2F0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChjYW1wYWlnbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjYW1wYWlnbl9pZCddID0gY2FtcGFpZ25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhIHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcCBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gbWluaSBhcHAgdG8gcmV0cmlldmVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYW5zYWN0aW9uUGF5RnJhbWU6IGFzeW5jIChpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRUcmFuc2FjdGlvblBheUZyYW1lJywgJ2lkJywgaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWUvdHJhbnNhY3Rpb24vcGF5YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydpZCddID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIG1pbmkgYXBwIGVpdGhlciBieSBVVUlEIG9yIE5leW5hciBVUkxcbiAgICAgICAgICogQHN1bW1hcnkgTWluaSBhcHAgYnkgVVVJRCBvciBVUkxcbiAgICAgICAgICogQHBhcmFtIHtGcmFtZVR5cGV9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1dWlkXSBVVUlEIG9mIHRoZSBtaW5pIGFwcCB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF0gVVJMIG9mIHRoZSBOZXluYXIgbWluaSBhcHAgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TmV5bmFyRnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOZXluYXJGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLW5leW5hci1mcmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cE5leW5hckZyYW1lOiBhc3luYyAodHlwZSwgdXVpZCwgdXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3R5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwTmV5bmFyRnJhbWUnLCAndHlwZScsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndHlwZSddID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1dWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd1dWlkJ10gPSB1dWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndXJsJ10gPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0IG1pbmkgYXBwIGFjdGlvbnMsIGNhc3QgYWN0aW9ucyBvciBjYXN0IGNvbXBvc2VyIGFjdGlvbnMgdG8gdGhlIHNlcnZlciAgXFxcXCAoSW4gb3JkZXIgdG8gcG9zdCBhbnkgb2YgdGhlc2UgYWN0aW9ucywgeW91IG5lZWQgdG8gaGF2ZSBhbiBhcHByb3ZlZCBgc2lnbmVyX3V1aWRgKSAgVGhlIFBPU1QgcmVxdWVzdCB0byB0aGUgcG9zdF91cmwgaGFzIGEgdGltZW91dCBvZiA1IHNlY29uZHMgZm9yIG1pbmkgYXBwcy5cbiAgICAgICAgICogQHN1bW1hcnkgUG9zdCBhIG1pbmkgYXBwIGFjdGlvbiwgY2FzdCBhY3Rpb24gb3IgYSBjYXN0IGNvbXBvc2VyIGFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lQWN0aW9uUmVxQm9keX0gZnJhbWVBY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3Bvc3QtZnJhbWUtYWN0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcG9zdEZyYW1lQWN0aW9uOiBhc3luYyAoZnJhbWVBY3Rpb25SZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZyYW1lQWN0aW9uUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdwb3N0RnJhbWVBY3Rpb24nLCAnZnJhbWVBY3Rpb25SZXFCb2R5JywgZnJhbWVBY3Rpb25SZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lL2FjdGlvbmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGZyYW1lQWN0aW9uUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBhIG1pbmkgYXBwIGFjdGlvbiB0aGF0IGhhcyBiZWVuIHNpZ25lZCB3aXRoIGEgZGV2ZWxvcGVyIG1hbmFnZWQgc2lnbmVyICBUaGUgUE9TVCByZXF1ZXN0IHRvIHRoZSBwb3N0X3VybCBoYXMgYSB0aW1lb3V0IG9mIDUgc2Vjb25kcy5cbiAgICAgICAgICogQHN1bW1hcnkgU2lnbmF0dXJlIHBhY2tldFxuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHl9IGZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcG9zdC1mcmFtZS1hY3Rpb24tZGV2ZWxvcGVyLW1hbmFnZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkOiBhc3luYyAoZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmcmFtZURldmVsb3Blck1hbmFnZWRBY3Rpb25SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3Bvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQnLCAnZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keScsIGZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWUvZGV2ZWxvcGVyX21hbmFnZWQvYWN0aW9uYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBub3RpZmljYXRpb25zIHRvIGludGVyYWN0b3JzIG9mIGEgbWluaSBhcHBcbiAgICAgICAgICogQHN1bW1hcnkgU2VuZCBub3RpZmljYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7U2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHl9IHNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1mcmFtZS1ub3RpZmljYXRpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaEZyYW1lTm90aWZpY2F0aW9uczogYXN5bmMgKHNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnMnLCAnc2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHknLCBzZW5kRnJhbWVOb3RpZmljYXRpb25zUmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9mcmFtZS9ub3RpZmljYXRpb25zYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoc2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBtaW5pIGFwcCB3aXRoIGEgbGlzdCBvZiBwYWdlcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7TmV5bmFyRnJhbWVDcmVhdGlvblJlcUJvZHl9IG5leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtbmV5bmFyLWZyYW1lKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaE5leW5hckZyYW1lOiBhc3luYyAobmV5bmFyRnJhbWVDcmVhdGlvblJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV5bmFyRnJhbWVDcmVhdGlvblJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncHVibGlzaE5leW5hckZyYW1lJywgJ25leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5JywgbmV5bmFyRnJhbWVDcmVhdGlvblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShuZXluYXJGcmFtZUNyZWF0aW9uUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoIGZvciBtaW5pIGFwcHMgYmFzZWQgb24gYSBxdWVyeSBzdHJpbmdcbiAgICAgICAgICogQHN1bW1hcnkgU2VhcmNoIG1pbmkgYXBwc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcSBRdWVyeSBzdHJpbmcgdG8gc2VhcmNoIGZvciBtaW5pIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVDYXRhbG9nUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZUNhdGFsb2dSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLWZyYW1lcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaEZyYW1lczogYXN5bmMgKHEsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdzZWFyY2hGcmFtZXMnLCAncScsIHEpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnJhbWUvc2VhcmNoYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3EnXSA9IHE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIG1pbmkgYXBwIHdpdGggYSBsaXN0IG9mIHBhZ2VzLCBpZiBpdCB3YXMgbWFkZSBieSB0aGUgZGV2ZWxvcGVyIChpZGVudGlmaWVkIGJ5IEFQSSBrZXkpXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBtaW5pIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge05leW5hckZyYW1lVXBkYXRlUmVxQm9keX0gbmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VwZGF0ZS1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVOZXluYXJGcmFtZTogYXN5bmMgKG5leW5hckZyYW1lVXBkYXRlUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXluYXJGcmFtZVVwZGF0ZVJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndXBkYXRlTmV5bmFyRnJhbWUnLCAnbmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5JywgbmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUFVUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShuZXluYXJGcmFtZVVwZGF0ZVJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRlcyBhIG1pbmkgYXBwIGFnYWluc3QgYnkgYW4gaW50ZXJhY3RpbmcgdXNlciBhZ2FpbnN0IGEgRmFyY2FzdGVyIEh1YiBcXFxcIChJbiBvcmRlciB0byB2YWxpZGF0ZSBhIG1pbmkgYXBwLCBtZXNzYWdlIGJ5dGVzIGZyb20gRnJhbWUgQWN0aW9uIG11c3QgYmUgcHJvdmlkZWQgaW4gaGV4KVxuICAgICAgICAgKiBAc3VtbWFyeSBWYWxpZGF0ZSBtaW5pIGFwcCBhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtWYWxpZGF0ZUZyYW1lQWN0aW9uUmVxQm9keX0gdmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmFsaWRhdGVGcmFtZUFjdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVmFsaWRhdGVGcmFtZUFjdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS92YWxpZGF0ZS1mcmFtZS1hY3Rpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YWxpZGF0ZUZyYW1lQWN0aW9uOiBhc3luYyAodmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndmFsaWRhdGVGcmFtZUFjdGlvbicsICd2YWxpZGF0ZUZyYW1lQWN0aW9uUmVxQm9keScsIHZhbGlkYXRlRnJhbWVBY3Rpb25SZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2ZyYW1lL3ZhbGlkYXRlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkodmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRnJhbWVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEZyYW1lQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEZyYW1lQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnJhbWVBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkZyYW1lQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgbWluaSBhcHAsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RGVsZXRlRnJhbWVSZXFCb2R5fSBkZWxldGVGcmFtZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlbGV0ZUZyYW1lUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBkZWxldGVOZXluYXJGcmFtZShkZWxldGVGcmFtZVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZU5leW5hckZyYW1lKGRlbGV0ZUZyYW1lUmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLmRlbGV0ZU5leW5hckZyYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1cmF0ZWQgbGlzdCBvZiBmZWF0dXJlZCBtaW5pIGFwcHNcbiAgICAgICAgICogQHN1bW1hcnkgTWluaSBhcHBzIGNhdGFsb2dcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAxMDAsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7TWluaUFwcFRpbWVXaW5kb3d9IFt0aW1lV2luZG93XSBUaW1lIHdpbmRvdyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgY2hhbmdlIGluIHRyZW5kaW5nIHNjb3JlIGZvciBlYWNoIG1pbmkgYXBwLCB1c2VkIHRvIHNvcnQgbWluaSBhcHAgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEZldGNoRnJhbWVDYXRhbG9nQ2F0ZWdvcmllc0VudW0+fSBbY2F0ZWdvcmllc10gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY2F0ZWdvcmllcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRzLiAgSW5jbHVkZXMgYWxsIGlmIGxlZnQgYmxhbmsuICBFeGFtcGxlOiAmI3g2MDtjYXRlZ29yaWVzJiN4M0Q7Z2FtZXMsc29jaWFsJiN4NjA7IE9SOiAmI3g2MDtjYXRlZ29yaWVzJiN4M0Q7Z2FtZXMmYW1wO2NhdGVnb3JpZXMmI3gzRDtzb2NpYWwmI3g2MDtcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVDYXRhbG9nUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZUNhdGFsb2dSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEZyYW1lQ2F0YWxvZyhsaW1pdCwgY3Vyc29yLCB0aW1lV2luZG93LCBjYXRlZ29yaWVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEZyYW1lQ2F0YWxvZyhsaW1pdCwgY3Vyc29yLCB0aW1lV2luZG93LCBjYXRlZ29yaWVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkuZmV0Y2hGcmFtZUNhdGFsb2cnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgdGhlIG1pbmkgYXBwIG1ldGEgdGFncyBmcm9tIHRoZSBVUkxcbiAgICAgICAgICogQHN1bW1hcnkgTWV0YSB0YWdzIGZyb20gVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIG1pbmkgYXBwIFVSTCB0byBjcmF3bFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaEZyYW1lTWV0YVRhZ3NGcm9tVXJsMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaEZyYW1lTWV0YVRhZ3NGcm9tVXJsMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZyYW1lLW1ldGEtdGFncy1mcm9tLXVybClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEZyYW1lTWV0YVRhZ3NGcm9tVXJsKHVybCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLmZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBtaW5pIGFwcHMgbWFkZSBieSB0aGUgZGV2ZWxvcGVyIChpZGVudGlmaWVkIGJ5IEFQSSBrZXkpXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE5leW5hckZyYW1lPj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFycmF5PE5leW5hckZyYW1lPmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbmV5bmFyLWZyYW1lcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoTmV5bmFyRnJhbWVzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoTmV5bmFyRnJhbWVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGcmFtZUFwaS5mZXRjaE5leW5hckZyYW1lcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyB0b2tlbnMgcmVsYXRlZCB0byBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHAgbm90aWZpY2F0aW9uIHRva2Vuc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlkc10gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRklEcywgdXAgdG8gMTAwIGF0IGEgdGltZS4gSWYgeW91IHBhc3MgaW4gRklEcywgeW91IHdpbGwgZ2V0IGJhY2sgdGhlIG5vdGlmaWNhdGlvbiB0b2tlbnMgZm9yIHRob3NlIEZJRHMuIElmIHlvdSBkb25cXCYjMzk7dCBwYXNzIGluIEZJRHMsIHlvdSB3aWxsIGdldCBiYWNrIGFsbCB0aGUgbm90aWZpY2F0aW9uIHRva2VucyBmb3IgdGhlIG1pbmkgYXBwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVOb3RpZmljYXRpb25Ub2tlbnM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZU5vdGlmaWNhdGlvblRva2Vuc2Agb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbm90aWZpY2F0aW9uLXRva2VucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoTm90aWZpY2F0aW9uVG9rZW5zKGxpbWl0LCBmaWRzLCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoTm90aWZpY2F0aW9uVG9rZW5zKGxpbWl0LCBmaWRzLCBjdXJzb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGcmFtZUFwaS5mZXRjaE5vdGlmaWNhdGlvblRva2VucyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIG1pbmkgYXBwcyByZWxldmFudCB0byB0aGUgdXNlciBiYXNlZCBvbiBjYXN0cyBieSB1c2VycyB3aXRoIHN0cm9uZyBhZmZpbml0eSBzY29yZSBmb3IgdGhlIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3ZXJGaWQgRklEIG9mIHRoZSB1c2VyIHRvIGZldGNoIHJlbGV2YW50IG1pbmkgYXBwcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtNaW5pQXBwVGltZVdpbmRvd30gW3RpbWVXaW5kb3ddIFRpbWUgd2luZG93IHVzZWQgdG8gbGltaXQgc3RhdGlzdGljcyB1c2VkIHRvIGNhbGN1bGF0ZSBtaW5pIGFwcCByZWxldmFuY2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZWxldmFudEZyYW1lczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hSZWxldmFudEZyYW1lczIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mcmFtZS1yZWxldmFudClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoUmVsZXZhbnRGcmFtZXModmlld2VyRmlkLCB0aW1lV2luZG93LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFJlbGV2YW50RnJhbWVzKHZpZXdlckZpZCwgdGltZVdpbmRvdywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLmZldGNoUmVsZXZhbnRGcmFtZXMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGFuYWx5dGljcyBmb3IgdG90YWwtaW50ZXJhY3RvcnMsIGludGVyYWN0b3JzLCBudGVyYWN0aW9ucy1wZXItY2FzdCBhbmQgaW5wdXQtdGV4dC5cbiAgICAgICAgICogQHN1bW1hcnkgQW5hbHl0aWNzIGZvciB0aGUgbWluaSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZyYW1lVXJsXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdGVGcmFtZUFuYWx5dGljc1R5cGV9IGFuYWx5dGljc1R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9wXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdGVGcmFtZUFnZ3JlZ2F0ZVdpbmRvd30gW2FnZ3JlZ2F0ZVdpbmRvd10gUmVxdWlyZWQgZm9yICYjeDYwO2FuYWx5dGljc190eXBlJiN4M0Q7aW50ZXJhY3Rpb25zLXBlci1jYXN0JiN4NjA7XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdmFsaWRhdGUtZnJhbWUtYW5hbHl0aWNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzKGZyYW1lVXJsLCBhbmFseXRpY3NUeXBlLCBzdGFydCwgc3RvcCwgYWdncmVnYXRlV2luZG93LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MoZnJhbWVVcmwsIGFuYWx5dGljc1R5cGUsIHN0YXJ0LCBzdG9wLCBhZ2dyZWdhdGVXaW5kb3csIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGcmFtZUFwaS5mZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIG1pbmkgYXBwcyB2YWxpZGF0ZWQgYnkgYSB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEFsbCBtaW5pIGFwcHMgdmFsaWRhdGVkIGJ5IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVWYWxpZGF0ZUxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lVmFsaWRhdGVMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXZhbGlkYXRlLWZyYW1lLWxpc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFZhbGlkYXRlRnJhbWVMaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVmFsaWRhdGVGcmFtZUxpc3Qob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLmZldGNoVmFsaWRhdGVGcmFtZUxpc3QnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIG5vdGlmaWNhdGlvbiBkZWxpdmVyeSBhbmQgb3BlbmVkIHN0YXRzIGZvciBub3RpZmljYXRpb24gY2FtcGFpZ25zXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBub3RpZmljYXRpb24gY2FtcGFpZ24gc3RhdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjYW1wYWlnbklkXSBBbiBJRCBvZiBhIHNwZWNpZmljIG5vdGlmaWNhdGlvbiBjYW1wYWlnbiB0byBxdWVyeVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuICAoRGVmYXVsdDogMTAwLFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgR2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldE5vdGlmaWNhdGlvbkNhbXBhaWduU3RhdHMoY2FtcGFpZ25JZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0cyhjYW1wYWlnbklkLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkuZ2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0cyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGRldGFpbHMgYWJvdXQgYSB0cmFuc2FjdGlvbiBwYXkgbWluaSBhcHAgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIG1pbmkgYXBwIHRvIHJldHJpZXZlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRUcmFuc2FjdGlvblBheUZyYW1lKGlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRUcmFuc2FjdGlvblBheUZyYW1lKGlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkuZ2V0VHJhbnNhY3Rpb25QYXlGcmFtZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBtaW5pIGFwcCBlaXRoZXIgYnkgVVVJRCBvciBOZXluYXIgVVJMXG4gICAgICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwIGJ5IFVVSUQgb3IgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVUeXBlfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXVpZF0gVVVJRCBvZiB0aGUgbWluaSBhcHAgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdIFVSTCBvZiB0aGUgTmV5bmFyIG1pbmkgYXBwIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsb29rdXBOZXluYXJGcmFtZSh0eXBlLCB1dWlkLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cE5leW5hckZyYW1lKHR5cGUsIHV1aWQsIHVybCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLmxvb2t1cE5leW5hckZyYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0IG1pbmkgYXBwIGFjdGlvbnMsIGNhc3QgYWN0aW9ucyBvciBjYXN0IGNvbXBvc2VyIGFjdGlvbnMgdG8gdGhlIHNlcnZlciAgXFxcXCAoSW4gb3JkZXIgdG8gcG9zdCBhbnkgb2YgdGhlc2UgYWN0aW9ucywgeW91IG5lZWQgdG8gaGF2ZSBhbiBhcHByb3ZlZCBgc2lnbmVyX3V1aWRgKSAgVGhlIFBPU1QgcmVxdWVzdCB0byB0aGUgcG9zdF91cmwgaGFzIGEgdGltZW91dCBvZiA1IHNlY29uZHMgZm9yIG1pbmkgYXBwcy5cbiAgICAgICAgICogQHN1bW1hcnkgUG9zdCBhIG1pbmkgYXBwIGFjdGlvbiwgY2FzdCBhY3Rpb24gb3IgYSBjYXN0IGNvbXBvc2VyIGFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lQWN0aW9uUmVxQm9keX0gZnJhbWVBY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3Bvc3QtZnJhbWUtYWN0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcG9zdEZyYW1lQWN0aW9uKGZyYW1lQWN0aW9uUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucG9zdEZyYW1lQWN0aW9uKGZyYW1lQWN0aW9uUmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLnBvc3RGcmFtZUFjdGlvbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBhIG1pbmkgYXBwIGFjdGlvbiB0aGF0IGhhcyBiZWVuIHNpZ25lZCB3aXRoIGEgZGV2ZWxvcGVyIG1hbmFnZWQgc2lnbmVyICBUaGUgUE9TVCByZXF1ZXN0IHRvIHRoZSBwb3N0X3VybCBoYXMgYSB0aW1lb3V0IG9mIDUgc2Vjb25kcy5cbiAgICAgICAgICogQHN1bW1hcnkgU2lnbmF0dXJlIHBhY2tldFxuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHl9IGZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcG9zdC1mcmFtZS1hY3Rpb24tZGV2ZWxvcGVyLW1hbmFnZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBwb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkKGZyYW1lRGV2ZWxvcGVyTWFuYWdlZEFjdGlvblJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQoZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0ZyYW1lQXBpLnBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgbm90aWZpY2F0aW9ucyB0byBpbnRlcmFjdG9ycyBvZiBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlbmQgbm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1NlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXFCb2R5fSBzZW5kRnJhbWVOb3RpZmljYXRpb25zUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZW5kRnJhbWVOb3RpZmljYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTZW5kRnJhbWVOb3RpZmljYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtZnJhbWUtbm90aWZpY2F0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnMoc2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnMoc2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGcmFtZUFwaS5wdWJsaXNoRnJhbWVOb3RpZmljYXRpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgbWluaSBhcHAgd2l0aCBhIGxpc3Qgb2YgcGFnZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBtaW5pIGFwcFxuICAgICAgICAgKiBAcGFyYW0ge05leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5fSBuZXluYXJGcmFtZUNyZWF0aW9uUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZXluYXJGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5leW5hckZyYW1lYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLW5leW5hci1mcmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hOZXluYXJGcmFtZShuZXluYXJGcmFtZUNyZWF0aW9uUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucHVibGlzaE5leW5hckZyYW1lKG5leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkucHVibGlzaE5leW5hckZyYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2ggZm9yIG1pbmkgYXBwcyBiYXNlZCBvbiBhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgKiBAc3VtbWFyeSBTZWFyY2ggbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxIFF1ZXJ5IHN0cmluZyB0byBzZWFyY2ggZm9yIG1pbmkgYXBwc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZUNhdGFsb2dSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lQ2F0YWxvZ1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtZnJhbWVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgc2VhcmNoRnJhbWVzKHEsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnNlYXJjaEZyYW1lcyhxLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkuc2VhcmNoRnJhbWVzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgbWluaSBhcHAgd2l0aCBhIGxpc3Qgb2YgcGFnZXMsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7TmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5fSBuZXluYXJGcmFtZVVwZGF0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TmV5bmFyRnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOZXluYXJGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLW5leW5hci1mcmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHVwZGF0ZU5leW5hckZyYW1lKG5leW5hckZyYW1lVXBkYXRlUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IudXBkYXRlTmV5bmFyRnJhbWUobmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkudXBkYXRlTmV5bmFyRnJhbWUnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRlcyBhIG1pbmkgYXBwIGFnYWluc3QgYnkgYW4gaW50ZXJhY3RpbmcgdXNlciBhZ2FpbnN0IGEgRmFyY2FzdGVyIEh1YiBcXFxcIChJbiBvcmRlciB0byB2YWxpZGF0ZSBhIG1pbmkgYXBwLCBtZXNzYWdlIGJ5dGVzIGZyb20gRnJhbWUgQWN0aW9uIG11c3QgYmUgcHJvdmlkZWQgaW4gaGV4KVxuICAgICAgICAgKiBAc3VtbWFyeSBWYWxpZGF0ZSBtaW5pIGFwcCBhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtWYWxpZGF0ZUZyYW1lQWN0aW9uUmVxQm9keX0gdmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmFsaWRhdGVGcmFtZUFjdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVmFsaWRhdGVGcmFtZUFjdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS92YWxpZGF0ZS1mcmFtZS1hY3Rpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB2YWxpZGF0ZUZyYW1lQWN0aW9uKHZhbGlkYXRlRnJhbWVBY3Rpb25SZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci52YWxpZGF0ZUZyYW1lQWN0aW9uKHZhbGlkYXRlRnJhbWVBY3Rpb25SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnJhbWVBcGkudmFsaWRhdGVGcmFtZUFjdGlvbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5GcmFtZUFwaUZwID0gRnJhbWVBcGlGcDtcbi8qKlxuICogRnJhbWVBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBGcmFtZUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgbWluaSBhcHAsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlEZWxldGVOZXluYXJGcmFtZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlbGV0ZUZyYW1lUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVOZXluYXJGcmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlRnJhbWVSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXJhdGVkIGxpc3Qgb2YgZmVhdHVyZWQgbWluaSBhcHBzXG4gICAgICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwcyBjYXRhbG9nXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlGZXRjaEZyYW1lQ2F0YWxvZ1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVDYXRhbG9nUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZUNhdGFsb2dSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZyYW1lQ2F0YWxvZyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEZyYW1lQ2F0YWxvZyhyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy50aW1lV2luZG93LCByZXF1ZXN0UGFyYW1ldGVycy5jYXRlZ29yaWVzLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyB0aGUgbWluaSBhcHAgbWV0YSB0YWdzIGZyb20gdGhlIFVSTFxuICAgICAgICAgKiBAc3VtbWFyeSBNZXRhIHRhZ3MgZnJvbSBVUkxcbiAgICAgICAgICogQHBhcmFtIHtGcmFtZUFwaUZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmxSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZnJhbWUtbWV0YS10YWdzLWZyb20tdXJsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybChyZXF1ZXN0UGFyYW1ldGVycy51cmwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgbWluaSBhcHBzIG1hZGUgYnkgdGhlIGRldmVsb3BlciAoaWRlbnRpZmllZCBieSBBUEkga2V5KVxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IG9mIG1pbmkgYXBwc1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxOZXluYXJGcmFtZT4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBBcnJheTxOZXluYXJGcmFtZT5gIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW5leW5hci1mcmFtZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaE5leW5hckZyYW1lcyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaE5leW5hckZyYW1lcyhvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyB0b2tlbnMgcmVsYXRlZCB0byBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHAgbm90aWZpY2F0aW9uIHRva2Vuc1xuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpRmV0Y2hOb3RpZmljYXRpb25Ub2tlbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lTm90aWZpY2F0aW9uVG9rZW5zPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVOb3RpZmljYXRpb25Ub2tlbnNgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW5vdGlmaWNhdGlvbi10b2tlbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaE5vdGlmaWNhdGlvblRva2VucyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaE5vdGlmaWNhdGlvblRva2VucyhyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuZmlkcywgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIG1pbmkgYXBwcyByZWxldmFudCB0byB0aGUgdXNlciBiYXNlZCBvbiBjYXN0cyBieSB1c2VycyB3aXRoIHN0cm9uZyBhZmZpbml0eSBzY29yZSBmb3IgdGhlIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgbWluaSBhcHBzXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlGZXRjaFJlbGV2YW50RnJhbWVzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJlbGV2YW50RnJhbWVzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFJlbGV2YW50RnJhbWVzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZyYW1lLXJlbGV2YW50KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hSZWxldmFudEZyYW1lcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hSZWxldmFudEZyYW1lcyhyZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnRpbWVXaW5kb3csIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhbmFseXRpY3MgZm9yIHRvdGFsLWludGVyYWN0b3JzLCBpbnRlcmFjdG9ycywgbnRlcmFjdGlvbnMtcGVyLWNhc3QgYW5kIGlucHV0LXRleHQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEFuYWx5dGljcyBmb3IgdGhlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlGZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3NSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdmFsaWRhdGUtZnJhbWUtYW5hbHl0aWNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MocmVxdWVzdFBhcmFtZXRlcnMuZnJhbWVVcmwsIHJlcXVlc3RQYXJhbWV0ZXJzLmFuYWx5dGljc1R5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnN0YXJ0LCByZXF1ZXN0UGFyYW1ldGVycy5zdG9wLCByZXF1ZXN0UGFyYW1ldGVycy5hZ2dyZWdhdGVXaW5kb3csIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBtaW5pIGFwcHMgdmFsaWRhdGVkIGJ5IGEgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBBbGwgbWluaSBhcHBzIHZhbGlkYXRlZCBieSB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZVZhbGlkYXRlTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12YWxpZGF0ZS1mcmFtZS1saXN0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hWYWxpZGF0ZUZyYW1lTGlzdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFZhbGlkYXRlRnJhbWVMaXN0KG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBub3RpZmljYXRpb24gZGVsaXZlcnkgYW5kIG9wZW5lZCBzdGF0cyBmb3Igbm90aWZpY2F0aW9uIGNhbXBhaWduc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgbm90aWZpY2F0aW9uIGNhbXBhaWduIHN0YXRzXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0cyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzKHJlcXVlc3RQYXJhbWV0ZXJzLmNhbXBhaWduSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhIHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcCBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlHZXRUcmFuc2FjdGlvblBheUZyYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbkZyYW1lUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmFuc2FjdGlvbkZyYW1lUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25QYXlGcmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0VHJhbnNhY3Rpb25QYXlGcmFtZShyZXF1ZXN0UGFyYW1ldGVycy5pZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbWluaSBhcHAgZWl0aGVyIGJ5IFVVSUQgb3IgTmV5bmFyIFVSTFxuICAgICAgICAgKiBAc3VtbWFyeSBNaW5pIGFwcCBieSBVVUlEIG9yIFVSTFxuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpTG9va3VwTmV5bmFyRnJhbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBOZXluYXJGcmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMudXVpZCwgcmVxdWVzdFBhcmFtZXRlcnMudXJsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBtaW5pIGFwcCBhY3Rpb25zLCBjYXN0IGFjdGlvbnMgb3IgY2FzdCBjb21wb3NlciBhY3Rpb25zIHRvIHRoZSBzZXJ2ZXIgIFxcXFwgKEluIG9yZGVyIHRvIHBvc3QgYW55IG9mIHRoZXNlIGFjdGlvbnMsIHlvdSBuZWVkIHRvIGhhdmUgYW4gYXBwcm92ZWQgYHNpZ25lcl91dWlkYCkgIFRoZSBQT1NUIHJlcXVlc3QgdG8gdGhlIHBvc3RfdXJsIGhhcyBhIHRpbWVvdXQgb2YgNSBzZWNvbmRzIGZvciBtaW5pIGFwcHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvc3QgYSBtaW5pIGFwcCBhY3Rpb24sIGNhc3QgYWN0aW9uIG9yIGEgY2FzdCBjb21wb3NlciBhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtGcmFtZUFwaVBvc3RGcmFtZUFjdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcG9zdC1mcmFtZS1hY3Rpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwb3N0RnJhbWVBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnBvc3RGcmFtZUFjdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5mcmFtZUFjdGlvblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0IGEgbWluaSBhcHAgYWN0aW9uIHRoYXQgaGFzIGJlZW4gc2lnbmVkIHdpdGggYSBkZXZlbG9wZXIgbWFuYWdlZCBzaWduZXIgIFRoZSBQT1NUIHJlcXVlc3QgdG8gdGhlIHBvc3RfdXJsIGhhcyBhIHRpbWVvdXQgb2YgNSBzZWNvbmRzLlxuICAgICAgICAgKiBAc3VtbWFyeSBTaWduYXR1cmUgcGFja2V0XG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlQb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wb3N0LWZyYW1lLWFjdGlvbi1kZXZlbG9wZXItbWFuYWdlZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQocmVxdWVzdFBhcmFtZXRlcnMuZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgbm90aWZpY2F0aW9ucyB0byBpbnRlcmFjdG9ycyBvZiBhIG1pbmkgYXBwXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlbmQgbm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpUHVibGlzaEZyYW1lTm90aWZpY2F0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2VuZEZyYW1lTm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2VuZEZyYW1lTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLWZyYW1lLW5vdGlmaWNhdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoRnJhbWVOb3RpZmljYXRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoRnJhbWVOb3RpZmljYXRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IG1pbmkgYXBwIHdpdGggYSBsaXN0IG9mIHBhZ2VzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgbWluaSBhcHBcbiAgICAgICAgICogQHBhcmFtIHtGcmFtZUFwaVB1Ymxpc2hOZXluYXJGcmFtZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TmV5bmFyRnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOZXluYXJGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1uZXluYXItZnJhbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnB1Ymxpc2hOZXluYXJGcmFtZShyZXF1ZXN0UGFyYW1ldGVycy5uZXluYXJGcmFtZUNyZWF0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaCBmb3IgbWluaSBhcHBzIGJhc2VkIG9uIGEgcXVlcnkgc3RyaW5nXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBtaW5pIGFwcHNcbiAgICAgICAgICogQHBhcmFtIHtGcmFtZUFwaVNlYXJjaEZyYW1lc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVDYXRhbG9nUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZUNhdGFsb2dSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLWZyYW1lcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaEZyYW1lcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuc2VhcmNoRnJhbWVzKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgbWluaSBhcHAgd2l0aCBhIGxpc3Qgb2YgcGFnZXMsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIG1pbmkgYXBwXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlVcGRhdGVOZXluYXJGcmFtZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TmV5bmFyRnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOZXluYXJGcmFtZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLW5leW5hci1mcmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC51cGRhdGVOZXluYXJGcmFtZShyZXF1ZXN0UGFyYW1ldGVycy5uZXluYXJGcmFtZVVwZGF0ZVJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZXMgYSBtaW5pIGFwcCBhZ2FpbnN0IGJ5IGFuIGludGVyYWN0aW5nIHVzZXIgYWdhaW5zdCBhIEZhcmNhc3RlciBIdWIgXFxcXCAoSW4gb3JkZXIgdG8gdmFsaWRhdGUgYSBtaW5pIGFwcCwgbWVzc2FnZSBieXRlcyBmcm9tIEZyYW1lIEFjdGlvbiBtdXN0IGJlIHByb3ZpZGVkIGluIGhleClcbiAgICAgICAgICogQHN1bW1hcnkgVmFsaWRhdGUgbWluaSBhcHAgYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RnJhbWVBcGlWYWxpZGF0ZUZyYW1lQWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWYWxpZGF0ZUZyYW1lQWN0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBWYWxpZGF0ZUZyYW1lQWN0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3ZhbGlkYXRlLWZyYW1lLWFjdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkYXRlRnJhbWVBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnZhbGlkYXRlRnJhbWVBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMudmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZyYW1lQXBpRmFjdG9yeSA9IEZyYW1lQXBpRmFjdG9yeTtcbi8qKlxuICogRnJhbWVBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRnJhbWVBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBGcmFtZUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gZXhpc3RpbmcgbWluaSBhcHAsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgbWluaSBhcHBcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpRGVsZXRlTmV5bmFyRnJhbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGcmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERlbGV0ZUZyYW1lUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZWxldGVGcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLW5leW5hci1mcmFtZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGRlbGV0ZU5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GcmFtZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlbGV0ZU5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZUZyYW1lUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY3VyYXRlZCBsaXN0IG9mIGZlYXR1cmVkIG1pbmkgYXBwc1xuICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwcyBjYXRhbG9nXG4gICAgICogQHBhcmFtIHtGcmFtZUFwaUZldGNoRnJhbWVDYXRhbG9nUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZUNhdGFsb2dSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lQ2F0YWxvZ1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoRnJhbWVDYXRhbG9nKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hGcmFtZUNhdGFsb2cocmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMudGltZVdpbmRvdywgcmVxdWVzdFBhcmFtZXRlcnMuY2F0ZWdvcmllcywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG1pbmkgYXBwIG1ldGEgdGFncyBmcm9tIHRoZSBVUkxcbiAgICAgKiBAc3VtbWFyeSBNZXRhIHRhZ3MgZnJvbSBVUkxcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpRmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybDIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybDIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZnJhbWUtbWV0YS10YWdzLWZyb20tdXJsKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnJhbWVBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEZyYW1lTWV0YVRhZ3NGcm9tVXJsKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBtaW5pIGFwcHMgbWFkZSBieSB0aGUgZGV2ZWxvcGVyIChpZGVudGlmaWVkIGJ5IEFQSSBrZXkpXG4gICAgICogQHN1bW1hcnkgTGlzdCBvZiBtaW5pIGFwcHNcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8TmV5bmFyRnJhbWU+Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXJyYXk8TmV5bmFyRnJhbWU+YCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbmV5bmFyLWZyYW1lcylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoTmV5bmFyRnJhbWVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hOZXluYXJGcmFtZXMob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgdG9rZW5zIHJlbGF0ZWQgdG8gYSBtaW5pIGFwcFxuICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHAgbm90aWZpY2F0aW9uIHRva2Vuc1xuICAgICAqIEBwYXJhbSB7RnJhbWVBcGlGZXRjaE5vdGlmaWNhdGlvblRva2Vuc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVOb3RpZmljYXRpb25Ub2tlbnM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZU5vdGlmaWNhdGlvblRva2Vuc2Agb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW5vdGlmaWNhdGlvbi10b2tlbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaE5vdGlmaWNhdGlvblRva2VucyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GcmFtZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoTm90aWZpY2F0aW9uVG9rZW5zKHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5maWRzLCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgbWluaSBhcHBzIHJlbGV2YW50IHRvIHRoZSB1c2VyIGJhc2VkIG9uIGNhc3RzIGJ5IHVzZXJzIHdpdGggc3Ryb25nIGFmZmluaXR5IHNjb3JlIGZvciB0aGUgdXNlclxuICAgICAqIEBzdW1tYXJ5IFJlbGV2YW50IG1pbmkgYXBwc1xuICAgICAqIEBwYXJhbSB7RnJhbWVBcGlGZXRjaFJlbGV2YW50RnJhbWVzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJlbGV2YW50RnJhbWVzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFJlbGV2YW50RnJhbWVzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mcmFtZS1yZWxldmFudClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoUmVsZXZhbnRGcmFtZXMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hSZWxldmFudEZyYW1lcyhyZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnRpbWVXaW5kb3csIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmFseXRpY3MgZm9yIHRvdGFsLWludGVyYWN0b3JzLCBpbnRlcmFjdG9ycywgbnRlcmFjdGlvbnMtcGVyLWNhc3QgYW5kIGlucHV0LXRleHQuXG4gICAgICogQHN1bW1hcnkgQW5hbHl0aWNzIGZvciB0aGUgbWluaSBhcHBcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpRmV0Y2hWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZVZhbGlkYXRlQW5hbHl0aWNzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZVZhbGlkYXRlQW5hbHl0aWNzUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12YWxpZGF0ZS1mcmFtZS1hbmFseXRpY3MpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzKHJlcXVlc3RQYXJhbWV0ZXJzLmZyYW1lVXJsLCByZXF1ZXN0UGFyYW1ldGVycy5hbmFseXRpY3NUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5zdGFydCwgcmVxdWVzdFBhcmFtZXRlcnMuc3RvcCwgcmVxdWVzdFBhcmFtZXRlcnMuYWdncmVnYXRlV2luZG93LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgbWluaSBhcHBzIHZhbGlkYXRlZCBieSBhIHVzZXJcbiAgICAgKiBAc3VtbWFyeSBBbGwgbWluaSBhcHBzIHZhbGlkYXRlZCBieSB1c2VyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGcmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZVZhbGlkYXRlTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdmFsaWRhdGUtZnJhbWUtbGlzdClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVmFsaWRhdGVGcmFtZUxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnJhbWVBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFZhbGlkYXRlRnJhbWVMaXN0KG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBub3RpZmljYXRpb24gZGVsaXZlcnkgYW5kIG9wZW5lZCBzdGF0cyBmb3Igbm90aWZpY2F0aW9uIGNhbXBhaWduc1xuICAgICAqIEBzdW1tYXJ5IEdldCBub3RpZmljYXRpb24gY2FtcGFpZ24gc3RhdHNcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpR2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgR2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGdldE5vdGlmaWNhdGlvbkNhbXBhaWduU3RhdHMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnJhbWVBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzKHJlcXVlc3RQYXJhbWV0ZXJzLmNhbXBhaWduSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhIHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcCBieSBJRFxuICAgICAqIEBzdW1tYXJ5IEdldCB0cmFuc2FjdGlvbiBwYXkgbWluaSBhcHBcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpR2V0VHJhbnNhY3Rpb25QYXlGcmFtZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25GcmFtZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uUGF5RnJhbWUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0VHJhbnNhY3Rpb25QYXlGcmFtZShyZXF1ZXN0UGFyYW1ldGVycy5pZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbWluaSBhcHAgZWl0aGVyIGJ5IFVVSUQgb3IgTmV5bmFyIFVSTFxuICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwIGJ5IFVVSUQgb3IgVVJMXG4gICAgICogQHBhcmFtIHtGcmFtZUFwaUxvb2t1cE5leW5hckZyYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZXluYXJGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5leW5hckZyYW1lYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLW5leW5hci1mcmFtZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cE5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GcmFtZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cE5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnV1aWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnVybCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgbWluaSBhcHAgYWN0aW9ucywgY2FzdCBhY3Rpb25zIG9yIGNhc3QgY29tcG9zZXIgYWN0aW9ucyB0byB0aGUgc2VydmVyICBcXFxcIChJbiBvcmRlciB0byBwb3N0IGFueSBvZiB0aGVzZSBhY3Rpb25zLCB5b3UgbmVlZCB0byBoYXZlIGFuIGFwcHJvdmVkIGBzaWduZXJfdXVpZGApICBUaGUgUE9TVCByZXF1ZXN0IHRvIHRoZSBwb3N0X3VybCBoYXMgYSB0aW1lb3V0IG9mIDUgc2Vjb25kcyBmb3IgbWluaSBhcHBzLlxuICAgICAqIEBzdW1tYXJ5IFBvc3QgYSBtaW5pIGFwcCBhY3Rpb24sIGNhc3QgYWN0aW9uIG9yIGEgY2FzdCBjb21wb3NlciBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpUG9zdEZyYW1lQWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcG9zdC1mcmFtZS1hY3Rpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBwb3N0RnJhbWVBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucG9zdEZyYW1lQWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLmZyYW1lQWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgYSBtaW5pIGFwcCBhY3Rpb24gdGhhdCBoYXMgYmVlbiBzaWduZWQgd2l0aCBhIGRldmVsb3BlciBtYW5hZ2VkIHNpZ25lciAgVGhlIFBPU1QgcmVxdWVzdCB0byB0aGUgcG9zdF91cmwgaGFzIGEgdGltZW91dCBvZiA1IHNlY29uZHMuXG4gICAgICogQHN1bW1hcnkgU2lnbmF0dXJlIHBhY2tldFxuICAgICAqIEBwYXJhbSB7RnJhbWVBcGlQb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcG9zdC1mcmFtZS1hY3Rpb24tZGV2ZWxvcGVyLW1hbmFnZWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBwb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GcmFtZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQocmVxdWVzdFBhcmFtZXRlcnMuZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgbm90aWZpY2F0aW9ucyB0byBpbnRlcmFjdG9ycyBvZiBhIG1pbmkgYXBwXG4gICAgICogQHN1bW1hcnkgU2VuZCBub3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtIHtGcmFtZUFwaVB1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGcmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNlbmRGcmFtZU5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtZnJhbWUtbm90aWZpY2F0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaEZyYW1lTm90aWZpY2F0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycy5zZW5kRnJhbWVOb3RpZmljYXRpb25zUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtaW5pIGFwcCB3aXRoIGEgbGlzdCBvZiBwYWdlcy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgbWluaSBhcHBcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpUHVibGlzaE5leW5hckZyYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZXluYXJGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5leW5hckZyYW1lYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1uZXluYXItZnJhbWUpXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaXNoTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaE5leW5hckZyYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLm5leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBtaW5pIGFwcHMgYmFzZWQgb24gYSBxdWVyeSBzdHJpbmdcbiAgICAgKiBAc3VtbWFyeSBTZWFyY2ggbWluaSBhcHBzXG4gICAgICogQHBhcmFtIHtGcmFtZUFwaVNlYXJjaEZyYW1lc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZyYW1lQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVDYXRhbG9nUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZUNhdGFsb2dSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlYXJjaC1mcmFtZXMpXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hGcmFtZXMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc2VhcmNoRnJhbWVzKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgbWluaSBhcHAgd2l0aCBhIGxpc3Qgb2YgcGFnZXMsIGlmIGl0IHdhcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGUgbWluaSBhcHBcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQXBpVXBkYXRlTmV5bmFyRnJhbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGcmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtbmV5bmFyLWZyYW1lKVxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikudXBkYXRlTmV5bmFyRnJhbWUocmVxdWVzdFBhcmFtZXRlcnMubmV5bmFyRnJhbWVVcGRhdGVSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGEgbWluaSBhcHAgYWdhaW5zdCBieSBhbiBpbnRlcmFjdGluZyB1c2VyIGFnYWluc3QgYSBGYXJjYXN0ZXIgSHViIFxcXFwgKEluIG9yZGVyIHRvIHZhbGlkYXRlIGEgbWluaSBhcHAsIG1lc3NhZ2UgYnl0ZXMgZnJvbSBGcmFtZSBBY3Rpb24gbXVzdCBiZSBwcm92aWRlZCBpbiBoZXgpXG4gICAgICogQHN1bW1hcnkgVmFsaWRhdGUgbWluaSBhcHAgYWN0aW9uXG4gICAgICogQHBhcmFtIHtGcmFtZUFwaVZhbGlkYXRlRnJhbWVBY3Rpb25SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGcmFtZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZhbGlkYXRlRnJhbWVBY3Rpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFZhbGlkYXRlRnJhbWVBY3Rpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3ZhbGlkYXRlLWZyYW1lLWFjdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIHZhbGlkYXRlRnJhbWVBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZyYW1lQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikudmFsaWRhdGVGcmFtZUFjdGlvbihyZXF1ZXN0UGFyYW1ldGVycy52YWxpZGF0ZUZyYW1lQWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFtZUFwaSA9IEZyYW1lQXBpO1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRmV0Y2hGcmFtZUNhdGFsb2dDYXRlZ29yaWVzRW51bSA9IHtcbiAgICBHYW1lczogJ2dhbWVzJyxcbiAgICBTb2NpYWw6ICdzb2NpYWwnLFxuICAgIEZpbmFuY2U6ICdmaW5hbmNlJyxcbiAgICBVdGlsaXR5OiAndXRpbGl0eScsXG4gICAgUHJvZHVjdGl2aXR5OiAncHJvZHVjdGl2aXR5JyxcbiAgICBIZWFsdGhGaXRuZXNzOiAnaGVhbHRoLWZpdG5lc3MnLFxuICAgIE5ld3NNZWRpYTogJ25ld3MtbWVkaWEnLFxuICAgIE11c2ljOiAnbXVzaWMnLFxuICAgIFNob3BwaW5nOiAnc2hvcHBpbmcnLFxuICAgIEVkdWNhdGlvbjogJ2VkdWNhdGlvbicsXG4gICAgRGV2ZWxvcGVyVG9vbHM6ICdkZXZlbG9wZXItdG9vbHMnLFxuICAgIEVudGVydGFpbm1lbnQ6ICdlbnRlcnRhaW5tZW50JyxcbiAgICBBcnRDcmVhdGl2aXR5OiAnYXJ0LWNyZWF0aXZpdHknXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/frame-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/login-api.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/login-api.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoginApi = exports.LoginApiFactory = exports.LoginApiFp = exports.LoginApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * LoginApi - axios parameter creator\n * @export\n */\nconst LoginApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Nonce to sign a message\n         * @summary Fetch nonce\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)\n         *\n         */\n        fetchNonce: async (options = {}) => {\n            const localVarPath = `/farcaster/login/nonce`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.LoginApiAxiosParamCreator = LoginApiAxiosParamCreator;\n/**\n * LoginApi - functional programming interface\n * @export\n */\nconst LoginApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.LoginApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Nonce to sign a message\n         * @summary Fetch nonce\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)\n         *\n         */\n        async fetchNonce(options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNonce(options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LoginApi.fetchNonce']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.LoginApiFp = LoginApiFp;\n/**\n * LoginApi - factory interface\n * @export\n */\nconst LoginApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.LoginApiFp)(configuration);\n    return {\n        /**\n         * Nonce to sign a message\n         * @summary Fetch nonce\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)\n         *\n         */\n        fetchNonce(options) {\n            return localVarFp.fetchNonce(options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.LoginApiFactory = LoginApiFactory;\n/**\n * LoginApi - object-oriented interface\n * @export\n * @class LoginApi\n * @extends {BaseAPI}\n */\nclass LoginApi extends base_1.BaseAPI {\n    /**\n     * Nonce to sign a message\n     * @summary Fetch nonce\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LoginApi\n     * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)\n     *\n     */\n    fetchNonce(options) {\n        return (0, exports.LoginApiFp)(this.configuration).fetchNonce(options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.LoginApi = LoginApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2xvZ2luLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDO0FBQ25HLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL2xvZ2luLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9naW5BcGkgPSBleHBvcnRzLkxvZ2luQXBpRmFjdG9yeSA9IGV4cG9ydHMuTG9naW5BcGlGcCA9IGV4cG9ydHMuTG9naW5BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIExvZ2luQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTG9naW5BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbmNlIHRvIHNpZ24gYSBtZXNzYWdlXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIG5vbmNlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vbmNlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOb25jZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub25jZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoTm9uY2U6IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2xvZ2luL25vbmNlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Mb2dpbkFwaUF4aW9zUGFyYW1DcmVhdG9yID0gTG9naW5BcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogTG9naW5BcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBMb2dpbkFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuTG9naW5BcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbmNlIHRvIHNpZ24gYSBtZXNzYWdlXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIG5vbmNlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vbmNlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOb25jZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub25jZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoTm9uY2Uob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hOb25jZShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTG9naW5BcGkuZmV0Y2hOb25jZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Mb2dpbkFwaUZwID0gTG9naW5BcGlGcDtcbi8qKlxuICogTG9naW5BcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBMb2dpbkFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkxvZ2luQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25jZSB0byBzaWduIGEgbWVzc2FnZVxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBub25jZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb25jZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm9uY2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbm9uY2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaE5vbmNlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoTm9uY2Uob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTG9naW5BcGlGYWN0b3J5ID0gTG9naW5BcGlGYWN0b3J5O1xuLyoqXG4gKiBMb2dpbkFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBMb2dpbkFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIExvZ2luQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIE5vbmNlIHRvIHNpZ24gYSBtZXNzYWdlXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggbm9uY2VcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIExvZ2luQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm9uY2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vbmNlUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub25jZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoTm9uY2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTG9naW5BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaE5vbmNlKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9naW5BcGkgPSBMb2dpbkFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/login-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/metrics-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/metrics-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchCastMetricsIntervalEnum = exports.MetricsApi = exports.MetricsApiFactory = exports.MetricsApiFp = exports.MetricsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * MetricsApi - axios parameter creator\n * @export\n */\nconst MetricsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetches metrics casts matching a query\n         * @summary Metrics for casts\n         * @param {string} q Query string to search for casts\n         * @param {FetchCastMetricsIntervalEnum} [interval] Interval of time for which to fetch metrics. Default is 30d.\n         * @param {number} [authorFid] Fid of the user whose casts you want to search\n         * @param {string} [channelId] Channel ID of the casts you want to search\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)\n         *\n         */\n        fetchCastMetrics: async (q, interval, authorFid, channelId, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'q' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastMetrics', 'q', q);\n            const localVarPath = `/farcaster/cast/metrics`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (q !== undefined) {\n                localVarQueryParameter['q'] = q;\n            }\n            if (interval !== undefined) {\n                localVarQueryParameter['interval'] = interval;\n            }\n            if (authorFid !== undefined) {\n                localVarQueryParameter['author_fid'] = authorFid;\n            }\n            if (channelId !== undefined) {\n                localVarQueryParameter['channel_id'] = channelId;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.MetricsApiAxiosParamCreator = MetricsApiAxiosParamCreator;\n/**\n * MetricsApi - functional programming interface\n * @export\n */\nconst MetricsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.MetricsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetches metrics casts matching a query\n         * @summary Metrics for casts\n         * @param {string} q Query string to search for casts\n         * @param {FetchCastMetricsIntervalEnum} [interval] Interval of time for which to fetch metrics. Default is 30d.\n         * @param {number} [authorFid] Fid of the user whose casts you want to search\n         * @param {string} [channelId] Channel ID of the casts you want to search\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)\n         *\n         */\n        async fetchCastMetrics(q, interval, authorFid, channelId, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastMetrics(q, interval, authorFid, channelId, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MetricsApi.fetchCastMetrics']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.MetricsApiFp = MetricsApiFp;\n/**\n * MetricsApi - factory interface\n * @export\n */\nconst MetricsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.MetricsApiFp)(configuration);\n    return {\n        /**\n         * Fetches metrics casts matching a query\n         * @summary Metrics for casts\n         * @param {MetricsApiFetchCastMetricsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)\n         *\n         */\n        fetchCastMetrics(requestParameters, options) {\n            return localVarFp.fetchCastMetrics(requestParameters.q, requestParameters.interval, requestParameters.authorFid, requestParameters.channelId, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.MetricsApiFactory = MetricsApiFactory;\n/**\n * MetricsApi - object-oriented interface\n * @export\n * @class MetricsApi\n * @extends {BaseAPI}\n */\nclass MetricsApi extends base_1.BaseAPI {\n    /**\n     * Fetches metrics casts matching a query\n     * @summary Metrics for casts\n     * @param {MetricsApiFetchCastMetricsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MetricsApi\n     * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)\n     *\n     */\n    fetchCastMetrics(requestParameters, options) {\n        return (0, exports.MetricsApiFp)(this.configuration).fetchCastMetrics(requestParameters.q, requestParameters.interval, requestParameters.authorFid, requestParameters.channelId, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.MetricsApi = MetricsApi;\n/**\n * @export\n */\nexports.FetchCastMetricsIntervalEnum = {\n    _1d: '1d',\n    _7d: '7d',\n    _30d: '30d',\n    _90d: '90d',\n    _180d: '180d'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL21ldHJpY3MtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDbEosZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL21ldHJpY3MtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GZXRjaENhc3RNZXRyaWNzSW50ZXJ2YWxFbnVtID0gZXhwb3J0cy5NZXRyaWNzQXBpID0gZXhwb3J0cy5NZXRyaWNzQXBpRmFjdG9yeSA9IGV4cG9ydHMuTWV0cmljc0FwaUZwID0gZXhwb3J0cy5NZXRyaWNzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBNZXRyaWNzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWV0cmljc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBtZXRyaWNzIGNhc3RzIG1hdGNoaW5nIGEgcXVlcnlcbiAgICAgICAgICogQHN1bW1hcnkgTWV0cmljcyBmb3IgY2FzdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHEgUXVlcnkgc3RyaW5nIHRvIHNlYXJjaCBmb3IgY2FzdHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaENhc3RNZXRyaWNzSW50ZXJ2YWxFbnVtfSBbaW50ZXJ2YWxdIEludGVydmFsIG9mIHRpbWUgZm9yIHdoaWNoIHRvIGZldGNoIG1ldHJpY3MuIERlZmF1bHQgaXMgMzBkLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2F1dGhvckZpZF0gRmlkIG9mIHRoZSB1c2VyIHdob3NlIGNhc3RzIHlvdSB3YW50IHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYW5uZWxJZF0gQ2hhbm5lbCBJRCBvZiB0aGUgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RzTWV0cmljc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdHNNZXRyaWNzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3QtbWV0cmljcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2FzdE1ldHJpY3M6IGFzeW5jIChxLCBpbnRlcnZhbCwgYXV0aG9yRmlkLCBjaGFubmVsSWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaENhc3RNZXRyaWNzJywgJ3EnLCBxKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL2Nhc3QvbWV0cmljc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydxJ10gPSBxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludGVydmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydpbnRlcnZhbCddID0gaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXV0aG9yRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhdXRob3JfZmlkJ10gPSBhdXRob3JGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbm5lbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjaGFubmVsX2lkJ10gPSBjaGFubmVsSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NZXRyaWNzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBNZXRyaWNzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE1ldHJpY3NBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBNZXRyaWNzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5NZXRyaWNzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIG1ldHJpY3MgY2FzdHMgbWF0Y2hpbmcgYSBxdWVyeVxuICAgICAgICAgKiBAc3VtbWFyeSBNZXRyaWNzIGZvciBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcSBRdWVyeSBzdHJpbmcgdG8gc2VhcmNoIGZvciBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge0ZldGNoQ2FzdE1ldHJpY3NJbnRlcnZhbEVudW19IFtpbnRlcnZhbF0gSW50ZXJ2YWwgb2YgdGltZSBmb3Igd2hpY2ggdG8gZmV0Y2ggbWV0cmljcy4gRGVmYXVsdCBpcyAzMGQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXV0aG9yRmlkXSBGaWQgb2YgdGhlIHVzZXIgd2hvc2UgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhbm5lbElkXSBDaGFubmVsIElEIG9mIHRoZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNNZXRyaWNzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0c01ldHJpY3NSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdC1tZXRyaWNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hDYXN0TWV0cmljcyhxLCBpbnRlcnZhbCwgYXV0aG9yRmlkLCBjaGFubmVsSWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2FzdE1ldHJpY3MocSwgaW50ZXJ2YWwsIGF1dGhvckZpZCwgY2hhbm5lbElkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTWV0cmljc0FwaS5mZXRjaENhc3RNZXRyaWNzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk1ldHJpY3NBcGlGcCA9IE1ldHJpY3NBcGlGcDtcbi8qKlxuICogTWV0cmljc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1ldHJpY3NBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5NZXRyaWNzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIG1ldHJpY3MgY2FzdHMgbWF0Y2hpbmcgYSBxdWVyeVxuICAgICAgICAgKiBAc3VtbWFyeSBNZXRyaWNzIGZvciBjYXN0c1xuICAgICAgICAgKiBAcGFyYW0ge01ldHJpY3NBcGlGZXRjaENhc3RNZXRyaWNzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0c01ldHJpY3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzTWV0cmljc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LW1ldHJpY3MpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENhc3RNZXRyaWNzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaENhc3RNZXRyaWNzKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLmludGVydmFsLCByZXF1ZXN0UGFyYW1ldGVycy5hdXRob3JGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxJZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTWV0cmljc0FwaUZhY3RvcnkgPSBNZXRyaWNzQXBpRmFjdG9yeTtcbi8qKlxuICogTWV0cmljc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBNZXRyaWNzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgTWV0cmljc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIG1ldHJpY3MgY2FzdHMgbWF0Y2hpbmcgYSBxdWVyeVxuICAgICAqIEBzdW1tYXJ5IE1ldHJpY3MgZm9yIGNhc3RzXG4gICAgICogQHBhcmFtIHtNZXRyaWNzQXBpRmV0Y2hDYXN0TWV0cmljc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE1ldHJpY3NBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0c01ldHJpY3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzTWV0cmljc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdC1tZXRyaWNzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hDYXN0TWV0cmljcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTWV0cmljc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoQ2FzdE1ldHJpY3MocmVxdWVzdFBhcmFtZXRlcnMucSwgcmVxdWVzdFBhcmFtZXRlcnMuaW50ZXJ2YWwsIHJlcXVlc3RQYXJhbWV0ZXJzLmF1dGhvckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLk1ldHJpY3NBcGkgPSBNZXRyaWNzQXBpO1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRmV0Y2hDYXN0TWV0cmljc0ludGVydmFsRW51bSA9IHtcbiAgICBfMWQ6ICcxZCcsXG4gICAgXzdkOiAnN2QnLFxuICAgIF8zMGQ6ICczMGQnLFxuICAgIF85MGQ6ICc5MGQnLFxuICAgIF8xODBkOiAnMTgwZCdcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/metrics-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/mute-api.js":
/*!********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/mute-api.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MuteApi = exports.MuteApiFactory = exports.MuteApiFp = exports.MuteApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * MuteApi - axios parameter creator\n * @export\n */\nconst MuteApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Unmute FID\n         * @param {MuteReqBody} muteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)\n         *\n         */\n        deleteMute: async (muteReqBody, options = {}) => {\n            // verify required parameter 'muteReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteMute', 'muteReqBody', muteReqBody);\n            const localVarPath = `/farcaster/mute`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(muteReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all FIDs that a user has muted.\n         * @summary Muted FIDs of user\n         * @param {number} fid The user\\&#39;s FID (identifier)\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)\n         *\n         */\n        fetchMuteList: async (fid, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchMuteList', 'fid', fid);\n            const localVarPath = `/farcaster/mute/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Mute FID\n         * @param {MuteReqBody} muteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)\n         *\n         */\n        publishMute: async (muteReqBody, options = {}) => {\n            // verify required parameter 'muteReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishMute', 'muteReqBody', muteReqBody);\n            const localVarPath = `/farcaster/mute`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(muteReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.MuteApiAxiosParamCreator = MuteApiAxiosParamCreator;\n/**\n * MuteApi - functional programming interface\n * @export\n */\nconst MuteApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.MuteApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Unmute FID\n         * @param {MuteReqBody} muteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)\n         *\n         */\n        async deleteMute(muteReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMute(muteReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MuteApi.deleteMute']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all FIDs that a user has muted.\n         * @summary Muted FIDs of user\n         * @param {number} fid The user\\&#39;s FID (identifier)\n         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)\n         *\n         */\n        async fetchMuteList(fid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchMuteList(fid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MuteApi.fetchMuteList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Mute FID\n         * @param {MuteReqBody} muteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)\n         *\n         */\n        async publishMute(muteReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishMute(muteReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MuteApi.publishMute']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.MuteApiFp = MuteApiFp;\n/**\n * MuteApi - factory interface\n * @export\n */\nconst MuteApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.MuteApiFp)(configuration);\n    return {\n        /**\n         * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Unmute FID\n         * @param {MuteApiDeleteMuteRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)\n         *\n         */\n        deleteMute(requestParameters, options) {\n            return localVarFp.deleteMute(requestParameters.muteReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all FIDs that a user has muted.\n         * @summary Muted FIDs of user\n         * @param {MuteApiFetchMuteListRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)\n         *\n         */\n        fetchMuteList(requestParameters, options) {\n            return localVarFp.fetchMuteList(requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.\n         * @summary Mute FID\n         * @param {MuteApiPublishMuteRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)\n         *\n         */\n        publishMute(requestParameters, options) {\n            return localVarFp.publishMute(requestParameters.muteReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.MuteApiFactory = MuteApiFactory;\n/**\n * MuteApi - object-oriented interface\n * @export\n * @class MuteApi\n * @extends {BaseAPI}\n */\nclass MuteApi extends base_1.BaseAPI {\n    /**\n     * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.\n     * @summary Unmute FID\n     * @param {MuteApiDeleteMuteRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MuteApi\n     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)\n     *\n     */\n    deleteMute(requestParameters, options) {\n        return (0, exports.MuteApiFp)(this.configuration).deleteMute(requestParameters.muteReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all FIDs that a user has muted.\n     * @summary Muted FIDs of user\n     * @param {MuteApiFetchMuteListRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MuteApi\n     * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)\n     *\n     */\n    fetchMuteList(requestParameters, options) {\n        return (0, exports.MuteApiFp)(this.configuration).fetchMuteList(requestParameters.fid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.\n     * @summary Mute FID\n     * @param {MuteApiPublishMuteRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MuteApi\n     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)\n     *\n     */\n    publishMute(requestParameters, options) {\n        return (0, exports.MuteApiFp)(this.configuration).publishMute(requestParameters.muteReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.MuteApi = MuteApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL211dGUtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsZ0NBQWdDO0FBQy9GLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsa0JBQWtCO0FBQzdDLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9tdXRlLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXV0ZUFwaSA9IGV4cG9ydHMuTXV0ZUFwaUZhY3RvcnkgPSBleHBvcnRzLk11dGVBcGlGcCA9IGV4cG9ydHMuTXV0ZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogTXV0ZUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE11dGVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgYSBtdXRlIGZvciBhIGdpdmVuIEZJRC4gVGhpcyBpcyBhbiBhbGxvd2xpc3RlZCBBUEksIHJlYWNoIG91dCBpZiB5b3Ugd2FudCBhY2Nlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFVubXV0ZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtNdXRlUmVxQm9keX0gbXV0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtbXV0ZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZU11dGU6IGFzeW5jIChtdXRlUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdtdXRlUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZWxldGVNdXRlJywgJ211dGVSZXFCb2R5JywgbXV0ZVJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvbXV0ZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0RFTEVURScgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkobXV0ZVJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIG11dGVkLlxuICAgICAgICAgKiBAc3VtbWFyeSBNdXRlZCBGSURzIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgdXNlclxcJiMzOTtzIEZJRCAoaWRlbnRpZmllcilcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE11dGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBNdXRlTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1tdXRlLWxpc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaE11dGVMaXN0OiBhc3luYyAoZmlkLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaE11dGVMaXN0JywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9tdXRlL2xpc3RgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG11dGUgZm9yIGEgZ2l2ZW4gRklELiBUaGlzIGlzIGFuIGFsbG93bGlzdGVkIEFQSSwgcmVhY2ggb3V0IGlmIHlvdSB3YW50IGFjY2Vzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTXV0ZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtNdXRlUmVxQm9keX0gbXV0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLW11dGUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoTXV0ZTogYXN5bmMgKG11dGVSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ211dGVSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hNdXRlJywgJ211dGVSZXFCb2R5JywgbXV0ZVJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvbXV0ZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKG11dGVSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk11dGVBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IE11dGVBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogTXV0ZUFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE11dGVBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLk11dGVBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgYSBtdXRlIGZvciBhIGdpdmVuIEZJRC4gVGhpcyBpcyBhbiBhbGxvd2xpc3RlZCBBUEksIHJlYWNoIG91dCBpZiB5b3Ugd2FudCBhY2Nlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFVubXV0ZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtNdXRlUmVxQm9keX0gbXV0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtbXV0ZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZU11dGUobXV0ZVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZU11dGUobXV0ZVJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydNdXRlQXBpLmRlbGV0ZU11dGUnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIG11dGVkLlxuICAgICAgICAgKiBAc3VtbWFyeSBNdXRlZCBGSURzIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgdXNlclxcJiMzOTtzIEZJRCAoaWRlbnRpZmllcilcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE11dGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBNdXRlTGlzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1tdXRlLWxpc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaE11dGVMaXN0KGZpZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hNdXRlTGlzdChmaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydNdXRlQXBpLmZldGNoTXV0ZUxpc3QnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBtdXRlIGZvciBhIGdpdmVuIEZJRC4gVGhpcyBpcyBhbiBhbGxvd2xpc3RlZCBBUEksIHJlYWNoIG91dCBpZiB5b3Ugd2FudCBhY2Nlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IE11dGUgRklEXG4gICAgICAgICAqIEBwYXJhbSB7TXV0ZVJlcUJvZHl9IG11dGVSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE11dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE11dGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1tdXRlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHVibGlzaE11dGUobXV0ZVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hNdXRlKG11dGVSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTXV0ZUFwaS5wdWJsaXNoTXV0ZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NdXRlQXBpRnAgPSBNdXRlQXBpRnA7XG4vKipcbiAqIE11dGVBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBNdXRlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuTXV0ZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIG11dGUgZm9yIGEgZ2l2ZW4gRklELiBUaGlzIGlzIGFuIGFsbG93bGlzdGVkIEFQSSwgcmVhY2ggb3V0IGlmIHlvdSB3YW50IGFjY2Vzcy5cbiAgICAgICAgICogQHN1bW1hcnkgVW5tdXRlIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge011dGVBcGlEZWxldGVNdXRlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNdXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBNdXRlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1tdXRlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlTXV0ZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlTXV0ZShyZXF1ZXN0UGFyYW1ldGVycy5tdXRlUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIG11dGVkLlxuICAgICAgICAgKiBAc3VtbWFyeSBNdXRlZCBGSURzIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtNdXRlQXBpRmV0Y2hNdXRlTGlzdFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZUxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE11dGVMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW11dGUtbGlzdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoTXV0ZUxpc3QocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoTXV0ZUxpc3QocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG11dGUgZm9yIGEgZ2l2ZW4gRklELiBUaGlzIGlzIGFuIGFsbG93bGlzdGVkIEFQSSwgcmVhY2ggb3V0IGlmIHlvdSB3YW50IGFjY2Vzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTXV0ZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtNdXRlQXBpUHVibGlzaE11dGVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE11dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE11dGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1tdXRlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaE11dGUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnB1Ymxpc2hNdXRlKHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NdXRlQXBpRmFjdG9yeSA9IE11dGVBcGlGYWN0b3J5O1xuLyoqXG4gKiBNdXRlQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE11dGVBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBNdXRlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBtdXRlIGZvciBhIGdpdmVuIEZJRC4gVGhpcyBpcyBhbiBhbGxvd2xpc3RlZCBBUEksIHJlYWNoIG91dCBpZiB5b3Ugd2FudCBhY2Nlc3MuXG4gICAgICogQHN1bW1hcnkgVW5tdXRlIEZJRFxuICAgICAqIEBwYXJhbSB7TXV0ZUFwaURlbGV0ZU11dGVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNdXRlQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLW11dGUpXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVNdXRlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5NdXRlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZGVsZXRlTXV0ZShyZXF1ZXN0UGFyYW1ldGVycy5tdXRlUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIG11dGVkLlxuICAgICAqIEBzdW1tYXJ5IE11dGVkIEZJRHMgb2YgdXNlclxuICAgICAqIEBwYXJhbSB7TXV0ZUFwaUZldGNoTXV0ZUxpc3RSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNdXRlQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZUxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE11dGVMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1tdXRlLWxpc3QpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaE11dGVMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5NdXRlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hNdXRlTGlzdChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbXV0ZSBmb3IgYSBnaXZlbiBGSUQuIFRoaXMgaXMgYW4gYWxsb3dsaXN0ZWQgQVBJLCByZWFjaCBvdXQgaWYgeW91IHdhbnQgYWNjZXNzLlxuICAgICAqIEBzdW1tYXJ5IE11dGUgRklEXG4gICAgICogQHBhcmFtIHtNdXRlQXBpUHVibGlzaE11dGVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNdXRlQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TXV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1tdXRlKVxuICAgICAqXG4gICAgICovXG4gICAgcHVibGlzaE11dGUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk11dGVBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5wdWJsaXNoTXV0ZShyZXF1ZXN0UGFyYW1ldGVycy5tdXRlUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5NdXRlQXBpID0gTXV0ZUFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/mute-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/notifications-api.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/notifications-api.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotificationsApi = exports.NotificationsApiFactory = exports.NotificationsApiFp = exports.NotificationsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * NotificationsApi - axios parameter creator\n * @export\n */\nconst NotificationsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Returns a list of notifications for a specific FID.\n         * @summary For user\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {Array<NotificationType>} [type] Notification type to fetch. Comma separated values of follows, recasts, likes, mentions, replies.\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)\n         *\n         */\n        fetchAllNotifications: async (fid, type, priorityMode, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchAllNotifications', 'fid', fid);\n            const localVarPath = `/farcaster/notifications`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (type) {\n                localVarQueryParameter['type'] = type.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (priorityMode !== undefined) {\n                localVarQueryParameter['priority_mode'] = priorityMode;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of notifications for a user in specific channels\n         * @summary For user by channel\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {string} channelIds Comma separated channel_ids (find list of all channels here - https://docs.neynar.com/reference/list-all-channels)\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)\n         *\n         */\n        fetchChannelNotificationsForUser: async (fid, channelIds, priorityMode, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchChannelNotificationsForUser', 'fid', fid);\n            // verify required parameter 'channelIds' is not null or undefined\n            (0, common_1.assertParamExists)('fetchChannelNotificationsForUser', 'channelIds', channelIds);\n            const localVarPath = `/farcaster/notifications/channel`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (channelIds !== undefined) {\n                localVarQueryParameter['channel_ids'] = channelIds;\n            }\n            if (priorityMode !== undefined) {\n                localVarQueryParameter['priority_mode'] = priorityMode;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Returns a list of notifications for a user in specific parent_urls\n         * @summary For user by parent_urls\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {string} parentUrls Comma separated parent_urls\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)\n         *\n         */\n        fetchNotificationsByParentUrlForUser: async (fid, parentUrls, priorityMode, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchNotificationsByParentUrlForUser', 'fid', fid);\n            // verify required parameter 'parentUrls' is not null or undefined\n            (0, common_1.assertParamExists)('fetchNotificationsByParentUrlForUser', 'parentUrls', parentUrls);\n            const localVarPath = `/farcaster/notifications/parent_url`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (parentUrls !== undefined) {\n                localVarQueryParameter['parent_urls'] = parentUrls;\n            }\n            if (priorityMode !== undefined) {\n                localVarQueryParameter['priority_mode'] = priorityMode;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Mark notifications as seen. You can choose one of two authorization methods, either:   1. Provide a valid signer_uuid in the request body (Most common)   2. Provide a valid, signed \\\"Bearer\\\" token in the request\\'s `Authorization` header similar to the      approach described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication)\n         * @summary Mark as seen\n         * @param {MarkNotificationsAsSeenReqBody} markNotificationsAsSeenReqBody\n         * @param {string} [authorization] Optional Bearer token for certain endpoints. The token format is described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)\n         *\n         */\n        markNotificationsAsSeen: async (markNotificationsAsSeenReqBody, authorization, options = {}) => {\n            // verify required parameter 'markNotificationsAsSeenReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('markNotificationsAsSeen', 'markNotificationsAsSeenReqBody', markNotificationsAsSeenReqBody);\n            const localVarPath = `/farcaster/notifications/seen`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (authorization != null) {\n                localVarHeaderParameter['Authorization'] = String(authorization);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(markNotificationsAsSeenReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.NotificationsApiAxiosParamCreator = NotificationsApiAxiosParamCreator;\n/**\n * NotificationsApi - functional programming interface\n * @export\n */\nconst NotificationsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.NotificationsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Returns a list of notifications for a specific FID.\n         * @summary For user\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {Array<NotificationType>} [type] Notification type to fetch. Comma separated values of follows, recasts, likes, mentions, replies.\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)\n         *\n         */\n        async fetchAllNotifications(fid, type, priorityMode, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAllNotifications(fid, type, priorityMode, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationsApi.fetchAllNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of notifications for a user in specific channels\n         * @summary For user by channel\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {string} channelIds Comma separated channel_ids (find list of all channels here - https://docs.neynar.com/reference/list-all-channels)\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)\n         *\n         */\n        async fetchChannelNotificationsForUser(fid, channelIds, priorityMode, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchChannelNotificationsForUser(fid, channelIds, priorityMode, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationsApi.fetchChannelNotificationsForUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Returns a list of notifications for a user in specific parent_urls\n         * @summary For user by parent_urls\n         * @param {number} fid FID of the user you you want to fetch notifications for. The response will respect this user\\&#39;s mutes and blocks.\n         * @param {string} parentUrls Comma separated parent_urls\n         * @param {boolean} [priorityMode] When true, only returns notifications from power badge users and users that the user follows.\n         * @param {number} [limit] Number of results to fetch  (Default: 15, Maximum: 25)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)\n         *\n         */\n        async fetchNotificationsByParentUrlForUser(fid, parentUrls, priorityMode, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNotificationsByParentUrlForUser(fid, parentUrls, priorityMode, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationsApi.fetchNotificationsByParentUrlForUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Mark notifications as seen. You can choose one of two authorization methods, either:   1. Provide a valid signer_uuid in the request body (Most common)   2. Provide a valid, signed \\\"Bearer\\\" token in the request\\'s `Authorization` header similar to the      approach described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication)\n         * @summary Mark as seen\n         * @param {MarkNotificationsAsSeenReqBody} markNotificationsAsSeenReqBody\n         * @param {string} [authorization] Optional Bearer token for certain endpoints. The token format is described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication).\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)\n         *\n         */\n        async markNotificationsAsSeen(markNotificationsAsSeenReqBody, authorization, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.markNotificationsAsSeen(markNotificationsAsSeenReqBody, authorization, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationsApi.markNotificationsAsSeen']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.NotificationsApiFp = NotificationsApiFp;\n/**\n * NotificationsApi - factory interface\n * @export\n */\nconst NotificationsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.NotificationsApiFp)(configuration);\n    return {\n        /**\n         * Returns a list of notifications for a specific FID.\n         * @summary For user\n         * @param {NotificationsApiFetchAllNotificationsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)\n         *\n         */\n        fetchAllNotifications(requestParameters, options) {\n            return localVarFp.fetchAllNotifications(requestParameters.fid, requestParameters.type, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of notifications for a user in specific channels\n         * @summary For user by channel\n         * @param {NotificationsApiFetchChannelNotificationsForUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)\n         *\n         */\n        fetchChannelNotificationsForUser(requestParameters, options) {\n            return localVarFp.fetchChannelNotificationsForUser(requestParameters.fid, requestParameters.channelIds, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Returns a list of notifications for a user in specific parent_urls\n         * @summary For user by parent_urls\n         * @param {NotificationsApiFetchNotificationsByParentUrlForUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)\n         *\n         */\n        fetchNotificationsByParentUrlForUser(requestParameters, options) {\n            return localVarFp.fetchNotificationsByParentUrlForUser(requestParameters.fid, requestParameters.parentUrls, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Mark notifications as seen. You can choose one of two authorization methods, either:   1. Provide a valid signer_uuid in the request body (Most common)   2. Provide a valid, signed \\\"Bearer\\\" token in the request\\'s `Authorization` header similar to the      approach described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication)\n         * @summary Mark as seen\n         * @param {NotificationsApiMarkNotificationsAsSeenRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)\n         *\n         */\n        markNotificationsAsSeen(requestParameters, options) {\n            return localVarFp.markNotificationsAsSeen(requestParameters.markNotificationsAsSeenReqBody, requestParameters.authorization, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NotificationsApiFactory = NotificationsApiFactory;\n/**\n * NotificationsApi - object-oriented interface\n * @export\n * @class NotificationsApi\n * @extends {BaseAPI}\n */\nclass NotificationsApi extends base_1.BaseAPI {\n    /**\n     * Returns a list of notifications for a specific FID.\n     * @summary For user\n     * @param {NotificationsApiFetchAllNotificationsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotificationsApi\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)\n     *\n     */\n    fetchAllNotifications(requestParameters, options) {\n        return (0, exports.NotificationsApiFp)(this.configuration).fetchAllNotifications(requestParameters.fid, requestParameters.type, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of notifications for a user in specific channels\n     * @summary For user by channel\n     * @param {NotificationsApiFetchChannelNotificationsForUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotificationsApi\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)\n     *\n     */\n    fetchChannelNotificationsForUser(requestParameters, options) {\n        return (0, exports.NotificationsApiFp)(this.configuration).fetchChannelNotificationsForUser(requestParameters.fid, requestParameters.channelIds, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Returns a list of notifications for a user in specific parent_urls\n     * @summary For user by parent_urls\n     * @param {NotificationsApiFetchNotificationsByParentUrlForUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotificationsApi\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)\n     *\n     */\n    fetchNotificationsByParentUrlForUser(requestParameters, options) {\n        return (0, exports.NotificationsApiFp)(this.configuration).fetchNotificationsByParentUrlForUser(requestParameters.fid, requestParameters.parentUrls, requestParameters.priorityMode, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Mark notifications as seen. You can choose one of two authorization methods, either:   1. Provide a valid signer_uuid in the request body (Most common)   2. Provide a valid, signed \\\"Bearer\\\" token in the request\\'s `Authorization` header similar to the      approach described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication)\n     * @summary Mark as seen\n     * @param {NotificationsApiMarkNotificationsAsSeenRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NotificationsApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)\n     *\n     */\n    markNotificationsAsSeen(requestParameters, options) {\n        return (0, exports.NotificationsApiFp)(this.configuration).markNotificationsAsSeen(requestParameters.markNotificationsAsSeenReqBody, requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NotificationsApi = NotificationsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL25vdGlmaWNhdGlvbnMtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywrQkFBK0IsR0FBRywwQkFBMEIsR0FBRyx5Q0FBeUM7QUFDbkksZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLHNHQUFzRztBQUNqSSxtQkFBbUIseUJBQXlCO0FBQzVDLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxzR0FBc0c7QUFDakksbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFD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O0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQXlEO0FBQ3hFLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBNkQ7QUFDNUUsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFnRDtBQUMvRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL25vdGlmaWNhdGlvbnMtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpID0gZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpRmFjdG9yeSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uc0FwaUZwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBOb3RpZmljYXRpb25zQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTm90aWZpY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSBzcGVjaWZpYyBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHlvdSB5b3Ugd2FudCB0byBmZXRjaCBub3RpZmljYXRpb25zIGZvci4gVGhlIHJlc3BvbnNlIHdpbGwgcmVzcGVjdCB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vdGlmaWNhdGlvblR5cGU+fSBbdHlwZV0gTm90aWZpY2F0aW9uIHR5cGUgdG8gZmV0Y2guIENvbW1hIHNlcGFyYXRlZCB2YWx1ZXMgb2YgZm9sbG93cywgcmVjYXN0cywgbGlrZXMsIG1lbnRpb25zLCByZXBsaWVzLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmlvcml0eU1vZGVdIFdoZW4gdHJ1ZSwgb25seSByZXR1cm5zIG5vdGlmaWNhdGlvbnMgZnJvbSBwb3dlciBiYWRnZSB1c2VycyBhbmQgdXNlcnMgdGhhdCB0aGUgdXNlciBmb2xsb3dzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDE1LCBNYXhpbXVtOiAyNSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3RpZmljYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOb3RpZmljYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWFsbC1ub3RpZmljYXRpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hBbGxOb3RpZmljYXRpb25zOiBhc3luYyAoZmlkLCB0eXBlLCBwcmlvcml0eU1vZGUsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQWxsTm90aWZpY2F0aW9ucycsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvbm90aWZpY2F0aW9uc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0eXBlJ10gPSB0eXBlLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW9yaXR5TW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJpb3JpdHlfbW9kZSddID0gcHJpb3JpdHlNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlciBpbiBzcGVjaWZpYyBjaGFubmVsc1xuICAgICAgICAgKiBAc3VtbWFyeSBGb3IgdXNlciBieSBjaGFubmVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHlvdSB5b3Ugd2FudCB0byBmZXRjaCBub3RpZmljYXRpb25zIGZvci4gVGhlIHJlc3BvbnNlIHdpbGwgcmVzcGVjdCB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbElkcyBDb21tYSBzZXBhcmF0ZWQgY2hhbm5lbF9pZHMgKGZpbmQgbGlzdCBvZiBhbGwgY2hhbm5lbHMgaGVyZSAtIGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9saXN0LWFsbC1jaGFubmVscylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJpb3JpdHlNb2RlXSBXaGVuIHRydWUsIG9ubHkgcmV0dXJucyBub3RpZmljYXRpb25zIGZyb20gcG93ZXIgYmFkZ2UgdXNlcnMgYW5kIHVzZXJzIHRoYXQgdGhlIHVzZXIgZm9sbG93cy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAxNSwgTWF4aW11bTogMjUpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jaGFubmVsLW5vdGlmaWNhdGlvbnMtZm9yLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlcjogYXN5bmMgKGZpZCwgY2hhbm5lbElkcywgcHJpb3JpdHlNb2RlLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlcicsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY2hhbm5lbElkcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlcicsICdjaGFubmVsSWRzJywgY2hhbm5lbElkcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9ub3RpZmljYXRpb25zL2NoYW5uZWxgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFubmVsSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjaGFubmVsX2lkcyddID0gY2hhbm5lbElkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eU1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ByaW9yaXR5X21vZGUnXSA9IHByaW9yaXR5TW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3Vyc29yJ10gPSBjdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub3RpZmljYXRpb25zIGZvciBhIHVzZXIgaW4gc3BlY2lmaWMgcGFyZW50X3VybHNcbiAgICAgICAgICogQHN1bW1hcnkgRm9yIHVzZXIgYnkgcGFyZW50X3VybHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdGhlIHVzZXIgeW91IHlvdSB3YW50IHRvIGZldGNoIG5vdGlmaWNhdGlvbnMgZm9yLiBUaGUgcmVzcG9uc2Ugd2lsbCByZXNwZWN0IHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRVcmxzIENvbW1hIHNlcGFyYXRlZCBwYXJlbnRfdXJsc1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmlvcml0eU1vZGVdIFdoZW4gdHJ1ZSwgb25seSByZXR1cm5zIG5vdGlmaWNhdGlvbnMgZnJvbSBwb3dlciBiYWRnZSB1c2VycyBhbmQgdXNlcnMgdGhhdCB0aGUgdXNlciBmb2xsb3dzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDE1LCBNYXhpbXVtOiAyNSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3RpZmljYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOb3RpZmljYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW5vdGlmaWNhdGlvbnMtYnktcGFyZW50LXVybC1mb3ItdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcjogYXN5bmMgKGZpZCwgcGFyZW50VXJscywgcHJpb3JpdHlNb2RlLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaE5vdGlmaWNhdGlvbnNCeVBhcmVudFVybEZvclVzZXInLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3BhcmVudFVybHMnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hOb3RpZmljYXRpb25zQnlQYXJlbnRVcmxGb3JVc2VyJywgJ3BhcmVudFVybHMnLCBwYXJlbnRVcmxzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL25vdGlmaWNhdGlvbnMvcGFyZW50X3VybGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFVybHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhcmVudF91cmxzJ10gPSBwYXJlbnRVcmxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW9yaXR5TW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHJpb3JpdHlfbW9kZSddID0gcHJpb3JpdHlNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgbm90aWZpY2F0aW9ucyBhcyBzZWVuLiBZb3UgY2FuIGNob29zZSBvbmUgb2YgdHdvIGF1dGhvcml6YXRpb24gbWV0aG9kcywgZWl0aGVyOiAgIDEuIFByb3ZpZGUgYSB2YWxpZCBzaWduZXJfdXVpZCBpbiB0aGUgcmVxdWVzdCBib2R5IChNb3N0IGNvbW1vbikgICAyLiBQcm92aWRlIGEgdmFsaWQsIHNpZ25lZCBcXFwiQmVhcmVyXFxcIiB0b2tlbiBpbiB0aGUgcmVxdWVzdFxcJ3MgYEF1dGhvcml6YXRpb25gIGhlYWRlciBzaW1pbGFyIHRvIHRoZSAgICAgIGFwcHJvYWNoIGRlc2NyaWJlZCBbaGVyZV0oaHR0cHM6Ly9kb2NzLmZhcmNhc3Rlci54eXovcmVmZXJlbmNlL3dhcnBjYXN0L2FwaSNhdXRoZW50aWNhdGlvbilcbiAgICAgICAgICogQHN1bW1hcnkgTWFyayBhcyBzZWVuXG4gICAgICAgICAqIEBwYXJhbSB7TWFya05vdGlmaWNhdGlvbnNBc1NlZW5SZXFCb2R5fSBtYXJrTm90aWZpY2F0aW9uc0FzU2VlblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFthdXRob3JpemF0aW9uXSBPcHRpb25hbCBCZWFyZXIgdG9rZW4gZm9yIGNlcnRhaW4gZW5kcG9pbnRzLiBUaGUgdG9rZW4gZm9ybWF0IGlzIGRlc2NyaWJlZCBbaGVyZV0oaHR0cHM6Ly9kb2NzLmZhcmNhc3Rlci54eXovcmVmZXJlbmNlL3dhcnBjYXN0L2FwaSNhdXRoZW50aWNhdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL21hcmstbm90aWZpY2F0aW9ucy1hcy1zZWVuKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbWFya05vdGlmaWNhdGlvbnNBc1NlZW46IGFzeW5jIChtYXJrTm90aWZpY2F0aW9uc0FzU2VlblJlcUJvZHksIGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbWFya05vdGlmaWNhdGlvbnNBc1NlZW5SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ21hcmtOb3RpZmljYXRpb25zQXNTZWVuJywgJ21hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keScsIG1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9ub3RpZmljYXRpb25zL3NlZW5gO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGF1dGhvcml6YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydBdXRob3JpemF0aW9uJ10gPSBTdHJpbmcoYXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKG1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBOb3RpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE5vdGlmaWNhdGlvbnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBOb3RpZmljYXRpb25zQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub3RpZmljYXRpb25zIGZvciBhIHNwZWNpZmljIEZJRC5cbiAgICAgICAgICogQHN1bW1hcnkgRm9yIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdGhlIHVzZXIgeW91IHlvdSB3YW50IHRvIGZldGNoIG5vdGlmaWNhdGlvbnMgZm9yLiBUaGUgcmVzcG9uc2Ugd2lsbCByZXNwZWN0IHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm90aWZpY2F0aW9uVHlwZT59IFt0eXBlXSBOb3RpZmljYXRpb24gdHlwZSB0byBmZXRjaC4gQ29tbWEgc2VwYXJhdGVkIHZhbHVlcyBvZiBmb2xsb3dzLCByZWNhc3RzLCBsaWtlcywgbWVudGlvbnMsIHJlcGxpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByaW9yaXR5TW9kZV0gV2hlbiB0cnVlLCBvbmx5IHJldHVybnMgbm90aWZpY2F0aW9ucyBmcm9tIHBvd2VyIGJhZGdlIHVzZXJzIGFuZCB1c2VycyB0aGF0IHRoZSB1c2VyIGZvbGxvd3MuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMTUsIE1heGltdW06IDI1KVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYWxsLW5vdGlmaWNhdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEFsbE5vdGlmaWNhdGlvbnMoZmlkLCB0eXBlLCBwcmlvcml0eU1vZGUsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQWxsTm90aWZpY2F0aW9ucyhmaWQsIHR5cGUsIHByaW9yaXR5TW9kZSwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ05vdGlmaWNhdGlvbnNBcGkuZmV0Y2hBbGxOb3RpZmljYXRpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub3RpZmljYXRpb25zIGZvciBhIHVzZXIgaW4gc3BlY2lmaWMgY2hhbm5lbHNcbiAgICAgICAgICogQHN1bW1hcnkgRm9yIHVzZXIgYnkgY2hhbm5lbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB0aGUgdXNlciB5b3UgeW91IHdhbnQgdG8gZmV0Y2ggbm90aWZpY2F0aW9ucyBmb3IuIFRoZSByZXNwb25zZSB3aWxsIHJlc3BlY3QgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2Nrcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxJZHMgQ29tbWEgc2VwYXJhdGVkIGNoYW5uZWxfaWRzIChmaW5kIGxpc3Qgb2YgYWxsIGNoYW5uZWxzIGhlcmUgLSBodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbGlzdC1hbGwtY2hhbm5lbHMpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByaW9yaXR5TW9kZV0gV2hlbiB0cnVlLCBvbmx5IHJldHVybnMgbm90aWZpY2F0aW9ucyBmcm9tIHBvd2VyIGJhZGdlIHVzZXJzIGFuZCB1c2VycyB0aGF0IHRoZSB1c2VyIGZvbGxvd3MuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMTUsIE1heGltdW06IDI1KVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2hhbm5lbC1ub3RpZmljYXRpb25zLWZvci11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hDaGFubmVsTm90aWZpY2F0aW9uc0ZvclVzZXIoZmlkLCBjaGFubmVsSWRzLCBwcmlvcml0eU1vZGUsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2hhbm5lbE5vdGlmaWNhdGlvbnNGb3JVc2VyKGZpZCwgY2hhbm5lbElkcywgcHJpb3JpdHlNb2RlLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTm90aWZpY2F0aW9uc0FwaS5mZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlciddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyIGluIHNwZWNpZmljIHBhcmVudF91cmxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyIGJ5IHBhcmVudF91cmxzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgRklEIG9mIHRoZSB1c2VyIHlvdSB5b3Ugd2FudCB0byBmZXRjaCBub3RpZmljYXRpb25zIGZvci4gVGhlIHJlc3BvbnNlIHdpbGwgcmVzcGVjdCB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50VXJscyBDb21tYSBzZXBhcmF0ZWQgcGFyZW50X3VybHNcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcHJpb3JpdHlNb2RlXSBXaGVuIHRydWUsIG9ubHkgcmV0dXJucyBub3RpZmljYXRpb25zIGZyb20gcG93ZXIgYmFkZ2UgdXNlcnMgYW5kIHVzZXJzIHRoYXQgdGhlIHVzZXIgZm9sbG93cy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAxNSwgTWF4aW11bTogMjUpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub3RpZmljYXRpb25zLWJ5LXBhcmVudC11cmwtZm9yLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaE5vdGlmaWNhdGlvbnNCeVBhcmVudFVybEZvclVzZXIoZmlkLCBwYXJlbnRVcmxzLCBwcmlvcml0eU1vZGUsIGxpbWl0LCBjdXJzb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcihmaWQsIHBhcmVudFVybHMsIHByaW9yaXR5TW9kZSwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ05vdGlmaWNhdGlvbnNBcGkuZmV0Y2hOb3RpZmljYXRpb25zQnlQYXJlbnRVcmxGb3JVc2VyJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIG5vdGlmaWNhdGlvbnMgYXMgc2Vlbi4gWW91IGNhbiBjaG9vc2Ugb25lIG9mIHR3byBhdXRob3JpemF0aW9uIG1ldGhvZHMsIGVpdGhlcjogICAxLiBQcm92aWRlIGEgdmFsaWQgc2lnbmVyX3V1aWQgaW4gdGhlIHJlcXVlc3QgYm9keSAoTW9zdCBjb21tb24pICAgMi4gUHJvdmlkZSBhIHZhbGlkLCBzaWduZWQgXFxcIkJlYXJlclxcXCIgdG9rZW4gaW4gdGhlIHJlcXVlc3RcXCdzIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgc2ltaWxhciB0byB0aGUgICAgICBhcHByb2FjaCBkZXNjcmliZWQgW2hlcmVdKGh0dHBzOi8vZG9jcy5mYXJjYXN0ZXIueHl6L3JlZmVyZW5jZS93YXJwY2FzdC9hcGkjYXV0aGVudGljYXRpb24pXG4gICAgICAgICAqIEBzdW1tYXJ5IE1hcmsgYXMgc2VlblxuICAgICAgICAgKiBAcGFyYW0ge01hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keX0gbWFya05vdGlmaWNhdGlvbnNBc1NlZW5SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXV0aG9yaXphdGlvbl0gT3B0aW9uYWwgQmVhcmVyIHRva2VuIGZvciBjZXJ0YWluIGVuZHBvaW50cy4gVGhlIHRva2VuIGZvcm1hdCBpcyBkZXNjcmliZWQgW2hlcmVdKGh0dHBzOi8vZG9jcy5mYXJjYXN0ZXIueHl6L3JlZmVyZW5jZS93YXJwY2FzdC9hcGkjYXV0aGVudGljYXRpb24pLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9tYXJrLW5vdGlmaWNhdGlvbnMtYXMtc2VlbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIG1hcmtOb3RpZmljYXRpb25zQXNTZWVuKG1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keSwgYXV0aG9yaXphdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubWFya05vdGlmaWNhdGlvbnNBc1NlZW4obWFya05vdGlmaWNhdGlvbnNBc1NlZW5SZXFCb2R5LCBhdXRob3JpemF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTm90aWZpY2F0aW9uc0FwaS5tYXJrTm90aWZpY2F0aW9uc0FzU2VlbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpRnAgPSBOb3RpZmljYXRpb25zQXBpRnA7XG4vKipcbiAqIE5vdGlmaWNhdGlvbnNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBOb3RpZmljYXRpb25zQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuTm90aWZpY2F0aW9uc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSBzcGVjaWZpYyBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Tm90aWZpY2F0aW9uc0FwaUZldGNoQWxsTm90aWZpY2F0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hbGwtbm90aWZpY2F0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQWxsTm90aWZpY2F0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hBbGxOb3RpZmljYXRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMucHJpb3JpdHlNb2RlLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyIGluIHNwZWNpZmljIGNoYW5uZWxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyIGJ5IGNoYW5uZWxcbiAgICAgICAgICogQHBhcmFtIHtOb3RpZmljYXRpb25zQXBpRmV0Y2hDaGFubmVsTm90aWZpY2F0aW9uc0ZvclVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2hhbm5lbC1ub3RpZmljYXRpb25zLWZvci11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDaGFubmVsTm90aWZpY2F0aW9uc0ZvclVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ2hhbm5lbE5vdGlmaWNhdGlvbnNGb3JVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbElkcywgcmVxdWVzdFBhcmFtZXRlcnMucHJpb3JpdHlNb2RlLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyIGluIHNwZWNpZmljIHBhcmVudF91cmxzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyIGJ5IHBhcmVudF91cmxzXG4gICAgICAgICAqIEBwYXJhbSB7Tm90aWZpY2F0aW9uc0FwaUZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub3RpZmljYXRpb25zLWJ5LXBhcmVudC11cmwtZm9yLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaE5vdGlmaWNhdGlvbnNCeVBhcmVudFVybEZvclVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhcmVudFVybHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnByaW9yaXR5TW9kZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgbm90aWZpY2F0aW9ucyBhcyBzZWVuLiBZb3UgY2FuIGNob29zZSBvbmUgb2YgdHdvIGF1dGhvcml6YXRpb24gbWV0aG9kcywgZWl0aGVyOiAgIDEuIFByb3ZpZGUgYSB2YWxpZCBzaWduZXJfdXVpZCBpbiB0aGUgcmVxdWVzdCBib2R5IChNb3N0IGNvbW1vbikgICAyLiBQcm92aWRlIGEgdmFsaWQsIHNpZ25lZCBcXFwiQmVhcmVyXFxcIiB0b2tlbiBpbiB0aGUgcmVxdWVzdFxcJ3MgYEF1dGhvcml6YXRpb25gIGhlYWRlciBzaW1pbGFyIHRvIHRoZSAgICAgIGFwcHJvYWNoIGRlc2NyaWJlZCBbaGVyZV0oaHR0cHM6Ly9kb2NzLmZhcmNhc3Rlci54eXovcmVmZXJlbmNlL3dhcnBjYXN0L2FwaSNhdXRoZW50aWNhdGlvbilcbiAgICAgICAgICogQHN1bW1hcnkgTWFyayBhcyBzZWVuXG4gICAgICAgICAqIEBwYXJhbSB7Tm90aWZpY2F0aW9uc0FwaU1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9tYXJrLW5vdGlmaWNhdGlvbnMtYXMtc2VlbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIG1hcmtOb3RpZmljYXRpb25zQXNTZWVuKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5tYXJrTm90aWZpY2F0aW9uc0FzU2VlbihyZXF1ZXN0UGFyYW1ldGVycy5tYXJrTm90aWZpY2F0aW9uc0FzU2VlblJlcUJvZHksIHJlcXVlc3RQYXJhbWV0ZXJzLmF1dGhvcml6YXRpb24sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk5vdGlmaWNhdGlvbnNBcGlGYWN0b3J5ID0gTm90aWZpY2F0aW9uc0FwaUZhY3Rvcnk7XG4vKipcbiAqIE5vdGlmaWNhdGlvbnNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgTm90aWZpY2F0aW9uc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIE5vdGlmaWNhdGlvbnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBmb3IgYSBzcGVjaWZpYyBGSUQuXG4gICAgICogQHN1bW1hcnkgRm9yIHVzZXJcbiAgICAgKiBAcGFyYW0ge05vdGlmaWNhdGlvbnNBcGlGZXRjaEFsbE5vdGlmaWNhdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25zQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYWxsLW5vdGlmaWNhdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEFsbE5vdGlmaWNhdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk5vdGlmaWNhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEFsbE5vdGlmaWNhdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy50eXBlLCByZXF1ZXN0UGFyYW1ldGVycy5wcmlvcml0eU1vZGUsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub3RpZmljYXRpb25zIGZvciBhIHVzZXIgaW4gc3BlY2lmaWMgY2hhbm5lbHNcbiAgICAgKiBAc3VtbWFyeSBGb3IgdXNlciBieSBjaGFubmVsXG4gICAgICogQHBhcmFtIHtOb3RpZmljYXRpb25zQXBpRmV0Y2hDaGFubmVsTm90aWZpY2F0aW9uc0ZvclVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25zQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2hhbm5lbC1ub3RpZmljYXRpb25zLWZvci11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hDaGFubmVsTm90aWZpY2F0aW9uc0ZvclVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk5vdGlmaWNhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxJZHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnByaW9yaXR5TW9kZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlciBpbiBzcGVjaWZpYyBwYXJlbnRfdXJsc1xuICAgICAqIEBzdW1tYXJ5IEZvciB1c2VyIGJ5IHBhcmVudF91cmxzXG4gICAgICogQHBhcmFtIHtOb3RpZmljYXRpb25zQXBpRmV0Y2hOb3RpZmljYXRpb25zQnlQYXJlbnRVcmxGb3JVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLW5vdGlmaWNhdGlvbnMtYnktcGFyZW50LXVybC1mb3ItdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTm90aWZpY2F0aW9uc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhcmVudFVybHMsIHJlcXVlc3RQYXJhbWV0ZXJzLnByaW9yaXR5TW9kZSwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgbm90aWZpY2F0aW9ucyBhcyBzZWVuLiBZb3UgY2FuIGNob29zZSBvbmUgb2YgdHdvIGF1dGhvcml6YXRpb24gbWV0aG9kcywgZWl0aGVyOiAgIDEuIFByb3ZpZGUgYSB2YWxpZCBzaWduZXJfdXVpZCBpbiB0aGUgcmVxdWVzdCBib2R5IChNb3N0IGNvbW1vbikgICAyLiBQcm92aWRlIGEgdmFsaWQsIHNpZ25lZCBcXFwiQmVhcmVyXFxcIiB0b2tlbiBpbiB0aGUgcmVxdWVzdFxcJ3MgYEF1dGhvcml6YXRpb25gIGhlYWRlciBzaW1pbGFyIHRvIHRoZSAgICAgIGFwcHJvYWNoIGRlc2NyaWJlZCBbaGVyZV0oaHR0cHM6Ly9kb2NzLmZhcmNhc3Rlci54eXovcmVmZXJlbmNlL3dhcnBjYXN0L2FwaSNhdXRoZW50aWNhdGlvbilcbiAgICAgKiBAc3VtbWFyeSBNYXJrIGFzIHNlZW5cbiAgICAgKiBAcGFyYW0ge05vdGlmaWNhdGlvbnNBcGlNYXJrTm90aWZpY2F0aW9uc0FzU2VlblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvbnNBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbWFyay1ub3RpZmljYXRpb25zLWFzLXNlZW4pXG4gICAgICpcbiAgICAgKi9cbiAgICBtYXJrTm90aWZpY2F0aW9uc0FzU2VlbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTm90aWZpY2F0aW9uc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLm1hcmtOb3RpZmljYXRpb25zQXNTZWVuKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keSwgcmVxdWVzdFBhcmFtZXRlcnMuYXV0aG9yaXphdGlvbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25zQXBpID0gTm90aWZpY2F0aW9uc0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/notifications-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/onchain-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/onchain-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DeployFungibleFactoryEnum = exports.DeployFungibleNetworkEnum = exports.DeployFungibleMetadataNsfwEnum = exports.OnchainApi = exports.OnchainApiFactory = exports.OnchainApiFp = exports.OnchainApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * OnchainApi - axios parameter creator\n * @export\n */\nconst OnchainApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Creates a new token.\n         * @summary Deploy fungible\n         * @param {string} owner Ethereum address of the one who is creating the token\n         * @param {string} symbol Symbol/Ticker for the token\n         * @param {string} name Name of the token\n         * @param {File} [metadataMedia] Media file associated with the token.  Supported formats are image/jpeg, image/gif and image/png\n         * @param {string} [metadataDescription] Description of the token\n         * @param {DeployFungibleMetadataNsfwEnum} [metadataNsfw] Indicates if the token is NSFW (Not Safe For Work).\n         * @param {string} [metadataWebsiteLink] Website link related to the token\n         * @param {string} [metadataTwitter] Twitter profile link\n         * @param {string} [metadataDiscord] Discord server link\n         * @param {string} [metadataTelegram] Telegram link\n         * @param {DeployFungibleNetworkEnum} [network] Network/Chain name\n         * @param {DeployFungibleFactoryEnum} [factory] Factory name - wow -&gt; [wow.xyz](https://wow.xyz) - clanker -&gt; [clanker.world](https://www.clanker.world)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)\n         *\n         */\n        deployFungible: async (owner, symbol, name, metadataMedia, metadataDescription, metadataNsfw, metadataWebsiteLink, metadataTwitter, metadataDiscord, metadataTelegram, network, factory, options = {}) => {\n            // verify required parameter 'owner' is not null or undefined\n            (0, common_1.assertParamExists)('deployFungible', 'owner', owner);\n            // verify required parameter 'symbol' is not null or undefined\n            (0, common_1.assertParamExists)('deployFungible', 'symbol', symbol);\n            // verify required parameter 'name' is not null or undefined\n            (0, common_1.assertParamExists)('deployFungible', 'name', name);\n            const localVarPath = `/fungible`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (owner !== undefined) {\n                localVarFormParams.append('owner', owner);\n            }\n            if (symbol !== undefined) {\n                localVarFormParams.append('symbol', symbol);\n            }\n            if (name !== undefined) {\n                localVarFormParams.append('name', name);\n            }\n            if (metadataMedia !== undefined) {\n                localVarFormParams.append('metadata[media]', metadataMedia);\n            }\n            if (metadataDescription !== undefined) {\n                localVarFormParams.append('metadata[description]', metadataDescription);\n            }\n            if (metadataNsfw !== undefined) {\n                localVarFormParams.append('metadata[nsfw]', metadataNsfw);\n            }\n            if (metadataWebsiteLink !== undefined) {\n                localVarFormParams.append('metadata[website_link]', metadataWebsiteLink);\n            }\n            if (metadataTwitter !== undefined) {\n                localVarFormParams.append('metadata[twitter]', metadataTwitter);\n            }\n            if (metadataDiscord !== undefined) {\n                localVarFormParams.append('metadata[discord]', metadataDiscord);\n            }\n            if (metadataTelegram !== undefined) {\n                localVarFormParams.append('metadata[telegram]', metadataTelegram);\n            }\n            if (network !== undefined) {\n                localVarFormParams.append('network', network);\n            }\n            if (factory !== undefined) {\n                localVarFormParams.append('factory', factory);\n            }\n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = localVarFormParams;\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \\\"X, Y, Z and N others you know own this asset\\\".\n         * @summary Relevant owners\n         * @param {string} contractAddress Contract address of the fungible asset\n         * @param {FungibleOwnerRelevantNetwork} network Network of the fungible asset.\n         * @param {number} [viewerFid] If you provide a viewer_fid, the response will include token holders from the user\\&#39;s network, respecting their mutes and blocks and including viewer_context; if not provided, the response will show top token holders across the network—both sets can be combined to generate a longer list if desired.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)\n         *\n         */\n        fetchRelevantFungibleOwners: async (contractAddress, network, viewerFid, options = {}) => {\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFungibleOwners', 'contractAddress', contractAddress);\n            // verify required parameter 'network' is not null or undefined\n            (0, common_1.assertParamExists)('fetchRelevantFungibleOwners', 'network', network);\n            const localVarPath = `/farcaster/fungible/owner/relevant`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (contractAddress !== undefined) {\n                localVarQueryParameter['contract_address'] = contractAddress;\n            }\n            if (network !== undefined) {\n                localVarQueryParameter['network'] = network;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches the token balances of a user given their FID\n         * @summary Token balance\n         * @param {number} fid FID of the user to fetch\n         * @param {Array<Network>} networks Comma separated list of networks to fetch balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)\n         *\n         */\n        fetchUserBalance: async (fid, networks, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserBalance', 'fid', fid);\n            // verify required parameter 'networks' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserBalance', 'networks', networks);\n            const localVarPath = `/farcaster/user/balance`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (networks) {\n                localVarQueryParameter['networks'] = networks.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Register a new farcaster account onchain. Optionally you can pass in signers along to register a new account and create multiple signers in a single transaction\n         * @summary Register Farcaster account onchain\n         * @param {RegisterUserOnChainReqBody} registerUserOnChainReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserOnChainResponse>} A promise that resolves to a `RegisterUserOnChainResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account-onchain)\n         *\n         */\n        registerAccountOnchain: async (registerUserOnChainReqBody, options = {}) => {\n            // verify required parameter 'registerUserOnChainReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('registerAccountOnchain', 'registerUserOnChainReqBody', registerUserOnChainReqBody);\n            const localVarPath = `/farcaster/user/register`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerUserOnChainReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Send fungibles in bulk to several farcaster users. A funded wallet is to required use this API. React out to us on the Neynar channel on farcaster to get your wallet address.\n         * @summary Send fungibles\n         * @param {string} xWalletId Wallet ID to use for transactions\n         * @param {TransactionSendFungiblesRequest} transactionSendFungiblesRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionSendFungiblesResponse>} A promise that resolves to a `TransactionSendFungiblesResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/send-fungibles-to-users)\n         *\n         */\n        sendFungiblesToUsers: async (xWalletId, transactionSendFungiblesRequest, options = {}) => {\n            // verify required parameter 'xWalletId' is not null or undefined\n            (0, common_1.assertParamExists)('sendFungiblesToUsers', 'xWalletId', xWalletId);\n            // verify required parameter 'transactionSendFungiblesRequest' is not null or undefined\n            (0, common_1.assertParamExists)('sendFungiblesToUsers', 'transactionSendFungiblesRequest', transactionSendFungiblesRequest);\n            const localVarPath = `/farcaster/fungible/send`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (xWalletId != null) {\n                localVarHeaderParameter['x-wallet-id'] = String(xWalletId);\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transactionSendFungiblesRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.OnchainApiAxiosParamCreator = OnchainApiAxiosParamCreator;\n/**\n * OnchainApi - functional programming interface\n * @export\n */\nconst OnchainApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.OnchainApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Creates a new token.\n         * @summary Deploy fungible\n         * @param {string} owner Ethereum address of the one who is creating the token\n         * @param {string} symbol Symbol/Ticker for the token\n         * @param {string} name Name of the token\n         * @param {File} [metadataMedia] Media file associated with the token.  Supported formats are image/jpeg, image/gif and image/png\n         * @param {string} [metadataDescription] Description of the token\n         * @param {DeployFungibleMetadataNsfwEnum} [metadataNsfw] Indicates if the token is NSFW (Not Safe For Work).\n         * @param {string} [metadataWebsiteLink] Website link related to the token\n         * @param {string} [metadataTwitter] Twitter profile link\n         * @param {string} [metadataDiscord] Discord server link\n         * @param {string} [metadataTelegram] Telegram link\n         * @param {DeployFungibleNetworkEnum} [network] Network/Chain name\n         * @param {DeployFungibleFactoryEnum} [factory] Factory name - wow -&gt; [wow.xyz](https://wow.xyz) - clanker -&gt; [clanker.world](https://www.clanker.world)\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)\n         *\n         */\n        async deployFungible(owner, symbol, name, metadataMedia, metadataDescription, metadataNsfw, metadataWebsiteLink, metadataTwitter, metadataDiscord, metadataTelegram, network, factory, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deployFungible(owner, symbol, name, metadataMedia, metadataDescription, metadataNsfw, metadataWebsiteLink, metadataTwitter, metadataDiscord, metadataTelegram, network, factory, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnchainApi.deployFungible']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \\\"X, Y, Z and N others you know own this asset\\\".\n         * @summary Relevant owners\n         * @param {string} contractAddress Contract address of the fungible asset\n         * @param {FungibleOwnerRelevantNetwork} network Network of the fungible asset.\n         * @param {number} [viewerFid] If you provide a viewer_fid, the response will include token holders from the user\\&#39;s network, respecting their mutes and blocks and including viewer_context; if not provided, the response will show top token holders across the network—both sets can be combined to generate a longer list if desired.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)\n         *\n         */\n        async fetchRelevantFungibleOwners(contractAddress, network, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFungibleOwners(contractAddress, network, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnchainApi.fetchRelevantFungibleOwners']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches the token balances of a user given their FID\n         * @summary Token balance\n         * @param {number} fid FID of the user to fetch\n         * @param {Array<Network>} networks Comma separated list of networks to fetch balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)\n         *\n         */\n        async fetchUserBalance(fid, networks, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserBalance(fid, networks, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnchainApi.fetchUserBalance']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Register a new farcaster account onchain. Optionally you can pass in signers along to register a new account and create multiple signers in a single transaction\n         * @summary Register Farcaster account onchain\n         * @param {RegisterUserOnChainReqBody} registerUserOnChainReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserOnChainResponse>} A promise that resolves to a `RegisterUserOnChainResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account-onchain)\n         *\n         */\n        async registerAccountOnchain(registerUserOnChainReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAccountOnchain(registerUserOnChainReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnchainApi.registerAccountOnchain']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Send fungibles in bulk to several farcaster users. A funded wallet is to required use this API. React out to us on the Neynar channel on farcaster to get your wallet address.\n         * @summary Send fungibles\n         * @param {string} xWalletId Wallet ID to use for transactions\n         * @param {TransactionSendFungiblesRequest} transactionSendFungiblesRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionSendFungiblesResponse>} A promise that resolves to a `TransactionSendFungiblesResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/send-fungibles-to-users)\n         *\n         */\n        async sendFungiblesToUsers(xWalletId, transactionSendFungiblesRequest, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFungiblesToUsers(xWalletId, transactionSendFungiblesRequest, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnchainApi.sendFungiblesToUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.OnchainApiFp = OnchainApiFp;\n/**\n * OnchainApi - factory interface\n * @export\n */\nconst OnchainApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.OnchainApiFp)(configuration);\n    return {\n        /**\n         * Creates a new token.\n         * @summary Deploy fungible\n         * @param {OnchainApiDeployFungibleRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)\n         *\n         */\n        deployFungible(requestParameters, options) {\n            return localVarFp.deployFungible(requestParameters.owner, requestParameters.symbol, requestParameters.name, requestParameters.metadataMedia, requestParameters.metadataDescription, requestParameters.metadataNsfw, requestParameters.metadataWebsiteLink, requestParameters.metadataTwitter, requestParameters.metadataDiscord, requestParameters.metadataTelegram, requestParameters.network, requestParameters.factory, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \\\"X, Y, Z and N others you know own this asset\\\".\n         * @summary Relevant owners\n         * @param {OnchainApiFetchRelevantFungibleOwnersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)\n         *\n         */\n        fetchRelevantFungibleOwners(requestParameters, options) {\n            return localVarFp.fetchRelevantFungibleOwners(requestParameters.contractAddress, requestParameters.network, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches the token balances of a user given their FID\n         * @summary Token balance\n         * @param {OnchainApiFetchUserBalanceRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)\n         *\n         */\n        fetchUserBalance(requestParameters, options) {\n            return localVarFp.fetchUserBalance(requestParameters.fid, requestParameters.networks, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Register a new farcaster account onchain. Optionally you can pass in signers along to register a new account and create multiple signers in a single transaction\n         * @summary Register Farcaster account onchain\n         * @param {OnchainApiRegisterAccountOnchainRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserOnChainResponse>} A promise that resolves to a `RegisterUserOnChainResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account-onchain)\n         *\n         */\n        registerAccountOnchain(requestParameters, options) {\n            return localVarFp.registerAccountOnchain(requestParameters.registerUserOnChainReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Send fungibles in bulk to several farcaster users. A funded wallet is to required use this API. React out to us on the Neynar channel on farcaster to get your wallet address.\n         * @summary Send fungibles\n         * @param {OnchainApiSendFungiblesToUsersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<TransactionSendFungiblesResponse>} A promise that resolves to a `TransactionSendFungiblesResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/send-fungibles-to-users)\n         *\n         */\n        sendFungiblesToUsers(requestParameters, options) {\n            return localVarFp.sendFungiblesToUsers(requestParameters.xWalletId, requestParameters.transactionSendFungiblesRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OnchainApiFactory = OnchainApiFactory;\n/**\n * OnchainApi - object-oriented interface\n * @export\n * @class OnchainApi\n * @extends {BaseAPI}\n */\nclass OnchainApi extends base_1.BaseAPI {\n    /**\n     * Creates a new token.\n     * @summary Deploy fungible\n     * @param {OnchainApiDeployFungibleRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainApi\n     * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)\n     *\n     */\n    deployFungible(requestParameters, options) {\n        return (0, exports.OnchainApiFp)(this.configuration).deployFungible(requestParameters.owner, requestParameters.symbol, requestParameters.name, requestParameters.metadataMedia, requestParameters.metadataDescription, requestParameters.metadataNsfw, requestParameters.metadataWebsiteLink, requestParameters.metadataTwitter, requestParameters.metadataDiscord, requestParameters.metadataTelegram, requestParameters.network, requestParameters.factory, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \\\"X, Y, Z and N others you know own this asset\\\".\n     * @summary Relevant owners\n     * @param {OnchainApiFetchRelevantFungibleOwnersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainApi\n     * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)\n     *\n     */\n    fetchRelevantFungibleOwners(requestParameters, options) {\n        return (0, exports.OnchainApiFp)(this.configuration).fetchRelevantFungibleOwners(requestParameters.contractAddress, requestParameters.network, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches the token balances of a user given their FID\n     * @summary Token balance\n     * @param {OnchainApiFetchUserBalanceRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainApi\n     * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)\n     *\n     */\n    fetchUserBalance(requestParameters, options) {\n        return (0, exports.OnchainApiFp)(this.configuration).fetchUserBalance(requestParameters.fid, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Register a new farcaster account onchain. Optionally you can pass in signers along to register a new account and create multiple signers in a single transaction\n     * @summary Register Farcaster account onchain\n     * @param {OnchainApiRegisterAccountOnchainRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainApi\n     * @returns {Promise<RegisterUserOnChainResponse>} A promise that resolves to a `RegisterUserOnChainResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account-onchain)\n     *\n     */\n    registerAccountOnchain(requestParameters, options) {\n        return (0, exports.OnchainApiFp)(this.configuration).registerAccountOnchain(requestParameters.registerUserOnChainReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Send fungibles in bulk to several farcaster users. A funded wallet is to required use this API. React out to us on the Neynar channel on farcaster to get your wallet address.\n     * @summary Send fungibles\n     * @param {OnchainApiSendFungiblesToUsersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainApi\n     * @returns {Promise<TransactionSendFungiblesResponse>} A promise that resolves to a `TransactionSendFungiblesResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/send-fungibles-to-users)\n     *\n     */\n    sendFungiblesToUsers(requestParameters, options) {\n        return (0, exports.OnchainApiFp)(this.configuration).sendFungiblesToUsers(requestParameters.xWalletId, requestParameters.transactionSendFungiblesRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OnchainApi = OnchainApi;\n/**\n * @export\n */\nexports.DeployFungibleMetadataNsfwEnum = {\n    True: 'true',\n    False: 'false'\n};\n/**\n * @export\n */\nexports.DeployFungibleNetworkEnum = {\n    Base: 'base'\n};\n/**\n * @export\n */\nexports.DeployFungibleFactoryEnum = {\n    Wow: 'wow',\n    Clanker: 'clanker'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL29uY2hhaW4tYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDNU4sZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixNQUFNO0FBQ3pCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsMkJBQTJCLG1DQUFtQywyQ0FBMkM7QUFDNUgsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2TUFBNk07QUFDN007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q2xELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixzQ0FBc0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvYXBpL2FwaXMvb25jaGFpbi1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlcGxveUZ1bmdpYmxlRmFjdG9yeUVudW0gPSBleHBvcnRzLkRlcGxveUZ1bmdpYmxlTmV0d29ya0VudW0gPSBleHBvcnRzLkRlcGxveUZ1bmdpYmxlTWV0YWRhdGFOc2Z3RW51bSA9IGV4cG9ydHMuT25jaGFpbkFwaSA9IGV4cG9ydHMuT25jaGFpbkFwaUZhY3RvcnkgPSBleHBvcnRzLk9uY2hhaW5BcGlGcCA9IGV4cG9ydHMuT25jaGFpbkFwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogT25jaGFpbkFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uY2hhaW5BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBmdW5naWJsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXIgRXRoZXJldW0gYWRkcmVzcyBvZiB0aGUgb25lIHdobyBpcyBjcmVhdGluZyB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBTeW1ib2wvVGlja2VyIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBbbWV0YWRhdGFNZWRpYV0gTWVkaWEgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHRva2VuLiAgU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGltYWdlL2pwZWcsIGltYWdlL2dpZiBhbmQgaW1hZ2UvcG5nXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFEZXNjcmlwdGlvbl0gRGVzY3JpcHRpb24gb2YgdGhlIHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95RnVuZ2libGVNZXRhZGF0YU5zZndFbnVtfSBbbWV0YWRhdGFOc2Z3XSBJbmRpY2F0ZXMgaWYgdGhlIHRva2VuIGlzIE5TRlcgKE5vdCBTYWZlIEZvciBXb3JrKS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YVdlYnNpdGVMaW5rXSBXZWJzaXRlIGxpbmsgcmVsYXRlZCB0byB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YVR3aXR0ZXJdIFR3aXR0ZXIgcHJvZmlsZSBsaW5rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFEaXNjb3JkXSBEaXNjb3JkIHNlcnZlciBsaW5rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFUZWxlZ3JhbV0gVGVsZWdyYW0gbGlua1xuICAgICAgICAgKiBAcGFyYW0ge0RlcGxveUZ1bmdpYmxlTmV0d29ya0VudW19IFtuZXR3b3JrXSBOZXR3b3JrL0NoYWluIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtEZXBsb3lGdW5naWJsZUZhY3RvcnlFbnVtfSBbZmFjdG9yeV0gRmFjdG9yeSBuYW1lIC0gd293IC0mZ3Q7IFt3b3cueHl6XShodHRwczovL3dvdy54eXopIC0gY2xhbmtlciAtJmd0OyBbY2xhbmtlci53b3JsZF0oaHR0cHM6Ly93d3cuY2xhbmtlci53b3JsZClcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVwbG95RnVuZ2libGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlcGxveUZ1bmdpYmxlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlcGxveS1mdW5naWJsZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlcGxveUZ1bmdpYmxlOiBhc3luYyAob3duZXIsIHN5bWJvbCwgbmFtZSwgbWV0YWRhdGFNZWRpYSwgbWV0YWRhdGFEZXNjcmlwdGlvbiwgbWV0YWRhdGFOc2Z3LCBtZXRhZGF0YVdlYnNpdGVMaW5rLCBtZXRhZGF0YVR3aXR0ZXIsIG1ldGFkYXRhRGlzY29yZCwgbWV0YWRhdGFUZWxlZ3JhbSwgbmV0d29yaywgZmFjdG9yeSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdvd25lcicgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lGdW5naWJsZScsICdvd25lcicsIG93bmVyKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N5bWJvbCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lGdW5naWJsZScsICdzeW1ib2wnLCBzeW1ib2wpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lGdW5naWJsZScsICduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2Z1bmdpYmxlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckZvcm1QYXJhbXMgPSBuZXcgKChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uZm9ybURhdGFDdG9yKSB8fCBGb3JtRGF0YSkoKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKG93bmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdvd25lcicsIG93bmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzeW1ib2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ3N5bWJvbCcsIHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJGb3JtUGFyYW1zLmFwcGVuZCgnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhTWVkaWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ21ldGFkYXRhW21lZGlhXScsIG1ldGFkYXRhTWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhRGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ21ldGFkYXRhW2Rlc2NyaXB0aW9uXScsIG1ldGFkYXRhRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhTnNmdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJGb3JtUGFyYW1zLmFwcGVuZCgnbWV0YWRhdGFbbnNmd10nLCBtZXRhZGF0YU5zZncpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhV2Vic2l0ZUxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ21ldGFkYXRhW3dlYnNpdGVfbGlua10nLCBtZXRhZGF0YVdlYnNpdGVMaW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVR3aXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ21ldGFkYXRhW3R3aXR0ZXJdJywgbWV0YWRhdGFUd2l0dGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YURpc2NvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyRm9ybVBhcmFtcy5hcHBlbmQoJ21ldGFkYXRhW2Rpc2NvcmRdJywgbWV0YWRhdGFEaXNjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVRlbGVncmFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCdtZXRhZGF0YVt0ZWxlZ3JhbV0nLCBtZXRhZGF0YVRlbGVncmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXR3b3JrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckZvcm1QYXJhbXMuYXBwZW5kKCduZXR3b3JrJywgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmFjdG9yeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJGb3JtUGFyYW1zLmFwcGVuZCgnZmFjdG9yeScsIGZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ211bHRpcGFydC9mb3JtLWRhdGEnO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBsb2NhbFZhckZvcm1QYXJhbXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHJlbGV2YW50IG93bmVycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGZ1bmdpYmxlIGFzc2V0IHBhZ2UgYXMgXFxcIlgsIFksIFogYW5kIE4gb3RoZXJzIHlvdSBrbm93IG93biB0aGlzIGFzc2V0XFxcIi5cbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgb3duZXJzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGUgZnVuZ2libGUgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtGdW5naWJsZU93bmVyUmVsZXZhbnROZXR3b3JrfSBuZXR3b3JrIE5ldHdvcmsgb2YgdGhlIGZ1bmdpYmxlIGFzc2V0LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gSWYgeW91IHByb3ZpZGUgYSB2aWV3ZXJfZmlkLCB0aGUgcmVzcG9uc2Ugd2lsbCBpbmNsdWRlIHRva2VuIGhvbGRlcnMgZnJvbSB0aGUgdXNlclxcJiMzOTtzIG5ldHdvcmssIHJlc3BlY3RpbmcgdGhlaXIgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkaW5nIHZpZXdlcl9jb250ZXh0OyBpZiBub3QgcHJvdmlkZWQsIHRoZSByZXNwb25zZSB3aWxsIHNob3cgdG9wIHRva2VuIGhvbGRlcnMgYWNyb3NzIHRoZSBuZXR3b3Jr4oCUYm90aCBzZXRzIGNhbiBiZSBjb21iaW5lZCB0byBnZW5lcmF0ZSBhIGxvbmdlciBsaXN0IGlmIGRlc2lyZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbGV2YW50RnVuZ2libGVPd25lcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50RnVuZ2libGVPd25lcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZnVuZ2libGUtb3duZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hSZWxldmFudEZ1bmdpYmxlT3duZXJzOiBhc3luYyAoY29udHJhY3RBZGRyZXNzLCBuZXR3b3JrLCB2aWV3ZXJGaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVycycsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29yaycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFJlbGV2YW50RnVuZ2libGVPd25lcnMnLCAnbmV0d29yaycsIG5ldHdvcmspO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnVuZ2libGUvb3duZXIvcmVsZXZhbnRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoY29udHJhY3RBZGRyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjb250cmFjdF9hZGRyZXNzJ10gPSBjb250cmFjdEFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV0d29yayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbmV0d29yayddID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgdGhlIHRva2VuIGJhbGFuY2VzIG9mIGEgdXNlciBnaXZlbiB0aGVpciBGSURcbiAgICAgICAgICogQHN1bW1hcnkgVG9rZW4gYmFsYW5jZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIEZJRCBvZiB0aGUgdXNlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5ldHdvcms+fSBuZXR3b3JrcyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBuZXR3b3JrcyB0byBmZXRjaCBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QmFsYW5jZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFsYW5jZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWJhbGFuY2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJCYWxhbmNlOiBhc3luYyAoZmlkLCBuZXR3b3Jrcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyQmFsYW5jZScsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyQmFsYW5jZScsICduZXR3b3JrcycsIG5ldHdvcmtzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvYmFsYW5jZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ldHdvcmtzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbmV0d29ya3MnXSA9IG5ldHdvcmtzLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBuZXcgZmFyY2FzdGVyIGFjY291bnQgb25jaGFpbi4gT3B0aW9uYWxseSB5b3UgY2FuIHBhc3MgaW4gc2lnbmVycyBhbG9uZyB0byByZWdpc3RlciBhIG5ldyBhY2NvdW50IGFuZCBjcmVhdGUgbXVsdGlwbGUgc2lnbmVycyBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBGYXJjYXN0ZXIgYWNjb3VudCBvbmNoYWluXG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHl9IHJlZ2lzdGVyVXNlck9uQ2hhaW5SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZ2lzdGVyVXNlck9uQ2hhaW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlZ2lzdGVyVXNlck9uQ2hhaW5SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItYWNjb3VudC1vbmNoYWluKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJBY2NvdW50T25jaGFpbjogYXN5bmMgKHJlZ2lzdGVyVXNlck9uQ2hhaW5SZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3JlZ2lzdGVyVXNlck9uQ2hhaW5SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlZ2lzdGVyQWNjb3VudE9uY2hhaW4nLCAncmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHknLCByZWdpc3RlclVzZXJPbkNoYWluUmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL3JlZ2lzdGVyYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkocmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgZnVuZ2libGVzIGluIGJ1bGsgdG8gc2V2ZXJhbCBmYXJjYXN0ZXIgdXNlcnMuIEEgZnVuZGVkIHdhbGxldCBpcyB0byByZXF1aXJlZCB1c2UgdGhpcyBBUEkuIFJlYWN0IG91dCB0byB1cyBvbiB0aGUgTmV5bmFyIGNoYW5uZWwgb24gZmFyY2FzdGVyIHRvIGdldCB5b3VyIHdhbGxldCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBTZW5kIGZ1bmdpYmxlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30geFdhbGxldElkIFdhbGxldCBJRCB0byB1c2UgZm9yIHRyYW5zYWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3R9IHRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VuZC1mdW5naWJsZXMtdG8tdXNlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBzZW5kRnVuZ2libGVzVG9Vc2VyczogYXN5bmMgKHhXYWxsZXRJZCwgdHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd4V2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnc2VuZEZ1bmdpYmxlc1RvVXNlcnMnLCAneFdhbGxldElkJywgeFdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnc2VuZEZ1bmdpYmxlc1RvVXNlcnMnLCAndHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdCcsIHRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvZnVuZ2libGUvc2VuZGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoeFdhbGxldElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC13YWxsZXQtaWQnXSA9IFN0cmluZyh4V2FsbGV0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKSh0cmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk9uY2hhaW5BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IE9uY2hhaW5BcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogT25jaGFpbkFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uY2hhaW5BcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLk9uY2hhaW5BcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBmdW5naWJsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3duZXIgRXRoZXJldW0gYWRkcmVzcyBvZiB0aGUgb25lIHdobyBpcyBjcmVhdGluZyB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBTeW1ib2wvVGlja2VyIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBbbWV0YWRhdGFNZWRpYV0gTWVkaWEgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHRva2VuLiAgU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGltYWdlL2pwZWcsIGltYWdlL2dpZiBhbmQgaW1hZ2UvcG5nXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFEZXNjcmlwdGlvbl0gRGVzY3JpcHRpb24gb2YgdGhlIHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95RnVuZ2libGVNZXRhZGF0YU5zZndFbnVtfSBbbWV0YWRhdGFOc2Z3XSBJbmRpY2F0ZXMgaWYgdGhlIHRva2VuIGlzIE5TRlcgKE5vdCBTYWZlIEZvciBXb3JrKS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YVdlYnNpdGVMaW5rXSBXZWJzaXRlIGxpbmsgcmVsYXRlZCB0byB0aGUgdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRhZGF0YVR3aXR0ZXJdIFR3aXR0ZXIgcHJvZmlsZSBsaW5rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFEaXNjb3JkXSBEaXNjb3JkIHNlcnZlciBsaW5rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0YWRhdGFUZWxlZ3JhbV0gVGVsZWdyYW0gbGlua1xuICAgICAgICAgKiBAcGFyYW0ge0RlcGxveUZ1bmdpYmxlTmV0d29ya0VudW19IFtuZXR3b3JrXSBOZXR3b3JrL0NoYWluIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtEZXBsb3lGdW5naWJsZUZhY3RvcnlFbnVtfSBbZmFjdG9yeV0gRmFjdG9yeSBuYW1lIC0gd293IC0mZ3Q7IFt3b3cueHl6XShodHRwczovL3dvdy54eXopIC0gY2xhbmtlciAtJmd0OyBbY2xhbmtlci53b3JsZF0oaHR0cHM6Ly93d3cuY2xhbmtlci53b3JsZClcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVwbG95RnVuZ2libGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlcGxveUZ1bmdpYmxlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlcGxveS1mdW5naWJsZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlcGxveUZ1bmdpYmxlKG93bmVyLCBzeW1ib2wsIG5hbWUsIG1ldGFkYXRhTWVkaWEsIG1ldGFkYXRhRGVzY3JpcHRpb24sIG1ldGFkYXRhTnNmdywgbWV0YWRhdGFXZWJzaXRlTGluaywgbWV0YWRhdGFUd2l0dGVyLCBtZXRhZGF0YURpc2NvcmQsIG1ldGFkYXRhVGVsZWdyYW0sIG5ldHdvcmssIGZhY3RvcnksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlcGxveUZ1bmdpYmxlKG93bmVyLCBzeW1ib2wsIG5hbWUsIG1ldGFkYXRhTWVkaWEsIG1ldGFkYXRhRGVzY3JpcHRpb24sIG1ldGFkYXRhTnNmdywgbWV0YWRhdGFXZWJzaXRlTGluaywgbWV0YWRhdGFUd2l0dGVyLCBtZXRhZGF0YURpc2NvcmQsIG1ldGFkYXRhVGVsZWdyYW0sIG5ldHdvcmssIGZhY3RvcnksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydPbmNoYWluQXBpLmRlcGxveUZ1bmdpYmxlJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgcmVsZXZhbnQgb3duZXJzIGZvciBhIHNwZWNpZmljIEZJRC4gVGhpcyB1c3VhbGx5IHNob3dzIG9uIGEgZnVuZ2libGUgYXNzZXQgcGFnZSBhcyBcXFwiWCwgWSwgWiBhbmQgTiBvdGhlcnMgeW91IGtub3cgb3duIHRoaXMgYXNzZXRcXFwiLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWxldmFudCBvd25lcnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoZSBmdW5naWJsZSBhc3NldFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmdpYmxlT3duZXJSZWxldmFudE5ldHdvcmt9IG5ldHdvcmsgTmV0d29yayBvZiB0aGUgZnVuZ2libGUgYXNzZXQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBJZiB5b3UgcHJvdmlkZSBhIHZpZXdlcl9maWQsIHRoZSByZXNwb25zZSB3aWxsIGluY2x1ZGUgdG9rZW4gaG9sZGVycyBmcm9tIHRoZSB1c2VyXFwmIzM5O3MgbmV0d29yaywgcmVzcGVjdGluZyB0aGVpciBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRpbmcgdmlld2VyX2NvbnRleHQ7IGlmIG5vdCBwcm92aWRlZCwgdGhlIHJlc3BvbnNlIHdpbGwgc2hvdyB0b3AgdG9rZW4gaG9sZGVycyBhY3Jvc3MgdGhlIG5ldHdvcmvigJRib3RoIHNldHMgY2FuIGJlIGNvbWJpbmVkIHRvIGdlbmVyYXRlIGEgbG9uZ2VyIGxpc3QgaWYgZGVzaXJlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1yZWxldmFudC1mdW5naWJsZS1vd25lcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFJlbGV2YW50RnVuZ2libGVPd25lcnMoY29udHJhY3RBZGRyZXNzLCBuZXR3b3JrLCB2aWV3ZXJGaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVycyhjb250cmFjdEFkZHJlc3MsIG5ldHdvcmssIHZpZXdlckZpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ09uY2hhaW5BcGkuZmV0Y2hSZWxldmFudEZ1bmdpYmxlT3duZXJzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHRoZSB0b2tlbiBiYWxhbmNlcyBvZiBhIHVzZXIgZ2l2ZW4gdGhlaXIgRklEXG4gICAgICAgICAqIEBzdW1tYXJ5IFRva2VuIGJhbGFuY2VcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBGSUQgb2YgdGhlIHVzZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxOZXR3b3JrPn0gbmV0d29ya3MgQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbmV0d29ya3MgdG8gZmV0Y2ggYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhbGFuY2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhbGFuY2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1iYWxhbmNlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyQmFsYW5jZShmaWQsIG5ldHdvcmtzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJCYWxhbmNlKGZpZCwgbmV0d29ya3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydPbmNoYWluQXBpLmZldGNoVXNlckJhbGFuY2UnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbmV3IGZhcmNhc3RlciBhY2NvdW50IG9uY2hhaW4uIE9wdGlvbmFsbHkgeW91IGNhbiBwYXNzIGluIHNpZ25lcnMgYWxvbmcgdG8gcmVnaXN0ZXIgYSBuZXcgYWNjb3VudCBhbmQgY3JlYXRlIG11bHRpcGxlIHNpZ25lcnMgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgRmFyY2FzdGVyIGFjY291bnQgb25jaGFpblxuICAgICAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyVXNlck9uQ2hhaW5SZXFCb2R5fSByZWdpc3RlclVzZXJPbkNoYWluUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWdpc3RlclVzZXJPbkNoYWluUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWdpc3RlclVzZXJPbkNoYWluUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLWFjY291bnQtb25jaGFpbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlZ2lzdGVyQWNjb3VudE9uY2hhaW4ocmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlZ2lzdGVyQWNjb3VudE9uY2hhaW4ocmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydPbmNoYWluQXBpLnJlZ2lzdGVyQWNjb3VudE9uY2hhaW4nXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgZnVuZ2libGVzIGluIGJ1bGsgdG8gc2V2ZXJhbCBmYXJjYXN0ZXIgdXNlcnMuIEEgZnVuZGVkIHdhbGxldCBpcyB0byByZXF1aXJlZCB1c2UgdGhpcyBBUEkuIFJlYWN0IG91dCB0byB1cyBvbiB0aGUgTmV5bmFyIGNoYW5uZWwgb24gZmFyY2FzdGVyIHRvIGdldCB5b3VyIHdhbGxldCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBTZW5kIGZ1bmdpYmxlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30geFdhbGxldElkIFdhbGxldCBJRCB0byB1c2UgZm9yIHRyYW5zYWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3R9IHRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VuZC1mdW5naWJsZXMtdG8tdXNlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzZW5kRnVuZ2libGVzVG9Vc2Vycyh4V2FsbGV0SWQsIHRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnNlbmRGdW5naWJsZXNUb1VzZXJzKHhXYWxsZXRJZCwgdHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ09uY2hhaW5BcGkuc2VuZEZ1bmdpYmxlc1RvVXNlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuT25jaGFpbkFwaUZwID0gT25jaGFpbkFwaUZwO1xuLyoqXG4gKiBPbmNoYWluQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgT25jaGFpbkFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLk9uY2hhaW5BcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBmdW5naWJsZVxuICAgICAgICAgKiBAcGFyYW0ge09uY2hhaW5BcGlEZXBsb3lGdW5naWJsZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGVwbG95RnVuZ2libGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlcGxveUZ1bmdpYmxlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlcGxveS1mdW5naWJsZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlcGxveUZ1bmdpYmxlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5kZXBsb3lGdW5naWJsZShyZXF1ZXN0UGFyYW1ldGVycy5vd25lciwgcmVxdWVzdFBhcmFtZXRlcnMuc3ltYm9sLCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YU1lZGlhLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YURlc2NyaXB0aW9uLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YU5zZncsIHJlcXVlc3RQYXJhbWV0ZXJzLm1ldGFkYXRhV2Vic2l0ZUxpbmssIHJlcXVlc3RQYXJhbWV0ZXJzLm1ldGFkYXRhVHdpdHRlciwgcmVxdWVzdFBhcmFtZXRlcnMubWV0YWRhdGFEaXNjb3JkLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YVRlbGVncmFtLCByZXF1ZXN0UGFyYW1ldGVycy5uZXR3b3JrLCByZXF1ZXN0UGFyYW1ldGVycy5mYWN0b3J5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHJlbGV2YW50IG93bmVycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGZ1bmdpYmxlIGFzc2V0IHBhZ2UgYXMgXFxcIlgsIFksIFogYW5kIE4gb3RoZXJzIHlvdSBrbm93IG93biB0aGlzIGFzc2V0XFxcIi5cbiAgICAgICAgICogQHN1bW1hcnkgUmVsZXZhbnQgb3duZXJzXG4gICAgICAgICAqIEBwYXJhbSB7T25jaGFpbkFwaUZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1yZWxldmFudC1mdW5naWJsZS1vd25lcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFJlbGV2YW50RnVuZ2libGVPd25lcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVycyhyZXF1ZXN0UGFyYW1ldGVycy5jb250cmFjdEFkZHJlc3MsIHJlcXVlc3RQYXJhbWV0ZXJzLm5ldHdvcmssIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgdGhlIHRva2VuIGJhbGFuY2VzIG9mIGEgdXNlciBnaXZlbiB0aGVpciBGSURcbiAgICAgICAgICogQHN1bW1hcnkgVG9rZW4gYmFsYW5jZVxuICAgICAgICAgKiBAcGFyYW0ge09uY2hhaW5BcGlGZXRjaFVzZXJCYWxhbmNlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYWxhbmNlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCYWxhbmNlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItYmFsYW5jZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckJhbGFuY2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVXNlckJhbGFuY2UocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5uZXR3b3Jrcywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbmV3IGZhcmNhc3RlciBhY2NvdW50IG9uY2hhaW4uIE9wdGlvbmFsbHkgeW91IGNhbiBwYXNzIGluIHNpZ25lcnMgYWxvbmcgdG8gcmVnaXN0ZXIgYSBuZXcgYWNjb3VudCBhbmQgY3JlYXRlIG11bHRpcGxlIHNpZ25lcnMgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgRmFyY2FzdGVyIGFjY291bnQgb25jaGFpblxuICAgICAgICAgKiBAcGFyYW0ge09uY2hhaW5BcGlSZWdpc3RlckFjY291bnRPbmNoYWluUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWdpc3RlclVzZXJPbkNoYWluUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWdpc3RlclVzZXJPbkNoYWluUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLWFjY291bnQtb25jaGFpbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyQWNjb3VudE9uY2hhaW4ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlZ2lzdGVyQWNjb3VudE9uY2hhaW4ocmVxdWVzdFBhcmFtZXRlcnMucmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGZ1bmdpYmxlcyBpbiBidWxrIHRvIHNldmVyYWwgZmFyY2FzdGVyIHVzZXJzLiBBIGZ1bmRlZCB3YWxsZXQgaXMgdG8gcmVxdWlyZWQgdXNlIHRoaXMgQVBJLiBSZWFjdCBvdXQgdG8gdXMgb24gdGhlIE5leW5hciBjaGFubmVsIG9uIGZhcmNhc3RlciB0byBnZXQgeW91ciB3YWxsZXQgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgU2VuZCBmdW5naWJsZXNcbiAgICAgICAgICogQHBhcmFtIHtPbmNoYWluQXBpU2VuZEZ1bmdpYmxlc1RvVXNlcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3NlbmQtZnVuZ2libGVzLXRvLXVzZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2VuZEZ1bmdpYmxlc1RvVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnNlbmRGdW5naWJsZXNUb1VzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLnhXYWxsZXRJZCwgcmVxdWVzdFBhcmFtZXRlcnMudHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuT25jaGFpbkFwaUZhY3RvcnkgPSBPbmNoYWluQXBpRmFjdG9yeTtcbi8qKlxuICogT25jaGFpbkFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBPbmNoYWluQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgT25jaGFpbkFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRva2VuLlxuICAgICAqIEBzdW1tYXJ5IERlcGxveSBmdW5naWJsZVxuICAgICAqIEBwYXJhbSB7T25jaGFpbkFwaURlcGxveUZ1bmdpYmxlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25jaGFpbkFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERlcGxveUZ1bmdpYmxlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXBsb3lGdW5naWJsZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVwbG95LWZ1bmdpYmxlKVxuICAgICAqXG4gICAgICovXG4gICAgZGVwbG95RnVuZ2libGUocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk9uY2hhaW5BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZXBsb3lGdW5naWJsZShyZXF1ZXN0UGFyYW1ldGVycy5vd25lciwgcmVxdWVzdFBhcmFtZXRlcnMuc3ltYm9sLCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YU1lZGlhLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YURlc2NyaXB0aW9uLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YU5zZncsIHJlcXVlc3RQYXJhbWV0ZXJzLm1ldGFkYXRhV2Vic2l0ZUxpbmssIHJlcXVlc3RQYXJhbWV0ZXJzLm1ldGFkYXRhVHdpdHRlciwgcmVxdWVzdFBhcmFtZXRlcnMubWV0YWRhdGFEaXNjb3JkLCByZXF1ZXN0UGFyYW1ldGVycy5tZXRhZGF0YVRlbGVncmFtLCByZXF1ZXN0UGFyYW1ldGVycy5uZXR3b3JrLCByZXF1ZXN0UGFyYW1ldGVycy5mYWN0b3J5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIHJlbGV2YW50IG93bmVycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGZ1bmdpYmxlIGFzc2V0IHBhZ2UgYXMgXFxcIlgsIFksIFogYW5kIE4gb3RoZXJzIHlvdSBrbm93IG93biB0aGlzIGFzc2V0XFxcIi5cbiAgICAgKiBAc3VtbWFyeSBSZWxldmFudCBvd25lcnNcbiAgICAgKiBAcGFyYW0ge09uY2hhaW5BcGlGZXRjaFJlbGV2YW50RnVuZ2libGVPd25lcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPbmNoYWluQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZnVuZ2libGUtb3duZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hSZWxldmFudEZ1bmdpYmxlT3duZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5PbmNoYWluQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hSZWxldmFudEZ1bmdpYmxlT3duZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbnRyYWN0QWRkcmVzcywgcmVxdWVzdFBhcmFtZXRlcnMubmV0d29yaywgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgdG9rZW4gYmFsYW5jZXMgb2YgYSB1c2VyIGdpdmVuIHRoZWlyIEZJRFxuICAgICAqIEBzdW1tYXJ5IFRva2VuIGJhbGFuY2VcbiAgICAgKiBAcGFyYW0ge09uY2hhaW5BcGlGZXRjaFVzZXJCYWxhbmNlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25jaGFpbkFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJhbGFuY2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhbGFuY2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItYmFsYW5jZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlckJhbGFuY2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk9uY2hhaW5BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJCYWxhbmNlKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubmV0d29ya3MsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5ldyBmYXJjYXN0ZXIgYWNjb3VudCBvbmNoYWluLiBPcHRpb25hbGx5IHlvdSBjYW4gcGFzcyBpbiBzaWduZXJzIGFsb25nIHRvIHJlZ2lzdGVyIGEgbmV3IGFjY291bnQgYW5kIGNyZWF0ZSBtdWx0aXBsZSBzaWduZXJzIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgRmFyY2FzdGVyIGFjY291bnQgb25jaGFpblxuICAgICAqIEBwYXJhbSB7T25jaGFpbkFwaVJlZ2lzdGVyQWNjb3VudE9uY2hhaW5SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPbmNoYWluQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVnaXN0ZXJVc2VyT25DaGFpblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVnaXN0ZXJVc2VyT25DaGFpblJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItYWNjb3VudC1vbmNoYWluKVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJBY2NvdW50T25jaGFpbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuT25jaGFpbkFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlZ2lzdGVyQWNjb3VudE9uY2hhaW4ocmVxdWVzdFBhcmFtZXRlcnMucmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGZ1bmdpYmxlcyBpbiBidWxrIHRvIHNldmVyYWwgZmFyY2FzdGVyIHVzZXJzLiBBIGZ1bmRlZCB3YWxsZXQgaXMgdG8gcmVxdWlyZWQgdXNlIHRoaXMgQVBJLiBSZWFjdCBvdXQgdG8gdXMgb24gdGhlIE5leW5hciBjaGFubmVsIG9uIGZhcmNhc3RlciB0byBnZXQgeW91ciB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBTZW5kIGZ1bmdpYmxlc1xuICAgICAqIEBwYXJhbSB7T25jaGFpbkFwaVNlbmRGdW5naWJsZXNUb1VzZXJzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25jaGFpbkFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZW5kLWZ1bmdpYmxlcy10by11c2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbmRGdW5naWJsZXNUb1VzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5PbmNoYWluQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc2VuZEZ1bmdpYmxlc1RvVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMueFdhbGxldElkLCByZXF1ZXN0UGFyYW1ldGVycy50cmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLk9uY2hhaW5BcGkgPSBPbmNoYWluQXBpO1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRGVwbG95RnVuZ2libGVNZXRhZGF0YU5zZndFbnVtID0ge1xuICAgIFRydWU6ICd0cnVlJyxcbiAgICBGYWxzZTogJ2ZhbHNlJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkRlcGxveUZ1bmdpYmxlTmV0d29ya0VudW0gPSB7XG4gICAgQmFzZTogJ2Jhc2UnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRGVwbG95RnVuZ2libGVGYWN0b3J5RW51bSA9IHtcbiAgICBXb3c6ICd3b3cnLFxuICAgIENsYW5rZXI6ICdjbGFua2VyJ1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/onchain-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/reaction-api.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/reaction-api.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReactionApi = exports.ReactionApiFactory = exports.ReactionApiFp = exports.ReactionApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * ReactionApi - axios parameter creator\n * @export\n */\nconst ReactionApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Delete a reaction (like or recast) to a cast \\\\ (In order to delete a reaction `signer_uuid` must be approved)\n         * @summary Delete reaction\n         * @param {ReactionReqBody} reactionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)\n         *\n         */\n        deleteReaction: async (reactionReqBody, options = {}) => {\n            // verify required parameter 'reactionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteReaction', 'reactionReqBody', reactionReqBody);\n            const localVarPath = `/farcaster/reaction`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reactionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches reactions for a given cast\n         * @summary Reactions for cast\n         * @param {string} hash\n         * @param {Array<ReactionsType>} types Customize which reaction types the request should search for. This is a comma-separated string that can include the following values: \\&#39;likes\\&#39; and \\&#39;recasts\\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.\n         * @param {number} [viewerFid] Providing this will return a list of reactions that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        fetchCastReactions: async (hash, types, viewerFid, limit, cursor, options = {}) => {\n            // verify required parameter 'hash' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastReactions', 'hash', hash);\n            // verify required parameter 'types' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastReactions', 'types', types);\n            const localVarPath = `/farcaster/reactions/cast`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (hash !== undefined) {\n                localVarQueryParameter['hash'] = hash;\n            }\n            if (types) {\n                localVarQueryParameter['types'] = types.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches reactions for a given user\n         * @summary Reactions for user\n         * @param {number} fid\n         * @param {ReactionsType} type Type of reaction to fetch (likes or recasts or all)\n         * @param {number} [viewerFid] Providing this will return a list of reactions that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        fetchUserReactions: async (fid, type, viewerFid, limit, cursor, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserReactions', 'fid', fid);\n            // verify required parameter 'type' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserReactions', 'type', type);\n            const localVarPath = `/farcaster/reactions/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (type !== undefined) {\n                localVarQueryParameter['type'] = type;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Post a reaction (like or recast) to a given cast \\\\ (In order to post a reaction `signer_uuid` must be approved)\n         * @summary Post a reaction\n         * @param {ReactionReqBody} reactionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)\n         *\n         */\n        publishReaction: async (reactionReqBody, options = {}) => {\n            // verify required parameter 'reactionReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishReaction', 'reactionReqBody', reactionReqBody);\n            const localVarPath = `/farcaster/reaction`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(reactionReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ReactionApiAxiosParamCreator = ReactionApiAxiosParamCreator;\n/**\n * ReactionApi - functional programming interface\n * @export\n */\nconst ReactionApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ReactionApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Delete a reaction (like or recast) to a cast \\\\ (In order to delete a reaction `signer_uuid` must be approved)\n         * @summary Delete reaction\n         * @param {ReactionReqBody} reactionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)\n         *\n         */\n        async deleteReaction(reactionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReaction(reactionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionApi.deleteReaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches reactions for a given cast\n         * @summary Reactions for cast\n         * @param {string} hash\n         * @param {Array<ReactionsType>} types Customize which reaction types the request should search for. This is a comma-separated string that can include the following values: \\&#39;likes\\&#39; and \\&#39;recasts\\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.\n         * @param {number} [viewerFid] Providing this will return a list of reactions that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        async fetchCastReactions(hash, types, viewerFid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastReactions(hash, types, viewerFid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionApi.fetchCastReactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches reactions for a given user\n         * @summary Reactions for user\n         * @param {number} fid\n         * @param {ReactionsType} type Type of reaction to fetch (likes or recasts or all)\n         * @param {number} [viewerFid] Providing this will return a list of reactions that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        async fetchUserReactions(fid, type, viewerFid, limit, cursor, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserReactions(fid, type, viewerFid, limit, cursor, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionApi.fetchUserReactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Post a reaction (like or recast) to a given cast \\\\ (In order to post a reaction `signer_uuid` must be approved)\n         * @summary Post a reaction\n         * @param {ReactionReqBody} reactionReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)\n         *\n         */\n        async publishReaction(reactionReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishReaction(reactionReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionApi.publishReaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ReactionApiFp = ReactionApiFp;\n/**\n * ReactionApi - factory interface\n * @export\n */\nconst ReactionApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ReactionApiFp)(configuration);\n    return {\n        /**\n         * Delete a reaction (like or recast) to a cast \\\\ (In order to delete a reaction `signer_uuid` must be approved)\n         * @summary Delete reaction\n         * @param {ReactionApiDeleteReactionRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)\n         *\n         */\n        deleteReaction(requestParameters, options) {\n            return localVarFp.deleteReaction(requestParameters.reactionReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches reactions for a given cast\n         * @summary Reactions for cast\n         * @param {ReactionApiFetchCastReactionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        fetchCastReactions(requestParameters, options) {\n            return localVarFp.fetchCastReactions(requestParameters.hash, requestParameters.types, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches reactions for a given user\n         * @summary Reactions for user\n         * @param {ReactionApiFetchUserReactionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        fetchUserReactions(requestParameters, options) {\n            return localVarFp.fetchUserReactions(requestParameters.fid, requestParameters.type, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Post a reaction (like or recast) to a given cast \\\\ (In order to post a reaction `signer_uuid` must be approved)\n         * @summary Post a reaction\n         * @param {ReactionApiPublishReactionRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)\n         *\n         */\n        publishReaction(requestParameters, options) {\n            return localVarFp.publishReaction(requestParameters.reactionReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ReactionApiFactory = ReactionApiFactory;\n/**\n * ReactionApi - object-oriented interface\n * @export\n * @class ReactionApi\n * @extends {BaseAPI}\n */\nclass ReactionApi extends base_1.BaseAPI {\n    /**\n     * Delete a reaction (like or recast) to a cast \\\\ (In order to delete a reaction `signer_uuid` must be approved)\n     * @summary Delete reaction\n     * @param {ReactionApiDeleteReactionRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)\n     *\n     */\n    deleteReaction(requestParameters, options) {\n        return (0, exports.ReactionApiFp)(this.configuration).deleteReaction(requestParameters.reactionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches reactions for a given cast\n     * @summary Reactions for cast\n     * @param {ReactionApiFetchCastReactionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionApi\n     * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n     *\n     */\n    fetchCastReactions(requestParameters, options) {\n        return (0, exports.ReactionApiFp)(this.configuration).fetchCastReactions(requestParameters.hash, requestParameters.types, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches reactions for a given user\n     * @summary Reactions for user\n     * @param {ReactionApiFetchUserReactionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionApi\n     * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n     *\n     */\n    fetchUserReactions(requestParameters, options) {\n        return (0, exports.ReactionApiFp)(this.configuration).fetchUserReactions(requestParameters.fid, requestParameters.type, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Post a reaction (like or recast) to a given cast \\\\ (In order to post a reaction `signer_uuid` must be approved)\n     * @summary Post a reaction\n     * @param {ReactionApiPublishReactionRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)\n     *\n     */\n    publishReaction(requestParameters, options) {\n        return (0, exports.ReactionApiFp)(this.configuration).publishReaction(requestParameters.reactionReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ReactionApi = ReactionApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3JlYWN0aW9uLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsb0NBQW9DO0FBQy9HLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsc0JBQXNCLGtKQUFrSixZQUFZLFVBQVUsYUFBYTtBQUM5TixtQkFBbUIsUUFBUSx3RkFBd0Ysc0NBQXNDLG9CQUFvQjtBQUM3SyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy9yZWFjdGlvbi1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWN0aW9uQXBpID0gZXhwb3J0cy5SZWFjdGlvbkFwaUZhY3RvcnkgPSBleHBvcnRzLlJlYWN0aW9uQXBpRnAgPSBleHBvcnRzLlJlYWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBSZWFjdGlvbkFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFJlYWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSByZWFjdGlvbiAobGlrZSBvciByZWNhc3QpIHRvIGEgY2FzdCBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSByZWFjdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSByZWFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uUmVxQm9keX0gcmVhY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1yZWFjdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVJlYWN0aW9uOiBhc3luYyAocmVhY3Rpb25SZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3JlYWN0aW9uUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZWxldGVSZWFjdGlvbicsICdyZWFjdGlvblJlcUJvZHknLCByZWFjdGlvblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvcmVhY3Rpb25gO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdERUxFVEUnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHJlYWN0aW9uUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyByZWFjdGlvbnMgZm9yIGEgZ2l2ZW4gY2FzdFxuICAgICAgICAgKiBAc3VtbWFyeSBSZWFjdGlvbnMgZm9yIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxSZWFjdGlvbnNUeXBlPn0gdHlwZXMgQ3VzdG9taXplIHdoaWNoIHJlYWN0aW9uIHR5cGVzIHRoZSByZXF1ZXN0IHNob3VsZCBzZWFyY2ggZm9yLiBUaGlzIGlzIGEgY29tbWEtc2VwYXJhdGVkIHN0cmluZyB0aGF0IGNhbiBpbmNsdWRlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiBcXCYjMzk7bGlrZXNcXCYjMzk7IGFuZCBcXCYjMzk7cmVjYXN0c1xcJiMzOTsuIEJ5IGRlZmF1bHQgYXBpIHJldHVybnMgYm90aC4gVG8gc2VsZWN0IG11bHRpcGxlIHR5cGVzLCB1c2UgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGVzZSB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgcmVhY3Rpb25zIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbnNDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3QtcmVhY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDYXN0UmVhY3Rpb25zOiBhc3luYyAoaGFzaCwgdHlwZXMsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdoYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQ2FzdFJlYWN0aW9ucycsICdoYXNoJywgaGFzaCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0eXBlcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaENhc3RSZWFjdGlvbnMnLCAndHlwZXMnLCB0eXBlcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9yZWFjdGlvbnMvY2FzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydoYXNoJ10gPSBoYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndHlwZXMnXSA9IHR5cGVzLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgcmVhY3Rpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgUmVhY3Rpb25zIGZvciB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWRcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvbnNUeXBlfSB0eXBlIFR5cGUgb2YgcmVhY3Rpb24gdG8gZmV0Y2ggKGxpa2VzIG9yIHJlY2FzdHMgb3IgYWxsKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIHJlYWN0aW9ucyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1yZWFjdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJSZWFjdGlvbnM6IGFzeW5jIChmaWQsIHR5cGUsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyUmVhY3Rpb25zJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0eXBlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlclJlYWN0aW9ucycsICd0eXBlJywgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9yZWFjdGlvbnMvdXNlcmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3R5cGUnXSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBhIHJlYWN0aW9uIChsaWtlIG9yIHJlY2FzdCkgdG8gYSBnaXZlbiBjYXN0IFxcXFwgKEluIG9yZGVyIHRvIHBvc3QgYSByZWFjdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvc3QgYSByZWFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uUmVxQm9keX0gcmVhY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtcmVhY3Rpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoUmVhY3Rpb246IGFzeW5jIChyZWFjdGlvblJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVhY3Rpb25SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hSZWFjdGlvbicsICdyZWFjdGlvblJlcUJvZHknLCByZWFjdGlvblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvcmVhY3Rpb25gO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZWFjdGlvblJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuUmVhY3Rpb25BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFJlYWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFJlYWN0aW9uQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVhY3Rpb25BcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlJlYWN0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSByZWFjdGlvbiAobGlrZSBvciByZWNhc3QpIHRvIGEgY2FzdCBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSByZWFjdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSByZWFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uUmVxQm9keX0gcmVhY3Rpb25SZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1yZWFjdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZVJlYWN0aW9uKHJlYWN0aW9uUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZGVsZXRlUmVhY3Rpb24ocmVhY3Rpb25SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnUmVhY3Rpb25BcGkuZGVsZXRlUmVhY3Rpb24nXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgcmVhY3Rpb25zIGZvciBhIGdpdmVuIGNhc3RcbiAgICAgICAgICogQHN1bW1hcnkgUmVhY3Rpb25zIGZvciBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8UmVhY3Rpb25zVHlwZT59IHR5cGVzIEN1c3RvbWl6ZSB3aGljaCByZWFjdGlvbiB0eXBlcyB0aGUgcmVxdWVzdCBzaG91bGQgc2VhcmNoIGZvci4gVGhpcyBpcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgdGhhdCBjYW4gaW5jbHVkZSB0aGUgZm9sbG93aW5nIHZhbHVlczogXFwmIzM5O2xpa2VzXFwmIzM5OyBhbmQgXFwmIzM5O3JlY2FzdHNcXCYjMzk7LiBCeSBkZWZhdWx0IGFwaSByZXR1cm5zIGJvdGguIFRvIHNlbGVjdCBtdWx0aXBsZSB0eXBlcywgdXNlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGhlc2UgdmFsdWVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIHJlYWN0aW9ucyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb25zQ2FzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVhY3Rpb25zQ2FzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQ2FzdFJlYWN0aW9ucyhoYXNoLCB0eXBlcywgdmlld2VyRmlkLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaENhc3RSZWFjdGlvbnMoaGFzaCwgdHlwZXMsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1JlYWN0aW9uQXBpLmZldGNoQ2FzdFJlYWN0aW9ucyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyByZWFjdGlvbnMgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBSZWFjdGlvbnMgZm9yIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZFxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uc1R5cGV9IHR5cGUgVHlwZSBvZiByZWFjdGlvbiB0byBmZXRjaCAobGlrZXMgb3IgcmVjYXN0cyBvciBhbGwpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgcmVhY3Rpb25zIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlYWN0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLXJlYWN0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoVXNlclJlYWN0aW9ucyhmaWQsIHR5cGUsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2VyUmVhY3Rpb25zKGZpZCwgdHlwZSwgdmlld2VyRmlkLCBsaW1pdCwgY3Vyc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnUmVhY3Rpb25BcGkuZmV0Y2hVc2VyUmVhY3Rpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3N0IGEgcmVhY3Rpb24gKGxpa2Ugb3IgcmVjYXN0KSB0byBhIGdpdmVuIGNhc3QgXFxcXCAoSW4gb3JkZXIgdG8gcG9zdCBhIHJlYWN0aW9uIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgICAgICogQHN1bW1hcnkgUG9zdCBhIHJlYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25SZXFCb2R5fSByZWFjdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1yZWFjdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hSZWFjdGlvbihyZWFjdGlvblJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hSZWFjdGlvbihyZWFjdGlvblJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydSZWFjdGlvbkFwaS5wdWJsaXNoUmVhY3Rpb24nXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuUmVhY3Rpb25BcGlGcCA9IFJlYWN0aW9uQXBpRnA7XG4vKipcbiAqIFJlYWN0aW9uQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVhY3Rpb25BcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5SZWFjdGlvbkFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgcmVhY3Rpb24gKGxpa2Ugb3IgcmVjYXN0KSB0byBhIGNhc3QgXFxcXCAoSW4gb3JkZXIgdG8gZGVsZXRlIGEgcmVhY3Rpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgcmVhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvbkFwaURlbGV0ZVJlYWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtcmVhY3Rpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVSZWFjdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlUmVhY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyByZWFjdGlvbnMgZm9yIGEgZ2l2ZW4gY2FzdFxuICAgICAgICAgKiBAc3VtbWFyeSBSZWFjdGlvbnMgZm9yIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvbkFwaUZldGNoQ2FzdFJlYWN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb25zQ2FzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVhY3Rpb25zQ2FzdFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2FzdFJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hDYXN0UmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmhhc2gsIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGVzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHJlYWN0aW9ucyBmb3IgYSBnaXZlbiB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlYWN0aW9ucyBmb3IgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uQXBpRmV0Y2hVc2VyUmVhY3Rpb25zUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlYWN0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLXJlYWN0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlclJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyUmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zdCBhIHJlYWN0aW9uIChsaWtlIG9yIHJlY2FzdCkgdG8gYSBnaXZlbiBjYXN0IFxcXFwgKEluIG9yZGVyIHRvIHBvc3QgYSByZWFjdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvc3QgYSByZWFjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlYWN0aW9uQXBpUHVibGlzaFJlYWN0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLXJlYWN0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaFJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoUmVhY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25SZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZWFjdGlvbkFwaUZhY3RvcnkgPSBSZWFjdGlvbkFwaUZhY3Rvcnk7XG4vKipcbiAqIFJlYWN0aW9uQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFJlYWN0aW9uQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgUmVhY3Rpb25BcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcmVhY3Rpb24gKGxpa2Ugb3IgcmVjYXN0KSB0byBhIGNhc3QgXFxcXCAoSW4gb3JkZXIgdG8gZGVsZXRlIGEgcmVhY3Rpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IERlbGV0ZSByZWFjdGlvblxuICAgICAqIEBwYXJhbSB7UmVhY3Rpb25BcGlEZWxldGVSZWFjdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFJlYWN0aW9uQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1yZWFjdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5SZWFjdGlvbkFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlbGV0ZVJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVhY3Rpb25zIGZvciBhIGdpdmVuIGNhc3RcbiAgICAgKiBAc3VtbWFyeSBSZWFjdGlvbnMgZm9yIGNhc3RcbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uQXBpRmV0Y2hDYXN0UmVhY3Rpb25zUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgUmVhY3Rpb25BcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbnNDYXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoQ2FzdFJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuUmVhY3Rpb25BcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaENhc3RSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuaGFzaCwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZXMsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVhY3Rpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgKiBAc3VtbWFyeSBSZWFjdGlvbnMgZm9yIHVzZXJcbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uQXBpRmV0Y2hVc2VyUmVhY3Rpb25zUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgUmVhY3Rpb25BcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlYWN0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1yZWFjdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFVzZXJSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlJlYWN0aW9uQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyUmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zdCBhIHJlYWN0aW9uIChsaWtlIG9yIHJlY2FzdCkgdG8gYSBnaXZlbiBjYXN0IFxcXFwgKEluIG9yZGVyIHRvIHBvc3QgYSByZWFjdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICogQHN1bW1hcnkgUG9zdCBhIHJlYWN0aW9uXG4gICAgICogQHBhcmFtIHtSZWFjdGlvbkFwaVB1Ymxpc2hSZWFjdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFJlYWN0aW9uQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtcmVhY3Rpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaXNoUmVhY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlJlYWN0aW9uQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaFJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFjdGlvbkFwaSA9IFJlYWN0aW9uQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/reaction-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/signer-api.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/signer-api.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SignerApi = exports.SignerApiFactory = exports.SignerApiFp = exports.SignerApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * SignerApi - axios parameter creator\n * @export\n */\nconst SignerApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Creates a signer and returns the signer status. \\\\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.\n         * @summary Create signer\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)\n         *\n         */\n        createSigner: async (options = {}) => {\n            const localVarPath = `/farcaster/signer`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch authorization url (Fetched authorized url useful for SIWN login operation)\n         * @summary Fetch authorization url\n         * @param {string} clientId\n         * @param {AuthorizationUrlResponseType} responseType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)\n         *\n         */\n        fetchAuthorizationUrl: async (clientId, responseType, options = {}) => {\n            // verify required parameter 'clientId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchAuthorizationUrl', 'clientId', clientId);\n            // verify required parameter 'responseType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchAuthorizationUrl', 'responseType', responseType);\n            const localVarPath = `/farcaster/login/authorize`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (clientId !== undefined) {\n                localVarQueryParameter['client_id'] = clientId;\n            }\n            if (responseType !== undefined) {\n                localVarQueryParameter['response_type'] = responseType;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches a list of signers for a custody address\n         * @summary List signers\n         * @param {string} message A Sign-In with Ethereum (SIWE) message that the user\\&#39;s Ethereum wallet signs. This message includes details such as the domain, address, statement, URI, nonce, and other relevant information following the EIP-4361 standard. It should be structured and URL-encoded.  example:  example.com wants you to sign in with your Ethereum account:\\\\\\\\n0x23A...F232\\\\\\\\n\\\\\\\\nSign in to continue.\\\\\\\\n\\\\\\\\nURI: example.com\\\\\\\\nVersion: 1\\\\\\\\nChain ID: 1\\\\\\\\nNonce: xyz123\\\\\\\\nIssued At: 2021-09-01T14:52:07Z  Note: This is just an example message (So, message is invalid, since we don\\&#39;t want any signers related to NEYNAR_API_DOCS to be exposed).   [Checkout fetch-signers API documentation for more details.](https://docs.neynar.com/docs/fetch-signers-1)\n         * @param {string} signature The digital signature produced by signing the provided SIWE message with the user\\&#39;s Ethereum private key. This signature is used to verify the authenticity of the message and the identity of the signer.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)\n         *\n         */\n        fetchSigners: async (message, signature, options = {}) => {\n            // verify required parameter 'message' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSigners', 'message', message);\n            // verify required parameter 'signature' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSigners', 'signature', signature);\n            const localVarPath = `/farcaster/signer/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (message !== undefined) {\n                localVarQueryParameter['message'] = message;\n            }\n            if (signature !== undefined) {\n                localVarQueryParameter['signature'] = signature;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches the status of a developer managed signer by public key\n         * @summary Status by public key\n         * @param {string} publicKey\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)\n         *\n         */\n        lookupDeveloperManagedSigner: async (publicKey, options = {}) => {\n            // verify required parameter 'publicKey' is not null or undefined\n            (0, common_1.assertParamExists)('lookupDeveloperManagedSigner', 'publicKey', publicKey);\n            const localVarPath = `/farcaster/signer/developer_managed`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (publicKey !== undefined) {\n                localVarQueryParameter['public_key'] = publicKey;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)\n         * @summary Status\n         * @param {string} signerUuid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)\n         *\n         */\n        lookupSigner: async (signerUuid, options = {}) => {\n            // verify required parameter 'signerUuid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupSigner', 'signerUuid', signerUuid);\n            const localVarPath = `/farcaster/signer`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (signerUuid !== undefined) {\n                localVarQueryParameter['signer_uuid'] = signerUuid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.\n         * @summary Publish message\n         * @param {object} body\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<object>} A promise that resolves to a `object` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)\n         *\n         */\n        publishMessageToFarcaster: async (body, options = {}) => {\n            // verify required parameter 'body' is not null or undefined\n            (0, common_1.assertParamExists)('publishMessageToFarcaster', 'body', body);\n            const localVarPath = `/farcaster/message`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {RegisterSignerKeyReqBody} registerSignerKeyReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)\n         *\n         */\n        registerSignedKey: async (registerSignerKeyReqBody, options = {}) => {\n            // verify required parameter 'registerSignerKeyReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('registerSignedKey', 'registerSignerKeyReqBody', registerSignerKeyReqBody);\n            const localVarPath = `/farcaster/signer/signed_key`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerSignerKeyReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Registers an signed key and returns the developer managed signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {RegisterDeveloperManagedSignedKeyReqBody} registerDeveloperManagedSignedKeyReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)\n         *\n         */\n        registerSignedKeyForDeveloperManagedSigner: async (registerDeveloperManagedSignedKeyReqBody, options = {}) => {\n            // verify required parameter 'registerDeveloperManagedSignedKeyReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('registerSignedKeyForDeveloperManagedSigner', 'registerDeveloperManagedSignedKeyReqBody', registerDeveloperManagedSignedKeyReqBody);\n            const localVarPath = `/farcaster/signer/developer_managed/signed_key`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerDeveloperManagedSignedKeyReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SignerApiAxiosParamCreator = SignerApiAxiosParamCreator;\n/**\n * SignerApi - functional programming interface\n * @export\n */\nconst SignerApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SignerApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Creates a signer and returns the signer status. \\\\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.\n         * @summary Create signer\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)\n         *\n         */\n        async createSigner(options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createSigner(options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.createSigner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch authorization url (Fetched authorized url useful for SIWN login operation)\n         * @summary Fetch authorization url\n         * @param {string} clientId\n         * @param {AuthorizationUrlResponseType} responseType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)\n         *\n         */\n        async fetchAuthorizationUrl(clientId, responseType, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAuthorizationUrl(clientId, responseType, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.fetchAuthorizationUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches a list of signers for a custody address\n         * @summary List signers\n         * @param {string} message A Sign-In with Ethereum (SIWE) message that the user\\&#39;s Ethereum wallet signs. This message includes details such as the domain, address, statement, URI, nonce, and other relevant information following the EIP-4361 standard. It should be structured and URL-encoded.  example:  example.com wants you to sign in with your Ethereum account:\\\\\\\\n0x23A...F232\\\\\\\\n\\\\\\\\nSign in to continue.\\\\\\\\n\\\\\\\\nURI: example.com\\\\\\\\nVersion: 1\\\\\\\\nChain ID: 1\\\\\\\\nNonce: xyz123\\\\\\\\nIssued At: 2021-09-01T14:52:07Z  Note: This is just an example message (So, message is invalid, since we don\\&#39;t want any signers related to NEYNAR_API_DOCS to be exposed).   [Checkout fetch-signers API documentation for more details.](https://docs.neynar.com/docs/fetch-signers-1)\n         * @param {string} signature The digital signature produced by signing the provided SIWE message with the user\\&#39;s Ethereum private key. This signature is used to verify the authenticity of the message and the identity of the signer.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)\n         *\n         */\n        async fetchSigners(message, signature, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSigners(message, signature, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.fetchSigners']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches the status of a developer managed signer by public key\n         * @summary Status by public key\n         * @param {string} publicKey\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)\n         *\n         */\n        async lookupDeveloperManagedSigner(publicKey, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupDeveloperManagedSigner(publicKey, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.lookupDeveloperManagedSigner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)\n         * @summary Status\n         * @param {string} signerUuid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)\n         *\n         */\n        async lookupSigner(signerUuid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupSigner(signerUuid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.lookupSigner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.\n         * @summary Publish message\n         * @param {object} body\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<object>} A promise that resolves to a `object` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)\n         *\n         */\n        async publishMessageToFarcaster(body, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishMessageToFarcaster(body, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.publishMessageToFarcaster']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {RegisterSignerKeyReqBody} registerSignerKeyReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)\n         *\n         */\n        async registerSignedKey(registerSignerKeyReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSignedKey(registerSignerKeyReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.registerSignedKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Registers an signed key and returns the developer managed signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {RegisterDeveloperManagedSignedKeyReqBody} registerDeveloperManagedSignedKeyReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)\n         *\n         */\n        async registerSignedKeyForDeveloperManagedSigner(registerDeveloperManagedSignedKeyReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSignedKeyForDeveloperManagedSigner(registerDeveloperManagedSignedKeyReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SignerApi.registerSignedKeyForDeveloperManagedSigner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SignerApiFp = SignerApiFp;\n/**\n * SignerApi - factory interface\n * @export\n */\nconst SignerApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SignerApiFp)(configuration);\n    return {\n        /**\n         * Creates a signer and returns the signer status. \\\\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.\n         * @summary Create signer\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)\n         *\n         */\n        createSigner(options) {\n            return localVarFp.createSigner(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch authorization url (Fetched authorized url useful for SIWN login operation)\n         * @summary Fetch authorization url\n         * @param {SignerApiFetchAuthorizationUrlRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)\n         *\n         */\n        fetchAuthorizationUrl(requestParameters, options) {\n            return localVarFp.fetchAuthorizationUrl(requestParameters.clientId, requestParameters.responseType, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches a list of signers for a custody address\n         * @summary List signers\n         * @param {SignerApiFetchSignersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)\n         *\n         */\n        fetchSigners(requestParameters, options) {\n            return localVarFp.fetchSigners(requestParameters.message, requestParameters.signature, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches the status of a developer managed signer by public key\n         * @summary Status by public key\n         * @param {SignerApiLookupDeveloperManagedSignerRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)\n         *\n         */\n        lookupDeveloperManagedSigner(requestParameters, options) {\n            return localVarFp.lookupDeveloperManagedSigner(requestParameters.publicKey, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)\n         * @summary Status\n         * @param {SignerApiLookupSignerRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)\n         *\n         */\n        lookupSigner(requestParameters, options) {\n            return localVarFp.lookupSigner(requestParameters.signerUuid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.\n         * @summary Publish message\n         * @param {SignerApiPublishMessageToFarcasterRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<object>} A promise that resolves to a `object` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)\n         *\n         */\n        publishMessageToFarcaster(requestParameters, options) {\n            return localVarFp.publishMessageToFarcaster(requestParameters.body, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {SignerApiRegisterSignedKeyRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)\n         *\n         */\n        registerSignedKey(requestParameters, options) {\n            return localVarFp.registerSignedKey(requestParameters.registerSignerKeyReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Registers an signed key and returns the developer managed signer status with an approval url.\n         * @summary Register Signed Key\n         * @param {SignerApiRegisterSignedKeyForDeveloperManagedSignerRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)\n         *\n         */\n        registerSignedKeyForDeveloperManagedSigner(requestParameters, options) {\n            return localVarFp.registerSignedKeyForDeveloperManagedSigner(requestParameters.registerDeveloperManagedSignedKeyReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SignerApiFactory = SignerApiFactory;\n/**\n * SignerApi - object-oriented interface\n * @export\n * @class SignerApi\n * @extends {BaseAPI}\n */\nclass SignerApi extends base_1.BaseAPI {\n    /**\n     * Creates a signer and returns the signer status. \\\\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.\n     * @summary Create signer\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)\n     *\n     */\n    createSigner(options) {\n        return (0, exports.SignerApiFp)(this.configuration).createSigner(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch authorization url (Fetched authorized url useful for SIWN login operation)\n     * @summary Fetch authorization url\n     * @param {SignerApiFetchAuthorizationUrlRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)\n     *\n     */\n    fetchAuthorizationUrl(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).fetchAuthorizationUrl(requestParameters.clientId, requestParameters.responseType, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches a list of signers for a custody address\n     * @summary List signers\n     * @param {SignerApiFetchSignersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)\n     *\n     */\n    fetchSigners(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).fetchSigners(requestParameters.message, requestParameters.signature, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches the status of a developer managed signer by public key\n     * @summary Status by public key\n     * @param {SignerApiLookupDeveloperManagedSignerRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)\n     *\n     */\n    lookupDeveloperManagedSigner(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).lookupDeveloperManagedSigner(requestParameters.publicKey, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)\n     * @summary Status\n     * @param {SignerApiLookupSignerRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)\n     *\n     */\n    lookupSigner(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).lookupSigner(requestParameters.signerUuid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.\n     * @summary Publish message\n     * @param {SignerApiPublishMessageToFarcasterRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<object>} A promise that resolves to a `object` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)\n     *\n     */\n    publishMessageToFarcaster(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).publishMessageToFarcaster(requestParameters.body, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.\n     * @summary Register Signed Key\n     * @param {SignerApiRegisterSignedKeyRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)\n     *\n     */\n    registerSignedKey(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).registerSignedKey(requestParameters.registerSignerKeyReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Registers an signed key and returns the developer managed signer status with an approval url.\n     * @summary Register Signed Key\n     * @param {SignerApiRegisterSignedKeyForDeveloperManagedSignerRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SignerApi\n     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)\n     *\n     */\n    registerSignedKeyForDeveloperManagedSigner(requestParameters, options) {\n        return (0, exports.SignerApiFp)(this.configuration).registerSignedKeyForDeveloperManagedSigner(requestParameters.registerDeveloperManagedSignedKeyReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SignerApi = SignerApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3NpZ25lci1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtDQUFrQztBQUN2RyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsMEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvYXBpL2FwaXMvc2lnbmVyLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmVyQXBpID0gZXhwb3J0cy5TaWduZXJBcGlGYWN0b3J5ID0gZXhwb3J0cy5TaWduZXJBcGlGcCA9IGV4cG9ydHMuU2lnbmVyQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBTaWduZXJBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBTaWduZXJBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaWduZXIgYW5kIHJldHVybnMgdGhlIHNpZ25lciBzdGF0dXMuIFxcXFwgKipOb3RlKio6IFdoaWxlIHRlc2luZyBwbGVhc2UgcmV1c2UgdGhlIHNpZ25lciwgaXQgY29zdHMgbW9uZXkgdG8gYXBwcm92ZSBhIHNpZ25lci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2NyZWF0ZS1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTaWduZXI6IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3NpZ25lcmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhdXRob3JpemF0aW9uIHVybCAoRmV0Y2hlZCBhdXRob3JpemVkIHVybCB1c2VmdWwgZm9yIFNJV04gbG9naW4gb3BlcmF0aW9uKVxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhdXRob3JpemF0aW9uIHVybFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xpZW50SWRcbiAgICAgICAgICogQHBhcmFtIHtBdXRob3JpemF0aW9uVXJsUmVzcG9uc2VUeXBlfSByZXNwb25zZVR5cGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aG9yaXphdGlvblVybFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXV0aG9yaXphdGlvblVybFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hdXRob3JpemF0aW9uLXVybClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQXV0aG9yaXphdGlvblVybDogYXN5bmMgKGNsaWVudElkLCByZXNwb25zZVR5cGUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY2xpZW50SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hBdXRob3JpemF0aW9uVXJsJywgJ2NsaWVudElkJywgY2xpZW50SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVzcG9uc2VUeXBlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQXV0aG9yaXphdGlvblVybCcsICdyZXNwb25zZVR5cGUnLCByZXNwb25zZVR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvbG9naW4vYXV0aG9yaXplYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGNsaWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjbGllbnRfaWQnXSA9IGNsaWVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmVzcG9uc2VfdHlwZSddID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhIGxpc3Qgb2Ygc2lnbmVycyBmb3IgYSBjdXN0b2R5IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzaWduZXJzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgU2lnbi1JbiB3aXRoIEV0aGVyZXVtIChTSVdFKSBtZXNzYWdlIHRoYXQgdGhlIHVzZXJcXCYjMzk7cyBFdGhlcmV1bSB3YWxsZXQgc2lnbnMuIFRoaXMgbWVzc2FnZSBpbmNsdWRlcyBkZXRhaWxzIHN1Y2ggYXMgdGhlIGRvbWFpbiwgYWRkcmVzcywgc3RhdGVtZW50LCBVUkksIG5vbmNlLCBhbmQgb3RoZXIgcmVsZXZhbnQgaW5mb3JtYXRpb24gZm9sbG93aW5nIHRoZSBFSVAtNDM2MSBzdGFuZGFyZC4gSXQgc2hvdWxkIGJlIHN0cnVjdHVyZWQgYW5kIFVSTC1lbmNvZGVkLiAgZXhhbXBsZTogIGV4YW1wbGUuY29tIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxcXFxcXFxcbjB4MjNBLi4uRjIzMlxcXFxcXFxcblxcXFxcXFxcblNpZ24gaW4gdG8gY29udGludWUuXFxcXFxcXFxuXFxcXFxcXFxuVVJJOiBleGFtcGxlLmNvbVxcXFxcXFxcblZlcnNpb246IDFcXFxcXFxcXG5DaGFpbiBJRDogMVxcXFxcXFxcbk5vbmNlOiB4eXoxMjNcXFxcXFxcXG5Jc3N1ZWQgQXQ6IDIwMjEtMDktMDFUMTQ6NTI6MDdaICBOb3RlOiBUaGlzIGlzIGp1c3QgYW4gZXhhbXBsZSBtZXNzYWdlIChTbywgbWVzc2FnZSBpcyBpbnZhbGlkLCBzaW5jZSB3ZSBkb25cXCYjMzk7dCB3YW50IGFueSBzaWduZXJzIHJlbGF0ZWQgdG8gTkVZTkFSX0FQSV9ET0NTIHRvIGJlIGV4cG9zZWQpLiAgIFtDaGVja291dCBmZXRjaC1zaWduZXJzIEFQSSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMuXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9kb2NzL2ZldGNoLXNpZ25lcnMtMSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBUaGUgZGlnaXRhbCBzaWduYXR1cmUgcHJvZHVjZWQgYnkgc2lnbmluZyB0aGUgcHJvdmlkZWQgU0lXRSBtZXNzYWdlIHdpdGggdGhlIHVzZXJcXCYjMzk7cyBFdGhlcmV1bSBwcml2YXRlIGtleS4gVGhpcyBzaWduYXR1cmUgaXMgdXNlZCB0byB2ZXJpZnkgdGhlIGF1dGhlbnRpY2l0eSBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGlkZW50aXR5IG9mIHRoZSBzaWduZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lckxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc2lnbmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU2lnbmVyczogYXN5bmMgKG1lc3NhZ2UsIHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdtZXNzYWdlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoU2lnbmVycycsICdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzaWduYXR1cmUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTaWduZXJzJywgJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9zaWduZXIvbGlzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydtZXNzYWdlJ10gPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc2lnbmF0dXJlJ10gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHRoZSBzdGF0dXMgb2YgYSBkZXZlbG9wZXIgbWFuYWdlZCBzaWduZXIgYnkgcHVibGljIGtleVxuICAgICAgICAgKiBAc3VtbWFyeSBTdGF0dXMgYnkgcHVibGljIGtleVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERldmVsb3Blck1hbmFnZWRTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtZGV2ZWxvcGVyLW1hbmFnZWQtc2lnbmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcjogYXN5bmMgKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdwdWJsaWNLZXknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcicsICdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvc2lnbmVyL2RldmVsb3Blcl9tYW5hZ2VkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncHVibGljX2tleSddID0gcHVibGljS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBpbmZvcm1hdGlvbiBzdGF0dXMgb2YgYSBzaWduZXIgYnkgcGFzc2luZyBpbiBhIHNpZ25lcl91dWlkIChVc2UgcG9zdCBBUEkgdG8gZ2VuZXJhdGUgYSBzaWduZXIpXG4gICAgICAgICAqIEBzdW1tYXJ5IFN0YXR1c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmVyVXVpZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBTaWduZXI6IGFzeW5jIChzaWduZXJVdWlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NpZ25lclV1aWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwU2lnbmVyJywgJ3NpZ25lclV1aWQnLCBzaWduZXJVdWlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3NpZ25lcmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChzaWduZXJVdWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzaWduZXJfdXVpZCddID0gc2lnbmVyVXVpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIGZhcmNhc3Rlci4gVGhlIG1lc3NhZ2UgbXVzdCBiZSBzaWduZWQgYnkgYSBzaWduZXIgbWFuYWdlZCBieSB0aGUgZGV2ZWxvcGVyLiBVc2UgdGhlIEBmYXJjYXN0ZXIvY29yZSBsaWJyYXJ5IHRvIGNvbnN0cnVjdCBhbmQgc2lnbiB0aGUgbWVzc2FnZS4gVXNlIHRoZSBNZXNzYWdlLnRvSlNPTiBtZXRob2Qgb24gdGhlIHNpZ25lZCBtZXNzYWdlIGFuZCBwYXNzIHRoZSBKU09OIGluIHRoZSBib2R5IG9mIHRoaXMgUE9TVCByZXF1ZXN0LlxuICAgICAgICAgKiBAc3VtbWFyeSBQdWJsaXNoIG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgb2JqZWN0YCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLW1lc3NhZ2UtdG8tZmFyY2FzdGVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlcjogYXN5bmMgKGJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdwdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyJywgJ2JvZHknLCBib2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL21lc3NhZ2VgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShib2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYW4gYXBwIEZJRCwgZGVhZGxpbmUgYW5kIGEgc2lnbmF0dXJlLiBSZXR1cm5zIHRoZSBzaWduZXIgc3RhdHVzIHdpdGggYW4gYXBwcm92YWwgdXJsLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBTaWduZWQgS2V5XG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJTaWduZXJLZXlSZXFCb2R5fSByZWdpc3RlclNpZ25lcktleVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1zaWduZWQta2V5KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTaWduZWRLZXk6IGFzeW5jIChyZWdpc3RlclNpZ25lcktleVJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVnaXN0ZXJTaWduZXJLZXlSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlZ2lzdGVyU2lnbmVkS2V5JywgJ3JlZ2lzdGVyU2lnbmVyS2V5UmVxQm9keScsIHJlZ2lzdGVyU2lnbmVyS2V5UmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9zaWduZXIvc2lnbmVkX2tleWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHJlZ2lzdGVyU2lnbmVyS2V5UmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGFuIHNpZ25lZCBrZXkgYW5kIHJldHVybnMgdGhlIGRldmVsb3BlciBtYW5hZ2VkIHNpZ25lciBzdGF0dXMgd2l0aCBhbiBhcHByb3ZhbCB1cmwuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIFNpZ25lZCBLZXlcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5fSByZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERldmVsb3Blck1hbmFnZWRTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1zaWduZWQta2V5LWZvci1kZXZlbG9wZXItbWFuYWdlZC1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlclNpZ25lZEtleUZvckRldmVsb3Blck1hbmFnZWRTaWduZXI6IGFzeW5jIChyZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3JlZ2lzdGVyRGV2ZWxvcGVyTWFuYWdlZFNpZ25lZEtleVJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVnaXN0ZXJTaWduZWRLZXlGb3JEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyJywgJ3JlZ2lzdGVyRGV2ZWxvcGVyTWFuYWdlZFNpZ25lZEtleVJlcUJvZHknLCByZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3NpZ25lci9kZXZlbG9wZXJfbWFuYWdlZC9zaWduZWRfa2V5YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkocmVnaXN0ZXJEZXZlbG9wZXJNYW5hZ2VkU2lnbmVkS2V5UmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TaWduZXJBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFNpZ25lckFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBTaWduZXJBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTaWduZXJBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlNpZ25lckFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHNpZ25lciBhbmQgcmV0dXJucyB0aGUgc2lnbmVyIHN0YXR1cy4gXFxcXCAqKk5vdGUqKjogV2hpbGUgdGVzaW5nIHBsZWFzZSByZXVzZSB0aGUgc2lnbmVyLCBpdCBjb3N0cyBtb25leSB0byBhcHByb3ZlIGEgc2lnbmVyLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgc2lnbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lcmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvY3JlYXRlLXNpZ25lcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVNpZ25lcihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVTaWduZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NpZ25lckFwaS5jcmVhdGVTaWduZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGF1dGhvcml6YXRpb24gdXJsIChGZXRjaGVkIGF1dGhvcml6ZWQgdXJsIHVzZWZ1bCBmb3IgU0lXTiBsb2dpbiBvcGVyYXRpb24pXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGF1dGhvcml6YXRpb24gdXJsXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGllbnRJZFxuICAgICAgICAgKiBAcGFyYW0ge0F1dGhvcml6YXRpb25VcmxSZXNwb25zZVR5cGV9IHJlc3BvbnNlVHlwZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRob3JpemF0aW9uVXJsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBBdXRob3JpemF0aW9uVXJsUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWF1dGhvcml6YXRpb24tdXJsKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hBdXRob3JpemF0aW9uVXJsKGNsaWVudElkLCByZXNwb25zZVR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQXV0aG9yaXphdGlvblVybChjbGllbnRJZCwgcmVzcG9uc2VUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2lnbmVyQXBpLmZldGNoQXV0aG9yaXphdGlvblVybCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhIGxpc3Qgb2Ygc2lnbmVycyBmb3IgYSBjdXN0b2R5IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzaWduZXJzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEEgU2lnbi1JbiB3aXRoIEV0aGVyZXVtIChTSVdFKSBtZXNzYWdlIHRoYXQgdGhlIHVzZXJcXCYjMzk7cyBFdGhlcmV1bSB3YWxsZXQgc2lnbnMuIFRoaXMgbWVzc2FnZSBpbmNsdWRlcyBkZXRhaWxzIHN1Y2ggYXMgdGhlIGRvbWFpbiwgYWRkcmVzcywgc3RhdGVtZW50LCBVUkksIG5vbmNlLCBhbmQgb3RoZXIgcmVsZXZhbnQgaW5mb3JtYXRpb24gZm9sbG93aW5nIHRoZSBFSVAtNDM2MSBzdGFuZGFyZC4gSXQgc2hvdWxkIGJlIHN0cnVjdHVyZWQgYW5kIFVSTC1lbmNvZGVkLiAgZXhhbXBsZTogIGV4YW1wbGUuY29tIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBFdGhlcmV1bSBhY2NvdW50OlxcXFxcXFxcbjB4MjNBLi4uRjIzMlxcXFxcXFxcblxcXFxcXFxcblNpZ24gaW4gdG8gY29udGludWUuXFxcXFxcXFxuXFxcXFxcXFxuVVJJOiBleGFtcGxlLmNvbVxcXFxcXFxcblZlcnNpb246IDFcXFxcXFxcXG5DaGFpbiBJRDogMVxcXFxcXFxcbk5vbmNlOiB4eXoxMjNcXFxcXFxcXG5Jc3N1ZWQgQXQ6IDIwMjEtMDktMDFUMTQ6NTI6MDdaICBOb3RlOiBUaGlzIGlzIGp1c3QgYW4gZXhhbXBsZSBtZXNzYWdlIChTbywgbWVzc2FnZSBpcyBpbnZhbGlkLCBzaW5jZSB3ZSBkb25cXCYjMzk7dCB3YW50IGFueSBzaWduZXJzIHJlbGF0ZWQgdG8gTkVZTkFSX0FQSV9ET0NTIHRvIGJlIGV4cG9zZWQpLiAgIFtDaGVja291dCBmZXRjaC1zaWduZXJzIEFQSSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMuXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9kb2NzL2ZldGNoLXNpZ25lcnMtMSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBUaGUgZGlnaXRhbCBzaWduYXR1cmUgcHJvZHVjZWQgYnkgc2lnbmluZyB0aGUgcHJvdmlkZWQgU0lXRSBtZXNzYWdlIHdpdGggdGhlIHVzZXJcXCYjMzk7cyBFdGhlcmV1bSBwcml2YXRlIGtleS4gVGhpcyBzaWduYXR1cmUgaXMgdXNlZCB0byB2ZXJpZnkgdGhlIGF1dGhlbnRpY2l0eSBvZiB0aGUgbWVzc2FnZSBhbmQgdGhlIGlkZW50aXR5IG9mIHRoZSBzaWduZXIuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lckxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc2lnbmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoU2lnbmVycyhtZXNzYWdlLCBzaWduYXR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoU2lnbmVycyhtZXNzYWdlLCBzaWduYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTaWduZXJBcGkuZmV0Y2hTaWduZXJzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHRoZSBzdGF0dXMgb2YgYSBkZXZlbG9wZXIgbWFuYWdlZCBzaWduZXIgYnkgcHVibGljIGtleVxuICAgICAgICAgKiBAc3VtbWFyeSBTdGF0dXMgYnkgcHVibGljIGtleVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERldmVsb3Blck1hbmFnZWRTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtZGV2ZWxvcGVyLW1hbmFnZWQtc2lnbmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihwdWJsaWNLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXIocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2lnbmVyQXBpLmxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgaW5mb3JtYXRpb24gc3RhdHVzIG9mIGEgc2lnbmVyIGJ5IHBhc3NpbmcgaW4gYSBzaWduZXJfdXVpZCAoVXNlIHBvc3QgQVBJIHRvIGdlbmVyYXRlIGEgc2lnbmVyKVxuICAgICAgICAgKiBAc3VtbWFyeSBTdGF0dXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25lclV1aWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtc2lnbmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwU2lnbmVyKHNpZ25lclV1aWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFNpZ25lcihzaWduZXJVdWlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2lnbmVyQXBpLmxvb2t1cFNpZ25lciddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGlzaCBhIG1lc3NhZ2UgdG8gZmFyY2FzdGVyLiBUaGUgbWVzc2FnZSBtdXN0IGJlIHNpZ25lZCBieSBhIHNpZ25lciBtYW5hZ2VkIGJ5IHRoZSBkZXZlbG9wZXIuIFVzZSB0aGUgQGZhcmNhc3Rlci9jb3JlIGxpYnJhcnkgdG8gY29uc3RydWN0IGFuZCBzaWduIHRoZSBtZXNzYWdlLiBVc2UgdGhlIE1lc3NhZ2UudG9KU09OIG1ldGhvZCBvbiB0aGUgc2lnbmVkIG1lc3NhZ2UgYW5kIHBhc3MgdGhlIEpTT04gaW4gdGhlIGJvZHkgb2YgdGhpcyBQT1NUIHJlcXVlc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IFB1Ymxpc2ggbWVzc2FnZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBvYmplY3RgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtbWVzc2FnZS10by1mYXJjYXN0ZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBwdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnB1Ymxpc2hNZXNzYWdlVG9GYXJjYXN0ZXIoYm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NpZ25lckFwaS5wdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYW4gYXBwIEZJRCwgZGVhZGxpbmUgYW5kIGEgc2lnbmF0dXJlLiBSZXR1cm5zIHRoZSBzaWduZXIgc3RhdHVzIHdpdGggYW4gYXBwcm92YWwgdXJsLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBTaWduZWQgS2V5XG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJTaWduZXJLZXlSZXFCb2R5fSByZWdpc3RlclNpZ25lcktleVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1zaWduZWQta2V5KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVnaXN0ZXJTaWduZWRLZXkocmVnaXN0ZXJTaWduZXJLZXlSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZWdpc3RlclNpZ25lZEtleShyZWdpc3RlclNpZ25lcktleVJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTaWduZXJBcGkucmVnaXN0ZXJTaWduZWRLZXknXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhbiBzaWduZWQga2V5IGFuZCByZXR1cm5zIHRoZSBkZXZlbG9wZXIgbWFuYWdlZCBzaWduZXIgc3RhdHVzIHdpdGggYW4gYXBwcm92YWwgdXJsLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBTaWduZWQgS2V5XG4gICAgICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJEZXZlbG9wZXJNYW5hZ2VkU2lnbmVkS2V5UmVxQm9keX0gcmVnaXN0ZXJEZXZlbG9wZXJNYW5hZ2VkU2lnbmVkS2V5UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItc2lnbmVkLWtleS1mb3ItZGV2ZWxvcGVyLW1hbmFnZWQtc2lnbmVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVnaXN0ZXJTaWduZWRLZXlGb3JEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyKHJlZ2lzdGVyRGV2ZWxvcGVyTWFuYWdlZFNpZ25lZEtleVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlZ2lzdGVyU2lnbmVkS2V5Rm9yRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihyZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2lnbmVyQXBpLnJlZ2lzdGVyU2lnbmVkS2V5Rm9yRGV2ZWxvcGVyTWFuYWdlZFNpZ25lciddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TaWduZXJBcGlGcCA9IFNpZ25lckFwaUZwO1xuLyoqXG4gKiBTaWduZXJBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTaWduZXJBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaWduZXIgYW5kIHJldHVybnMgdGhlIHNpZ25lciBzdGF0dXMuIFxcXFwgKipOb3RlKio6IFdoaWxlIHRlc2luZyBwbGVhc2UgcmV1c2UgdGhlIHNpZ25lciwgaXQgY29zdHMgbW9uZXkgdG8gYXBwcm92ZSBhIHNpZ25lci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2NyZWF0ZS1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTaWduZXIob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlU2lnbmVyKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhdXRob3JpemF0aW9uIHVybCAoRmV0Y2hlZCBhdXRob3JpemVkIHVybCB1c2VmdWwgZm9yIFNJV04gbG9naW4gb3BlcmF0aW9uKVxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhdXRob3JpemF0aW9uIHVybFxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25lckFwaUZldGNoQXV0aG9yaXphdGlvblVybFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aG9yaXphdGlvblVybFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXV0aG9yaXphdGlvblVybFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hdXRob3JpemF0aW9uLXVybClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQXV0aG9yaXphdGlvblVybChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hBdXRob3JpemF0aW9uVXJsKHJlcXVlc3RQYXJhbWV0ZXJzLmNsaWVudElkLCByZXF1ZXN0UGFyYW1ldGVycy5yZXNwb25zZVR5cGUsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGEgbGlzdCBvZiBzaWduZXJzIGZvciBhIGN1c3RvZHkgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNpZ25lcnNcbiAgICAgICAgICogQHBhcmFtIHtTaWduZXJBcGlGZXRjaFNpZ25lcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lckxpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc2lnbmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU2lnbmVycyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hTaWduZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnNpZ25hdHVyZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgdGhlIHN0YXR1cyBvZiBhIGRldmVsb3BlciBtYW5hZ2VkIHNpZ25lciBieSBwdWJsaWMga2V5XG4gICAgICAgICAqIEBzdW1tYXJ5IFN0YXR1cyBieSBwdWJsaWMga2V5XG4gICAgICAgICAqIEBwYXJhbSB7U2lnbmVyQXBpTG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RGV2ZWxvcGVyTWFuYWdlZFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERldmVsb3Blck1hbmFnZWRTaWduZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1kZXZlbG9wZXItbWFuYWdlZC1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyKHJlcXVlc3RQYXJhbWV0ZXJzLnB1YmxpY0tleSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgaW5mb3JtYXRpb24gc3RhdHVzIG9mIGEgc2lnbmVyIGJ5IHBhc3NpbmcgaW4gYSBzaWduZXJfdXVpZCAoVXNlIHBvc3QgQVBJIHRvIGdlbmVyYXRlIGEgc2lnbmVyKVxuICAgICAgICAgKiBAc3VtbWFyeSBTdGF0dXNcbiAgICAgICAgICogQHBhcmFtIHtTaWduZXJBcGlMb29rdXBTaWduZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lcmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXNpZ25lcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFNpZ25lcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwU2lnbmVyKHJlcXVlc3RQYXJhbWV0ZXJzLnNpZ25lclV1aWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaXNoIGEgbWVzc2FnZSB0byBmYXJjYXN0ZXIuIFRoZSBtZXNzYWdlIG11c3QgYmUgc2lnbmVkIGJ5IGEgc2lnbmVyIG1hbmFnZWQgYnkgdGhlIGRldmVsb3Blci4gVXNlIHRoZSBAZmFyY2FzdGVyL2NvcmUgbGlicmFyeSB0byBjb25zdHJ1Y3QgYW5kIHNpZ24gdGhlIG1lc3NhZ2UuIFVzZSB0aGUgTWVzc2FnZS50b0pTT04gbWV0aG9kIG9uIHRoZSBzaWduZWQgbWVzc2FnZSBhbmQgcGFzcyB0aGUgSlNPTiBpbiB0aGUgYm9keSBvZiB0aGlzIFBPU1QgcmVxdWVzdC5cbiAgICAgICAgICogQHN1bW1hcnkgUHVibGlzaCBtZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7U2lnbmVyQXBpUHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgb2JqZWN0YCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLW1lc3NhZ2UtdG8tZmFyY2FzdGVyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlcihyZXF1ZXN0UGFyYW1ldGVycy5ib2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGFuIGFwcCBGSUQsIGRlYWRsaW5lIGFuZCBhIHNpZ25hdHVyZS4gUmV0dXJucyB0aGUgc2lnbmVyIHN0YXR1cyB3aXRoIGFuIGFwcHJvdmFsIHVybC5cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgU2lnbmVkIEtleVxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25lckFwaVJlZ2lzdGVyU2lnbmVkS2V5UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLXNpZ25lZC1rZXkpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlclNpZ25lZEtleShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVnaXN0ZXJTaWduZWRLZXkocmVxdWVzdFBhcmFtZXRlcnMucmVnaXN0ZXJTaWduZXJLZXlSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGFuIHNpZ25lZCBrZXkgYW5kIHJldHVybnMgdGhlIGRldmVsb3BlciBtYW5hZ2VkIHNpZ25lciBzdGF0dXMgd2l0aCBhbiBhcHByb3ZhbCB1cmwuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIFNpZ25lZCBLZXlcbiAgICAgICAgICogQHBhcmFtIHtTaWduZXJBcGlSZWdpc3RlclNpZ25lZEtleUZvckRldmVsb3Blck1hbmFnZWRTaWduZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERldmVsb3Blck1hbmFnZWRTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1zaWduZWQta2V5LWZvci1kZXZlbG9wZXItbWFuYWdlZC1zaWduZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlclNpZ25lZEtleUZvckRldmVsb3Blck1hbmFnZWRTaWduZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlZ2lzdGVyU2lnbmVkS2V5Rm9yRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihyZXF1ZXN0UGFyYW1ldGVycy5yZWdpc3RlckRldmVsb3Blck1hbmFnZWRTaWduZWRLZXlSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TaWduZXJBcGlGYWN0b3J5ID0gU2lnbmVyQXBpRmFjdG9yeTtcbi8qKlxuICogU2lnbmVyQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFNpZ25lckFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFNpZ25lckFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2lnbmVyIGFuZCByZXR1cm5zIHRoZSBzaWduZXIgc3RhdHVzLiBcXFxcICoqTm90ZSoqOiBXaGlsZSB0ZXNpbmcgcGxlYXNlIHJldXNlIHRoZSBzaWduZXIsIGl0IGNvc3RzIG1vbmV5IHRvIGFwcHJvdmUgYSBzaWduZXIuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIHNpZ25lclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2lnbmVyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvY3JlYXRlLXNpZ25lcilcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVNpZ25lcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVTaWduZXIob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGF1dGhvcml6YXRpb24gdXJsIChGZXRjaGVkIGF1dGhvcml6ZWQgdXJsIHVzZWZ1bCBmb3IgU0lXTiBsb2dpbiBvcGVyYXRpb24pXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYXV0aG9yaXphdGlvbiB1cmxcbiAgICAgKiBAcGFyYW0ge1NpZ25lckFwaUZldGNoQXV0aG9yaXphdGlvblVybFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNpZ25lckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhvcml6YXRpb25VcmxSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEF1dGhvcml6YXRpb25VcmxSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWF1dGhvcml6YXRpb24tdXJsKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hBdXRob3JpemF0aW9uVXJsKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEF1dGhvcml6YXRpb25VcmwocmVxdWVzdFBhcmFtZXRlcnMuY2xpZW50SWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3BvbnNlVHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBsaXN0IG9mIHNpZ25lcnMgZm9yIGEgY3VzdG9keSBhZGRyZXNzXG4gICAgICogQHN1bW1hcnkgTGlzdCBzaWduZXJzXG4gICAgICogQHBhcmFtIHtTaWduZXJBcGlGZXRjaFNpZ25lcnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTaWduZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXJMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zaWduZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hTaWduZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFNpZ25lcnMocmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZSwgcmVxdWVzdFBhcmFtZXRlcnMuc2lnbmF0dXJlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgc3RhdHVzIG9mIGEgZGV2ZWxvcGVyIG1hbmFnZWQgc2lnbmVyIGJ5IHB1YmxpYyBrZXlcbiAgICAgKiBAc3VtbWFyeSBTdGF0dXMgYnkgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSB7U2lnbmVyQXBpTG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNpZ25lckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERldmVsb3Blck1hbmFnZWRTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWRldmVsb3Blci1tYW5hZ2VkLXNpZ25lcilcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNpZ25lckFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXIocmVxdWVzdFBhcmFtZXRlcnMucHVibGljS2V5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBzdGF0dXMgb2YgYSBzaWduZXIgYnkgcGFzc2luZyBpbiBhIHNpZ25lcl91dWlkIChVc2UgcG9zdCBBUEkgdG8gZ2VuZXJhdGUgYSBzaWduZXIpXG4gICAgICogQHN1bW1hcnkgU3RhdHVzXG4gICAgICogQHBhcmFtIHtTaWduZXJBcGlMb29rdXBTaWduZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTaWduZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTaWduZXJgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtc2lnbmVyKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwU2lnbmVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBTaWduZXIocmVxdWVzdFBhcmFtZXRlcnMuc2lnbmVyVXVpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIGZhcmNhc3Rlci4gVGhlIG1lc3NhZ2UgbXVzdCBiZSBzaWduZWQgYnkgYSBzaWduZXIgbWFuYWdlZCBieSB0aGUgZGV2ZWxvcGVyLiBVc2UgdGhlIEBmYXJjYXN0ZXIvY29yZSBsaWJyYXJ5IHRvIGNvbnN0cnVjdCBhbmQgc2lnbiB0aGUgbWVzc2FnZS4gVXNlIHRoZSBNZXNzYWdlLnRvSlNPTiBtZXRob2Qgb24gdGhlIHNpZ25lZCBtZXNzYWdlIGFuZCBwYXNzIHRoZSBKU09OIGluIHRoZSBib2R5IG9mIHRoaXMgUE9TVCByZXF1ZXN0LlxuICAgICAqIEBzdW1tYXJ5IFB1Ymxpc2ggbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U2lnbmVyQXBpUHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNpZ25lckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYG9iamVjdGAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtbWVzc2FnZS10by1mYXJjYXN0ZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5wdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyKHJlcXVlc3RQYXJhbWV0ZXJzLmJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gYXBwIEZJRCwgZGVhZGxpbmUgYW5kIGEgc2lnbmF0dXJlLiBSZXR1cm5zIHRoZSBzaWduZXIgc3RhdHVzIHdpdGggYW4gYXBwcm92YWwgdXJsLlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIFNpZ25lZCBLZXlcbiAgICAgKiBAcGFyYW0ge1NpZ25lckFwaVJlZ2lzdGVyU2lnbmVkS2V5UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2lnbmVyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItc2lnbmVkLWtleSlcbiAgICAgKlxuICAgICAqL1xuICAgIHJlZ2lzdGVyU2lnbmVkS2V5KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TaWduZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5yZWdpc3RlclNpZ25lZEtleShyZXF1ZXN0UGFyYW1ldGVycy5yZWdpc3RlclNpZ25lcktleVJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gc2lnbmVkIGtleSBhbmQgcmV0dXJucyB0aGUgZGV2ZWxvcGVyIG1hbmFnZWQgc2lnbmVyIHN0YXR1cyB3aXRoIGFuIGFwcHJvdmFsIHVybC5cbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBTaWduZWQgS2V5XG4gICAgICogQHBhcmFtIHtTaWduZXJBcGlSZWdpc3RlclNpZ25lZEtleUZvckRldmVsb3Blck1hbmFnZWRTaWduZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTaWduZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcmAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLXNpZ25lZC1rZXktZm9yLWRldmVsb3Blci1tYW5hZ2VkLXNpZ25lcilcbiAgICAgKlxuICAgICAqL1xuICAgIHJlZ2lzdGVyU2lnbmVkS2V5Rm9yRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU2lnbmVyQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVnaXN0ZXJTaWduZWRLZXlGb3JEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyKHJlcXVlc3RQYXJhbWV0ZXJzLnJlZ2lzdGVyRGV2ZWxvcGVyTWFuYWdlZFNpZ25lZEtleVJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lnbmVyQXBpID0gU2lnbmVyQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/signer-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/storage-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/storage-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageApi = exports.StorageApiFactory = exports.StorageApiFp = exports.StorageApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * StorageApi - axios parameter creator\n * @export\n */\nconst StorageApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n         * @summary Buy storage\n         * @param {BuyStorageReqBody} buyStorageReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)\n         *\n         */\n        buyStorage: async (buyStorageReqBody, options = {}) => {\n            // verify required parameter 'buyStorageReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('buyStorage', 'buyStorageReqBody', buyStorageReqBody);\n            const localVarPath = `/farcaster/storage/buy`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(buyStorageReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches storage allocations for a given user\n         * @summary Allocation of user\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)\n         *\n         */\n        lookupUserStorageAllocations: async (fid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserStorageAllocations', 'fid', fid);\n            const localVarPath = `/farcaster/storage/allocations`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches storage usage for a given user\n         * @summary Usage of user\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)\n         *\n         */\n        lookupUserStorageUsage: async (fid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserStorageUsage', 'fid', fid);\n            const localVarPath = `/farcaster/storage/usage`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.StorageApiAxiosParamCreator = StorageApiAxiosParamCreator;\n/**\n * StorageApi - functional programming interface\n * @export\n */\nconst StorageApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.StorageApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n         * @summary Buy storage\n         * @param {BuyStorageReqBody} buyStorageReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)\n         *\n         */\n        async buyStorage(buyStorageReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.buyStorage(buyStorageReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['StorageApi.buyStorage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches storage allocations for a given user\n         * @summary Allocation of user\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)\n         *\n         */\n        async lookupUserStorageAllocations(fid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStorageAllocations(fid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['StorageApi.lookupUserStorageAllocations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches storage usage for a given user\n         * @summary Usage of user\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)\n         *\n         */\n        async lookupUserStorageUsage(fid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStorageUsage(fid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['StorageApi.lookupUserStorageUsage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.StorageApiFp = StorageApiFp;\n/**\n * StorageApi - factory interface\n * @export\n */\nconst StorageApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.StorageApiFp)(configuration);\n    return {\n        /**\n         * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n         * @summary Buy storage\n         * @param {StorageApiBuyStorageRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)\n         *\n         */\n        buyStorage(requestParameters, options) {\n            return localVarFp.buyStorage(requestParameters.buyStorageReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches storage allocations for a given user\n         * @summary Allocation of user\n         * @param {StorageApiLookupUserStorageAllocationsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)\n         *\n         */\n        lookupUserStorageAllocations(requestParameters, options) {\n            return localVarFp.lookupUserStorageAllocations(requestParameters.fid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches storage usage for a given user\n         * @summary Usage of user\n         * @param {StorageApiLookupUserStorageUsageRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)\n         *\n         */\n        lookupUserStorageUsage(requestParameters, options) {\n            return localVarFp.lookupUserStorageUsage(requestParameters.fid, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StorageApiFactory = StorageApiFactory;\n/**\n * StorageApi - object-oriented interface\n * @export\n * @class StorageApi\n * @extends {BaseAPI}\n */\nclass StorageApi extends base_1.BaseAPI {\n    /**\n     * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n     * @summary Buy storage\n     * @param {StorageApiBuyStorageRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StorageApi\n     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)\n     *\n     */\n    buyStorage(requestParameters, options) {\n        return (0, exports.StorageApiFp)(this.configuration).buyStorage(requestParameters.buyStorageReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches storage allocations for a given user\n     * @summary Allocation of user\n     * @param {StorageApiLookupUserStorageAllocationsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StorageApi\n     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)\n     *\n     */\n    lookupUserStorageAllocations(requestParameters, options) {\n        return (0, exports.StorageApiFp)(this.configuration).lookupUserStorageAllocations(requestParameters.fid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches storage usage for a given user\n     * @summary Usage of user\n     * @param {StorageApiLookupUserStorageUsageRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StorageApi\n     * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)\n     *\n     */\n    lookupUserStorageUsage(requestParameters, options) {\n        return (0, exports.StorageApiFp)(this.configuration).lookupUserStorageUsage(requestParameters.fid, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StorageApi = StorageApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3N0b3JhZ2UtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDM0csZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBK0M7QUFDbEUsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBK0M7QUFDOUQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3N0b3JhZ2UtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yYWdlQXBpID0gZXhwb3J0cy5TdG9yYWdlQXBpRmFjdG9yeSA9IGV4cG9ydHMuU3RvcmFnZUFwaUZwID0gZXhwb3J0cy5TdG9yYWdlQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBhcGkgd2lsbCBoZWxwIHlvdSByZW50IHVuaXRzIG9mIHN0b3JhZ2UgZm9yIGFuIHllYXIgZm9yIGEgc3BlY2lmaWMgRklELiBBIHN0b3JhZ2UgdW5pdCBsZXRzIHlvdSBzdG9yZSA1MDAwIGNhc3RzLCAyNTAwIHJlYWN0aW9ucyBhbmQgMjUwMCBsaW5rcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnV5IHN0b3JhZ2VcbiAgICAgICAgICogQHBhcmFtIHtCdXlTdG9yYWdlUmVxQm9keX0gYnV5U3RvcmFnZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvYnV5LXN0b3JhZ2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBidXlTdG9yYWdlOiBhc3luYyAoYnV5U3RvcmFnZVJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnV5U3RvcmFnZVJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnV5U3RvcmFnZScsICdidXlTdG9yYWdlUmVxQm9keScsIGJ1eVN0b3JhZ2VSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3N0b3JhZ2UvYnV5YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYnV5U3RvcmFnZVJlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgc3RvcmFnZSBhbGxvY2F0aW9ucyBmb3IgYSBnaXZlbiB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEFsbG9jYXRpb24gb2YgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXN0b3JhZ2UtYWxsb2NhdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zOiBhc3luYyAoZmlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci9zdG9yYWdlL2FsbG9jYXRpb25zYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHN0b3JhZ2UgdXNhZ2UgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBVc2FnZSBvZiB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZVVzYWdlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlVXNhZ2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS11c2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJTdG9yYWdlVXNhZ2U6IGFzeW5jIChmaWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cFVzZXJTdG9yYWdlVXNhZ2UnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3N0b3JhZ2UvdXNhZ2VgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3RvcmFnZUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBhcGkgd2lsbCBoZWxwIHlvdSByZW50IHVuaXRzIG9mIHN0b3JhZ2UgZm9yIGFuIHllYXIgZm9yIGEgc3BlY2lmaWMgRklELiBBIHN0b3JhZ2UgdW5pdCBsZXRzIHlvdSBzdG9yZSA1MDAwIGNhc3RzLCAyNTAwIHJlYWN0aW9ucyBhbmQgMjUwMCBsaW5rcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnV5IHN0b3JhZ2VcbiAgICAgICAgICogQHBhcmFtIHtCdXlTdG9yYWdlUmVxQm9keX0gYnV5U3RvcmFnZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvYnV5LXN0b3JhZ2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBidXlTdG9yYWdlKGJ1eVN0b3JhZ2VSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5idXlTdG9yYWdlKGJ1eVN0b3JhZ2VSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3RvcmFnZUFwaS5idXlTdG9yYWdlJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHN0b3JhZ2UgYWxsb2NhdGlvbnMgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBBbGxvY2F0aW9uIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1zdG9yYWdlLWFsbG9jYXRpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwVXNlclN0b3JhZ2VBbGxvY2F0aW9ucyhmaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFVzZXJTdG9yYWdlQWxsb2NhdGlvbnMoZmlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3RvcmFnZUFwaS5sb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHN0b3JhZ2UgdXNhZ2UgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBVc2FnZSBvZiB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZVVzYWdlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlVXNhZ2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS11c2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cFVzZXJTdG9yYWdlVXNhZ2UoZmlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5sb29rdXBVc2VyU3RvcmFnZVVzYWdlKGZpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0b3JhZ2VBcGkubG9va3VwVXNlclN0b3JhZ2VVc2FnZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdG9yYWdlQXBpRnAgPSBTdG9yYWdlQXBpRnA7XG4vKipcbiAqIFN0b3JhZ2VBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTdG9yYWdlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuU3RvcmFnZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBhcGkgd2lsbCBoZWxwIHlvdSByZW50IHVuaXRzIG9mIHN0b3JhZ2UgZm9yIGFuIHllYXIgZm9yIGEgc3BlY2lmaWMgRklELiBBIHN0b3JhZ2UgdW5pdCBsZXRzIHlvdSBzdG9yZSA1MDAwIGNhc3RzLCAyNTAwIHJlYWN0aW9ucyBhbmQgMjUwMCBsaW5rcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnV5IHN0b3JhZ2VcbiAgICAgICAgICogQHBhcmFtIHtTdG9yYWdlQXBpQnV5U3RvcmFnZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvYnV5LXN0b3JhZ2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBidXlTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5idXlTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLmJ1eVN0b3JhZ2VSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBzdG9yYWdlIGFsbG9jYXRpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgICAgICogQHN1bW1hcnkgQWxsb2NhdGlvbiBvZiB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7U3RvcmFnZUFwaUxvb2t1cFVzZXJTdG9yYWdlQWxsb2NhdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXN0b3JhZ2UtYWxsb2NhdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgc3RvcmFnZSB1c2FnZSBmb3IgYSBnaXZlbiB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IFVzYWdlIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtTdG9yYWdlQXBpTG9va3VwVXNlclN0b3JhZ2VVc2FnZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZVVzYWdlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlVXNhZ2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS11c2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJTdG9yYWdlVXNhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cFVzZXJTdG9yYWdlVXNhZ2UocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdG9yYWdlQXBpRmFjdG9yeSA9IFN0b3JhZ2VBcGlGYWN0b3J5O1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFN0b3JhZ2VBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTdG9yYWdlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgYXBpIHdpbGwgaGVscCB5b3UgcmVudCB1bml0cyBvZiBzdG9yYWdlIGZvciBhbiB5ZWFyIGZvciBhIHNwZWNpZmljIEZJRC4gQSBzdG9yYWdlIHVuaXQgbGV0cyB5b3Ugc3RvcmUgNTAwMCBjYXN0cywgMjUwMCByZWFjdGlvbnMgYW5kIDI1MDAgbGlua3MuXG4gICAgICogQHN1bW1hcnkgQnV5IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VBcGlCdXlTdG9yYWdlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3RvcmFnZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9idXktc3RvcmFnZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGJ1eVN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0b3JhZ2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5idXlTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLmJ1eVN0b3JhZ2VSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBzdG9yYWdlIGFsbG9jYXRpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgKiBAc3VtbWFyeSBBbGxvY2F0aW9uIG9mIHVzZXJcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VBcGlMb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3RvcmFnZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1zdG9yYWdlLWFsbG9jYXRpb25zKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwVXNlclN0b3JhZ2VBbGxvY2F0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3RvcmFnZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cFVzZXJTdG9yYWdlQWxsb2NhdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBzdG9yYWdlIHVzYWdlIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgKiBAc3VtbWFyeSBVc2FnZSBvZiB1c2VyXG4gICAgICogQHBhcmFtIHtTdG9yYWdlQXBpTG9va3VwVXNlclN0b3JhZ2VVc2FnZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0b3JhZ2VBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlVXNhZ2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VVc2FnZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS11c2FnZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cFVzZXJTdG9yYWdlVXNhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0b3JhZ2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBVc2VyU3RvcmFnZVVzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yYWdlQXBpID0gU3RvcmFnZUFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/storage-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/subscribers-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/subscribers-api.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubscribersApi = exports.SubscribersApiFactory = exports.SubscribersApiFp = exports.SubscribersApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * SubscribersApi - axios parameter creator\n * @export\n */\nconst SubscribersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch what FIDs and contracts a FID is subscribed to.\n         * @summary Subscribed to\n         * @param {number} fid\n         * @param {SubscriptionProvider} subscriptionProvider\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)\n         *\n         */\n        fetchSubscribedToForFid: async (fid, subscriptionProvider, viewerFid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscribedToForFid', 'fid', fid);\n            // verify required parameter 'subscriptionProvider' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscribedToForFid', 'subscriptionProvider', subscriptionProvider);\n            const localVarPath = `/farcaster/user/subscribed_to`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (subscriptionProvider !== undefined) {\n                localVarQueryParameter['subscription_provider'] = subscriptionProvider;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch subscribers for a given FID\\'s contracts. Doesn\\'t return addresses that don\\'t have an FID.\n         * @summary Subscribers of a user\n         * @param {number} fid\n         * @param {SubscriptionProviders} subscriptionProvider\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)\n         *\n         */\n        fetchSubscribersForFid: async (fid, subscriptionProvider, viewerFid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscribersForFid', 'fid', fid);\n            // verify required parameter 'subscriptionProvider' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscribersForFid', 'subscriptionProvider', subscriptionProvider);\n            const localVarPath = `/farcaster/user/subscribers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (subscriptionProvider !== undefined) {\n                localVarQueryParameter['subscription_provider'] = subscriptionProvider;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Check if a wallet address is subscribed to a given STP (Hypersub) contract.\n         * @summary Hypersub subscription check\n         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time\n         * @param {string} contractAddress Ethereum address of the STP contract\n         * @param {string} chainId Chain ID of the STP contract\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)\n         *\n         */\n        fetchSubscriptionCheck: async (addresses, contractAddress, chainId, options = {}) => {\n            // verify required parameter 'addresses' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscriptionCheck', 'addresses', addresses);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscriptionCheck', 'contractAddress', contractAddress);\n            // verify required parameter 'chainId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscriptionCheck', 'chainId', chainId);\n            const localVarPath = `/stp/subscription_check`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (addresses !== undefined) {\n                localVarQueryParameter['addresses'] = addresses;\n            }\n            if (contractAddress !== undefined) {\n                localVarQueryParameter['contract_address'] = contractAddress;\n            }\n            if (chainId !== undefined) {\n                localVarQueryParameter['chain_id'] = chainId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch created subscriptions for a given FID\\'s.\n         * @summary Subscriptions created by FID\n         * @param {number} fid\n         * @param {SubscriptionProvider} subscriptionProvider\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)\n         *\n         */\n        fetchSubscriptionsForFid: async (fid, subscriptionProvider, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscriptionsForFid', 'fid', fid);\n            // verify required parameter 'subscriptionProvider' is not null or undefined\n            (0, common_1.assertParamExists)('fetchSubscriptionsForFid', 'subscriptionProvider', subscriptionProvider);\n            const localVarPath = `/farcaster/user/subscriptions_created`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (subscriptionProvider !== undefined) {\n                localVarQueryParameter['subscription_provider'] = subscriptionProvider;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SubscribersApiAxiosParamCreator = SubscribersApiAxiosParamCreator;\n/**\n * SubscribersApi - functional programming interface\n * @export\n */\nconst SubscribersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SubscribersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch what FIDs and contracts a FID is subscribed to.\n         * @summary Subscribed to\n         * @param {number} fid\n         * @param {SubscriptionProvider} subscriptionProvider\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)\n         *\n         */\n        async fetchSubscribedToForFid(fid, subscriptionProvider, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSubscribedToForFid(fid, subscriptionProvider, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SubscribersApi.fetchSubscribedToForFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch subscribers for a given FID\\'s contracts. Doesn\\'t return addresses that don\\'t have an FID.\n         * @summary Subscribers of a user\n         * @param {number} fid\n         * @param {SubscriptionProviders} subscriptionProvider\n         * @param {number} [viewerFid]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)\n         *\n         */\n        async fetchSubscribersForFid(fid, subscriptionProvider, viewerFid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSubscribersForFid(fid, subscriptionProvider, viewerFid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SubscribersApi.fetchSubscribersForFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Check if a wallet address is subscribed to a given STP (Hypersub) contract.\n         * @summary Hypersub subscription check\n         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time\n         * @param {string} contractAddress Ethereum address of the STP contract\n         * @param {string} chainId Chain ID of the STP contract\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)\n         *\n         */\n        async fetchSubscriptionCheck(addresses, contractAddress, chainId, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSubscriptionCheck(addresses, contractAddress, chainId, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SubscribersApi.fetchSubscriptionCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch created subscriptions for a given FID\\'s.\n         * @summary Subscriptions created by FID\n         * @param {number} fid\n         * @param {SubscriptionProvider} subscriptionProvider\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)\n         *\n         */\n        async fetchSubscriptionsForFid(fid, subscriptionProvider, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchSubscriptionsForFid(fid, subscriptionProvider, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SubscribersApi.fetchSubscriptionsForFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SubscribersApiFp = SubscribersApiFp;\n/**\n * SubscribersApi - factory interface\n * @export\n */\nconst SubscribersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SubscribersApiFp)(configuration);\n    return {\n        /**\n         * Fetch what FIDs and contracts a FID is subscribed to.\n         * @summary Subscribed to\n         * @param {SubscribersApiFetchSubscribedToForFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)\n         *\n         */\n        fetchSubscribedToForFid(requestParameters, options) {\n            return localVarFp.fetchSubscribedToForFid(requestParameters.fid, requestParameters.subscriptionProvider, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch subscribers for a given FID\\'s contracts. Doesn\\'t return addresses that don\\'t have an FID.\n         * @summary Subscribers of a user\n         * @param {SubscribersApiFetchSubscribersForFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)\n         *\n         */\n        fetchSubscribersForFid(requestParameters, options) {\n            return localVarFp.fetchSubscribersForFid(requestParameters.fid, requestParameters.subscriptionProvider, requestParameters.viewerFid, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Check if a wallet address is subscribed to a given STP (Hypersub) contract.\n         * @summary Hypersub subscription check\n         * @param {SubscribersApiFetchSubscriptionCheckRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)\n         *\n         */\n        fetchSubscriptionCheck(requestParameters, options) {\n            return localVarFp.fetchSubscriptionCheck(requestParameters.addresses, requestParameters.contractAddress, requestParameters.chainId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch created subscriptions for a given FID\\'s.\n         * @summary Subscriptions created by FID\n         * @param {SubscribersApiFetchSubscriptionsForFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)\n         *\n         */\n        fetchSubscriptionsForFid(requestParameters, options) {\n            return localVarFp.fetchSubscriptionsForFid(requestParameters.fid, requestParameters.subscriptionProvider, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SubscribersApiFactory = SubscribersApiFactory;\n/**\n * SubscribersApi - object-oriented interface\n * @export\n * @class SubscribersApi\n * @extends {BaseAPI}\n */\nclass SubscribersApi extends base_1.BaseAPI {\n    /**\n     * Fetch what FIDs and contracts a FID is subscribed to.\n     * @summary Subscribed to\n     * @param {SubscribersApiFetchSubscribedToForFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SubscribersApi\n     * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)\n     *\n     */\n    fetchSubscribedToForFid(requestParameters, options) {\n        return (0, exports.SubscribersApiFp)(this.configuration).fetchSubscribedToForFid(requestParameters.fid, requestParameters.subscriptionProvider, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch subscribers for a given FID\\'s contracts. Doesn\\'t return addresses that don\\'t have an FID.\n     * @summary Subscribers of a user\n     * @param {SubscribersApiFetchSubscribersForFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SubscribersApi\n     * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)\n     *\n     */\n    fetchSubscribersForFid(requestParameters, options) {\n        return (0, exports.SubscribersApiFp)(this.configuration).fetchSubscribersForFid(requestParameters.fid, requestParameters.subscriptionProvider, requestParameters.viewerFid, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Check if a wallet address is subscribed to a given STP (Hypersub) contract.\n     * @summary Hypersub subscription check\n     * @param {SubscribersApiFetchSubscriptionCheckRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SubscribersApi\n     * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)\n     *\n     */\n    fetchSubscriptionCheck(requestParameters, options) {\n        return (0, exports.SubscribersApiFp)(this.configuration).fetchSubscriptionCheck(requestParameters.addresses, requestParameters.contractAddress, requestParameters.chainId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch created subscriptions for a given FID\\'s.\n     * @summary Subscriptions created by FID\n     * @param {SubscribersApiFetchSubscriptionsForFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SubscribersApi\n     * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)\n     *\n     */\n    fetchSubscriptionsForFid(requestParameters, options) {\n        return (0, exports.SubscribersApiFp)(this.configuration).fetchSubscriptionsForFid(requestParameters.fid, requestParameters.subscriptionProvider, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SubscribersApi = SubscribersApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3N1YnNjcmliZXJzLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsdUNBQXVDO0FBQzNILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtB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QkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvYXBpL2FwaXMvc3Vic2NyaWJlcnMtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJzY3JpYmVyc0FwaSA9IGV4cG9ydHMuU3Vic2NyaWJlcnNBcGlGYWN0b3J5ID0gZXhwb3J0cy5TdWJzY3JpYmVyc0FwaUZwID0gZXhwb3J0cy5TdWJzY3JpYmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogU3Vic2NyaWJlcnNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBTdWJzY3JpYmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggd2hhdCBGSURzIGFuZCBjb250cmFjdHMgYSBGSUQgaXMgc3Vic2NyaWJlZCB0by5cbiAgICAgICAgICogQHN1bW1hcnkgU3Vic2NyaWJlZCB0b1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkXG4gICAgICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9uUHJvdmlkZXJ9IHN1YnNjcmlwdGlvblByb3ZpZGVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpYmVkVG9SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmliZWRUb1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpYmVkLXRvLWZvci1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFN1YnNjcmliZWRUb0ZvckZpZDogYXN5bmMgKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIHZpZXdlckZpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N1YnNjcmlwdGlvblByb3ZpZGVyJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoU3Vic2NyaWJlZFRvRm9yRmlkJywgJ3N1YnNjcmlwdGlvblByb3ZpZGVyJywgc3Vic2NyaXB0aW9uUHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlci9zdWJzY3JpYmVkX3RvYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uUHJvdmlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N1YnNjcmlwdGlvbl9wcm92aWRlciddID0gc3Vic2NyaXB0aW9uUHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBzdWJzY3JpYmVycyBmb3IgYSBnaXZlbiBGSURcXCdzIGNvbnRyYWN0cy4gRG9lc25cXCd0IHJldHVybiBhZGRyZXNzZXMgdGhhdCBkb25cXCd0IGhhdmUgYW4gRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJzY3JpYmVycyBvZiBhIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZFxuICAgICAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvblByb3ZpZGVyc30gc3Vic2NyaXB0aW9uUHJvdmlkZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmliZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpYmVyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpYmVycy1mb3ItZmlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hTdWJzY3JpYmVyc0ZvckZpZDogYXN5bmMgKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIHZpZXdlckZpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTdWJzY3JpYmVyc0ZvckZpZCcsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc3Vic2NyaXB0aW9uUHJvdmlkZXInIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTdWJzY3JpYmVyc0ZvckZpZCcsICdzdWJzY3JpcHRpb25Qcm92aWRlcicsIHN1YnNjcmlwdGlvblByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvc3Vic2NyaWJlcnNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3ZXJGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3ZpZXdlcl9maWQnXSA9IHZpZXdlckZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25Qcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc3Vic2NyaXB0aW9uX3Byb3ZpZGVyJ10gPSBzdWJzY3JpcHRpb25Qcm92aWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgd2FsbGV0IGFkZHJlc3MgaXMgc3Vic2NyaWJlZCB0byBhIGdpdmVuIFNUUCAoSHlwZXJzdWIpIGNvbnRyYWN0LlxuICAgICAgICAgKiBAc3VtbWFyeSBIeXBlcnN1YiBzdWJzY3JpcHRpb24gY2hlY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NlcyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBFdGhlcmV1bSBhZGRyZXNzZXMsIHVwIHRvIDM1MCBhdCBhIHRpbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFdGhlcmV1bSBhZGRyZXNzIG9mIHRoZSBTVFAgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgQ2hhaW4gSUQgb2YgdGhlIFNUUCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpcHRpb25DaGVja1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaXB0aW9uQ2hlY2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc3Vic2NyaXB0aW9uLWNoZWNrKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hTdWJzY3JpcHRpb25DaGVjazogYXN5bmMgKGFkZHJlc3NlcywgY29udHJhY3RBZGRyZXNzLCBjaGFpbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NlcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFN1YnNjcmlwdGlvbkNoZWNrJywgJ2FkZHJlc3NlcycsIGFkZHJlc3Nlcyk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjb250cmFjdEFkZHJlc3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTdWJzY3JpcHRpb25DaGVjaycsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY2hhaW5JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFN1YnNjcmlwdGlvbkNoZWNrJywgJ2NoYWluSWQnLCBjaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvc3RwL3N1YnNjcmlwdGlvbl9jaGVja2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2FkZHJlc3NlcyddID0gYWRkcmVzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY29udHJhY3RfYWRkcmVzcyddID0gY29udHJhY3RBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2NoYWluX2lkJ10gPSBjaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggY3JlYXRlZCBzdWJzY3JpcHRpb25zIGZvciBhIGdpdmVuIEZJRFxcJ3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFN1YnNjcmlwdGlvbnMgY3JlYXRlZCBieSBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZFxuICAgICAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvblByb3ZpZGVyfSBzdWJzY3JpcHRpb25Qcm92aWRlclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpcHRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpcHRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmlwdGlvbnMtZm9yLWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZDogYXN5bmMgKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZCcsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc3Vic2NyaXB0aW9uUHJvdmlkZXInIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hTdWJzY3JpcHRpb25zRm9yRmlkJywgJ3N1YnNjcmlwdGlvblByb3ZpZGVyJywgc3Vic2NyaXB0aW9uUHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlci9zdWJzY3JpcHRpb25zX2NyZWF0ZWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25Qcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc3Vic2NyaXB0aW9uX3Byb3ZpZGVyJ10gPSBzdWJzY3JpcHRpb25Qcm92aWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3Vic2NyaWJlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFN1YnNjcmliZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFN1YnNjcmliZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Vic2NyaWJlcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlN1YnNjcmliZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB3aGF0IEZJRHMgYW5kIGNvbnRyYWN0cyBhIEZJRCBpcyBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJzY3JpYmVkIHRvXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWRcbiAgICAgICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb25Qcm92aWRlcn0gc3Vic2NyaXB0aW9uUHJvdmlkZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmliZWRUb1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaWJlZFRvUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmliZWQtdG8tZm9yLWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoU3Vic2NyaWJlZFRvRm9yRmlkKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIHZpZXdlckZpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQoZmlkLCBzdWJzY3JpcHRpb25Qcm92aWRlciwgdmlld2VyRmlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Vic2NyaWJlcnNBcGkuZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN1YnNjcmliZXJzIGZvciBhIGdpdmVuIEZJRFxcJ3MgY29udHJhY3RzLiBEb2VzblxcJ3QgcmV0dXJuIGFkZHJlc3NlcyB0aGF0IGRvblxcJ3QgaGF2ZSBhbiBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZXJzIG9mIGEgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkXG4gICAgICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9uUHJvdmlkZXJzfSBzdWJzY3JpcHRpb25Qcm92aWRlclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3Vic2NyaWJlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmliZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmliZXJzLWZvci1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFN1YnNjcmliZXJzRm9yRmlkKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIHZpZXdlckZpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hTdWJzY3JpYmVyc0ZvckZpZChmaWQsIHN1YnNjcmlwdGlvblByb3ZpZGVyLCB2aWV3ZXJGaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdWJzY3JpYmVyc0FwaS5mZXRjaFN1YnNjcmliZXJzRm9yRmlkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBhIHdhbGxldCBhZGRyZXNzIGlzIHN1YnNjcmliZWQgdG8gYSBnaXZlbiBTVFAgKEh5cGVyc3ViKSBjb250cmFjdC5cbiAgICAgICAgICogQHN1bW1hcnkgSHlwZXJzdWIgc3Vic2NyaXB0aW9uIGNoZWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzZXMgQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRXRoZXJldW0gYWRkcmVzc2VzLCB1cCB0byAzNTAgYXQgYSB0aW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRXRoZXJldW0gYWRkcmVzcyBvZiB0aGUgU1RQIGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIENoYWluIElEIG9mIHRoZSBTVFAgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3Vic2NyaXB0aW9uQ2hlY2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmlwdGlvbkNoZWNrUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmlwdGlvbi1jaGVjaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoU3Vic2NyaXB0aW9uQ2hlY2soYWRkcmVzc2VzLCBjb250cmFjdEFkZHJlc3MsIGNoYWluSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoU3Vic2NyaXB0aW9uQ2hlY2soYWRkcmVzc2VzLCBjb250cmFjdEFkZHJlc3MsIGNoYWluSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdWJzY3JpYmVyc0FwaS5mZXRjaFN1YnNjcmlwdGlvbkNoZWNrJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBjcmVhdGVkIHN1YnNjcmlwdGlvbnMgZm9yIGEgZ2l2ZW4gRklEXFwncy5cbiAgICAgICAgICogQHN1bW1hcnkgU3Vic2NyaXB0aW9ucyBjcmVhdGVkIGJ5IEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkXG4gICAgICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9uUHJvdmlkZXJ9IHN1YnNjcmlwdGlvblByb3ZpZGVyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmlwdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmlwdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc3Vic2NyaXB0aW9ucy1mb3ItZmlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hTdWJzY3JpcHRpb25zRm9yRmlkKGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZChmaWQsIHN1YnNjcmlwdGlvblByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Vic2NyaWJlcnNBcGkuZmV0Y2hTdWJzY3JpcHRpb25zRm9yRmlkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlN1YnNjcmliZXJzQXBpRnAgPSBTdWJzY3JpYmVyc0FwaUZwO1xuLyoqXG4gKiBTdWJzY3JpYmVyc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFN1YnNjcmliZXJzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuU3Vic2NyaWJlcnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHdoYXQgRklEcyBhbmQgY29udHJhY3RzIGEgRklEIGlzIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZWQgdG9cbiAgICAgICAgICogQHBhcmFtIHtTdWJzY3JpYmVyc0FwaUZldGNoU3Vic2NyaWJlZFRvRm9yRmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpYmVkVG9SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmliZWRUb1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpYmVkLXRvLWZvci1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFN1YnNjcmliZWRUb0ZvckZpZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zdWJzY3JpcHRpb25Qcm92aWRlciwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggc3Vic2NyaWJlcnMgZm9yIGEgZ2l2ZW4gRklEXFwncyBjb250cmFjdHMuIERvZXNuXFwndCByZXR1cm4gYWRkcmVzc2VzIHRoYXQgZG9uXFwndCBoYXZlIGFuIEZJRC5cbiAgICAgICAgICogQHN1bW1hcnkgU3Vic2NyaWJlcnMgb2YgYSB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7U3Vic2NyaWJlcnNBcGlGZXRjaFN1YnNjcmliZXJzRm9yRmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpYmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaWJlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc3Vic2NyaWJlcnMtZm9yLWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU3Vic2NyaWJlcnNGb3JGaWQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoU3Vic2NyaWJlcnNGb3JGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zdWJzY3JpcHRpb25Qcm92aWRlciwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSB3YWxsZXQgYWRkcmVzcyBpcyBzdWJzY3JpYmVkIHRvIGEgZ2l2ZW4gU1RQIChIeXBlcnN1YikgY29udHJhY3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEh5cGVyc3ViIHN1YnNjcmlwdGlvbiBjaGVja1xuICAgICAgICAgKiBAcGFyYW0ge1N1YnNjcmliZXJzQXBpRmV0Y2hTdWJzY3JpcHRpb25DaGVja1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3Vic2NyaXB0aW9uQ2hlY2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmlwdGlvbkNoZWNrUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmlwdGlvbi1jaGVjaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU3Vic2NyaXB0aW9uQ2hlY2socmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoU3Vic2NyaXB0aW9uQ2hlY2socmVxdWVzdFBhcmFtZXRlcnMuYWRkcmVzc2VzLCByZXF1ZXN0UGFyYW1ldGVycy5jb250cmFjdEFkZHJlc3MsIHJlcXVlc3RQYXJhbWV0ZXJzLmNoYWluSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBjcmVhdGVkIHN1YnNjcmlwdGlvbnMgZm9yIGEgZ2l2ZW4gRklEXFwncy5cbiAgICAgICAgICogQHN1bW1hcnkgU3Vic2NyaXB0aW9ucyBjcmVhdGVkIGJ5IEZJRFxuICAgICAgICAgKiBAcGFyYW0ge1N1YnNjcmliZXJzQXBpRmV0Y2hTdWJzY3JpcHRpb25zRm9yRmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpcHRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpcHRpb25zUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmlwdGlvbnMtZm9yLWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hTdWJzY3JpcHRpb25zRm9yRmlkKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuc3Vic2NyaXB0aW9uUHJvdmlkZXIsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlN1YnNjcmliZXJzQXBpRmFjdG9yeSA9IFN1YnNjcmliZXJzQXBpRmFjdG9yeTtcbi8qKlxuICogU3Vic2NyaWJlcnNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU3Vic2NyaWJlcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTdWJzY3JpYmVyc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBGZXRjaCB3aGF0IEZJRHMgYW5kIGNvbnRyYWN0cyBhIEZJRCBpcyBzdWJzY3JpYmVkIHRvLlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZWQgdG9cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmliZXJzQXBpRmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmVyc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmliZWRUb1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaWJlZFRvUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpYmVkLXRvLWZvci1maWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFN1YnNjcmliZWRUb0ZvckZpZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Vic2NyaWJlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFN1YnNjcmliZWRUb0ZvckZpZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnN1YnNjcmlwdGlvblByb3ZpZGVyLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBzdWJzY3JpYmVycyBmb3IgYSBnaXZlbiBGSURcXCdzIGNvbnRyYWN0cy4gRG9lc25cXCd0IHJldHVybiBhZGRyZXNzZXMgdGhhdCBkb25cXCd0IGhhdmUgYW4gRklELlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZXJzIG9mIGEgdXNlclxuICAgICAqIEBwYXJhbSB7U3Vic2NyaWJlcnNBcGlGZXRjaFN1YnNjcmliZXJzRm9yRmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Vic2NyaWJlcnNBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpYmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaWJlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmliZXJzLWZvci1maWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFN1YnNjcmliZXJzRm9yRmlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdWJzY3JpYmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoU3Vic2NyaWJlcnNGb3JGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zdWJzY3JpcHRpb25Qcm92aWRlciwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB3YWxsZXQgYWRkcmVzcyBpcyBzdWJzY3JpYmVkIHRvIGEgZ2l2ZW4gU1RQIChIeXBlcnN1YikgY29udHJhY3QuXG4gICAgICogQHN1bW1hcnkgSHlwZXJzdWIgc3Vic2NyaXB0aW9uIGNoZWNrXG4gICAgICogQHBhcmFtIHtTdWJzY3JpYmVyc0FwaUZldGNoU3Vic2NyaXB0aW9uQ2hlY2tSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmVyc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmlwdGlvbkNoZWNrUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpcHRpb25DaGVja1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc3Vic2NyaXB0aW9uLWNoZWNrKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hTdWJzY3JpcHRpb25DaGVjayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Vic2NyaWJlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFN1YnNjcmlwdGlvbkNoZWNrKHJlcXVlc3RQYXJhbWV0ZXJzLmFkZHJlc3NlcywgcmVxdWVzdFBhcmFtZXRlcnMuY29udHJhY3RBZGRyZXNzLCByZXF1ZXN0UGFyYW1ldGVycy5jaGFpbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY3JlYXRlZCBzdWJzY3JpcHRpb25zIGZvciBhIGdpdmVuIEZJRFxcJ3MuXG4gICAgICogQHN1bW1hcnkgU3Vic2NyaXB0aW9ucyBjcmVhdGVkIGJ5IEZJRFxuICAgICAqIEBwYXJhbSB7U3Vic2NyaWJlcnNBcGlGZXRjaFN1YnNjcmlwdGlvbnNGb3JGaWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdWJzY3JpYmVyc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmlwdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmlwdGlvbnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXN1YnNjcmlwdGlvbnMtZm9yLWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Vic2NyaWJlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFN1YnNjcmlwdGlvbnNGb3JGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5zdWJzY3JpcHRpb25Qcm92aWRlciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpYmVyc0FwaSA9IFN1YnNjcmliZXJzQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/subscribers-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/user-api.js":
/*!********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/user-api.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * UserApi - axios parameter creator\n * @export\n */\nconst UserApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Removes verification for an eth address for the user \\\\ (In order to delete verification `signer_uuid` must be approved)\n         * @summary Delete verification\n         * @param {RemoveVerificationReqBody} removeVerificationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)\n         *\n         */\n        deleteVerification: async (removeVerificationReqBody, options = {}) => {\n            // verify required parameter 'removeVerificationReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteVerification', 'removeVerificationReqBody', removeVerificationReqBody);\n            const localVarPath = `/farcaster/user/verification`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(removeVerificationReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches information about multiple users based on FIDs\n         * @summary By FIDs\n         * @param {string} fids Comma separated list of FIDs, up to 100 at a time\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)\n         *\n         */\n        fetchBulkUsers: async (fids, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'fids' is not null or undefined\n            (0, common_1.assertParamExists)('fetchBulkUsers', 'fids', fids);\n            const localVarPath = `/farcaster/user/bulk`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fids !== undefined) {\n                localVarQueryParameter['fids'] = fids;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.\n         * @summary By Eth or Sol addresses\n         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time\n         * @param {Array<BulkUserAddressType>} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \\&#39;custody_address\\&#39; and \\&#39;verified_address\\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)\n         *\n         */\n        fetchBulkUsersByEthOrSolAddress: async (addresses, addressTypes, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'addresses' is not null or undefined\n            (0, common_1.assertParamExists)('fetchBulkUsersByEthOrSolAddress', 'addresses', addresses);\n            const localVarPath = `/farcaster/user/bulk-by-address`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (addresses !== undefined) {\n                localVarQueryParameter['addresses'] = addresses;\n            }\n            if (addressTypes) {\n                localVarQueryParameter['address_types'] = addressTypes.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches power users based on Warpcast power badges. Information is updated once a day.\n         * @summary Power users\n         * @param {number} [viewerFid]\n         * @param {number} [limit] Number of power users to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)\n         *\n         */\n        fetchPowerUsers: async (viewerFid, limit, cursor, xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/user/power`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches power users and respond in a backwards compatible format to Warpcast\\'s deprecated power badge endpoint.\n         * @summary Power user FIDs\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)\n         *\n         */\n        fetchPowerUsersLite: async (xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/user/power_lite`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches a list of users given a location\n         * @summary By location\n         * @param {number} latitude Latitude of the location\n         * @param {number} longitude Longitude of the location\n         * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)\n         *\n         */\n        fetchUsersByLocation: async (latitude, longitude, viewerFid, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'latitude' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsersByLocation', 'latitude', latitude);\n            // verify required parameter 'longitude' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsersByLocation', 'longitude', longitude);\n            const localVarPath = `/farcaster/user/by_location`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (latitude !== undefined) {\n                localVarQueryParameter['latitude'] = latitude;\n            }\n            if (longitude !== undefined) {\n                localVarQueryParameter['longitude'] = longitude;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Follow a user \\\\ (In order to follow a user `signer_uuid` must be approved)\n         * @summary Follow user\n         * @param {FollowReqBody} followReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)\n         *\n         */\n        followUser: async (followReqBody, options = {}) => {\n            // verify required parameter 'followReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('followUser', 'followReqBody', followReqBody);\n            const localVarPath = `/farcaster/user/follow`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(followReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)\n         * @summary Fetch fresh FID\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)\n         *\n         */\n        getFreshAccountFID: async (xNeynarExperimental, options = {}) => {\n            const localVarPath = `/farcaster/user/fid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Lookup a user by custody-address\n         * @summary By custody-address\n         * @param {string} custodyAddress Custody Address associated with mnemonic\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)\n         *\n         */\n        lookupUserByCustodyAddress: async (custodyAddress, options = {}) => {\n            // verify required parameter 'custodyAddress' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserByCustodyAddress', 'custodyAddress', custodyAddress);\n            const localVarPath = `/farcaster/user/custody-address`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (custodyAddress !== undefined) {\n                localVarQueryParameter['custody_address'] = custodyAddress;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches a single hydrated user object given a username\n         * @summary By username\n         * @param {string} username Username of the user to fetch\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)\n         *\n         */\n        lookupUserByUsername: async (username, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'username' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserByUsername', 'username', username);\n            const localVarPath = `/farcaster/user/by_username`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (username !== undefined) {\n                localVarQueryParameter['username'] = username;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetches the users who have verified the specified X (Twitter) username\n         * @summary By X username\n         * @param {string} xUsername X (Twitter) username to search for, without the @ symbol\n         * @param {number} [viewerFid] FID of the viewer for contextual information like follows and blocks\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)\n         *\n         */\n        lookupUsersByXUsername: async (xUsername, viewerFid, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'xUsername' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUsersByXUsername', 'xUsername', xUsername);\n            const localVarPath = `/farcaster/user/by_x_username`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (xUsername !== undefined) {\n                localVarQueryParameter['x_username'] = xUsername;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Adds verification for an eth address or contract for the user \\\\ (In order to add verification `signer_uuid` must be approved)\n         * @summary Add verification\n         * @param {AddVerificationReqBody} addVerificationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)\n         *\n         */\n        publishVerification: async (addVerificationReqBody, options = {}) => {\n            // verify required parameter 'addVerificationReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishVerification', 'addVerificationReqBody', addVerificationReqBody);\n            const localVarPath = `/farcaster/user/verification`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addVerificationReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.\n         * @summary Register new account\n         * @param {RegisterUserReqBody} registerUserReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)\n         *\n         */\n        registerAccount: async (registerUserReqBody, options = {}) => {\n            // verify required parameter 'registerUserReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('registerAccount', 'registerUserReqBody', registerUserReqBody);\n            const localVarPath = `/farcaster/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerUserReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Search for Usernames\n         * @summary Search for Usernames\n         * @param {string} q\n         * @param {number} [viewerFid] Providing this will return search results that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of users to fetch  (Default: 5, Maximum: 10)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)\n         *\n         */\n        searchUser: async (q, viewerFid, limit, cursor, xNeynarExperimental, options = {}) => {\n            // verify required parameter 'q' is not null or undefined\n            (0, common_1.assertParamExists)('searchUser', 'q', q);\n            const localVarPath = `/farcaster/user/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (q !== undefined) {\n                localVarQueryParameter['q'] = q;\n            }\n            if (viewerFid !== undefined) {\n                localVarQueryParameter['viewer_fid'] = viewerFid;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (cursor !== undefined) {\n                localVarQueryParameter['cursor'] = cursor;\n            }\n            if (xNeynarExperimental != null) {\n                localVarHeaderParameter['x-neynar-experimental'] = typeof xNeynarExperimental === 'string'\n                    ? xNeynarExperimental\n                    : JSON.stringify(xNeynarExperimental);\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Unfollow a user \\\\ (In order to unfollow a user `signer_uuid` must be approved)\n         * @summary Unfollow user\n         * @param {FollowReqBody} followReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)\n         *\n         */\n        unfollowUser: async (followReqBody, options = {}) => {\n            // verify required parameter 'followReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('unfollowUser', 'followReqBody', followReqBody);\n            const localVarPath = `/farcaster/user/follow`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(followReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update user profile \\\\ (In order to update user\\'s profile `signer_uuid` must be approved)\n         * @summary Update user profile\n         * @param {UpdateUserReqBody} updateUserReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)\n         *\n         */\n        updateUser: async (updateUserReqBody, options = {}) => {\n            // verify required parameter 'updateUserReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('updateUser', 'updateUserReqBody', updateUserReqBody);\n            const localVarPath = `/farcaster/user`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;\n/**\n * UserApi - functional programming interface\n * @export\n */\nconst UserApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Removes verification for an eth address for the user \\\\ (In order to delete verification `signer_uuid` must be approved)\n         * @summary Delete verification\n         * @param {RemoveVerificationReqBody} removeVerificationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)\n         *\n         */\n        async deleteVerification(removeVerificationReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVerification(removeVerificationReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.deleteVerification']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches information about multiple users based on FIDs\n         * @summary By FIDs\n         * @param {string} fids Comma separated list of FIDs, up to 100 at a time\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)\n         *\n         */\n        async fetchBulkUsers(fids, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkUsers(fids, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchBulkUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.\n         * @summary By Eth or Sol addresses\n         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time\n         * @param {Array<BulkUserAddressType>} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \\&#39;custody_address\\&#39; and \\&#39;verified_address\\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values.\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)\n         *\n         */\n        async fetchBulkUsersByEthOrSolAddress(addresses, addressTypes, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchBulkUsersByEthOrSolAddress(addresses, addressTypes, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchBulkUsersByEthOrSolAddress']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches power users based on Warpcast power badges. Information is updated once a day.\n         * @summary Power users\n         * @param {number} [viewerFid]\n         * @param {number} [limit] Number of power users to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)\n         *\n         */\n        async fetchPowerUsers(viewerFid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPowerUsers(viewerFid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchPowerUsers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches power users and respond in a backwards compatible format to Warpcast\\'s deprecated power badge endpoint.\n         * @summary Power user FIDs\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)\n         *\n         */\n        async fetchPowerUsersLite(xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPowerUsersLite(xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchPowerUsersLite']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches a list of users given a location\n         * @summary By location\n         * @param {number} latitude Latitude of the location\n         * @param {number} longitude Longitude of the location\n         * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of results to fetch  (Default: 25, Maximum: 100)\n         * @param {string} [cursor] Pagination cursor\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)\n         *\n         */\n        async fetchUsersByLocation(latitude, longitude, viewerFid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsersByLocation(latitude, longitude, viewerFid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.fetchUsersByLocation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Follow a user \\\\ (In order to follow a user `signer_uuid` must be approved)\n         * @summary Follow user\n         * @param {FollowReqBody} followReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)\n         *\n         */\n        async followUser(followReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(followReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.followUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)\n         * @summary Fetch fresh FID\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)\n         *\n         */\n        async getFreshAccountFID(xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshAccountFID(xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getFreshAccountFID']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Lookup a user by custody-address\n         * @summary By custody-address\n         * @param {string} custodyAddress Custody Address associated with mnemonic\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)\n         *\n         */\n        async lookupUserByCustodyAddress(custodyAddress, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(custodyAddress, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.lookupUserByCustodyAddress']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches a single hydrated user object given a username\n         * @summary By username\n         * @param {string} username Username of the user to fetch\n         * @param {number} [viewerFid]\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)\n         *\n         */\n        async lookupUserByUsername(username, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByUsername(username, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.lookupUserByUsername']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetches the users who have verified the specified X (Twitter) username\n         * @summary By X username\n         * @param {string} xUsername X (Twitter) username to search for, without the @ symbol\n         * @param {number} [viewerFid] FID of the viewer for contextual information like follows and blocks\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)\n         *\n         */\n        async lookupUsersByXUsername(xUsername, viewerFid, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUsersByXUsername(xUsername, viewerFid, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.lookupUsersByXUsername']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Adds verification for an eth address or contract for the user \\\\ (In order to add verification `signer_uuid` must be approved)\n         * @summary Add verification\n         * @param {AddVerificationReqBody} addVerificationReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)\n         *\n         */\n        async publishVerification(addVerificationReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishVerification(addVerificationReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.publishVerification']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.\n         * @summary Register new account\n         * @param {RegisterUserReqBody} registerUserReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)\n         *\n         */\n        async registerAccount(registerUserReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAccount(registerUserReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.registerAccount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Search for Usernames\n         * @summary Search for Usernames\n         * @param {string} q\n         * @param {number} [viewerFid] Providing this will return search results that respects this user\\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.\n         * @param {number} [limit] Number of users to fetch  (Default: 5, Maximum: 10)\n         * @param {string} [cursor] Pagination cursor.\n         * @param {boolean} [xNeynarExperimental] Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)\n         *\n         */\n        async searchUser(q, viewerFid, limit, cursor, xNeynarExperimental, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUser(q, viewerFid, limit, cursor, xNeynarExperimental, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.searchUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Unfollow a user \\\\ (In order to unfollow a user `signer_uuid` must be approved)\n         * @summary Unfollow user\n         * @param {FollowReqBody} followReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)\n         *\n         */\n        async unfollowUser(followReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(followReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.unfollowUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update user profile \\\\ (In order to update user\\'s profile `signer_uuid` must be approved)\n         * @summary Update user profile\n         * @param {UpdateUserReqBody} updateUserReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)\n         *\n         */\n        async updateUser(updateUserReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.updateUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UserApiFp = UserApiFp;\n/**\n * UserApi - factory interface\n * @export\n */\nconst UserApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UserApiFp)(configuration);\n    return {\n        /**\n         * Removes verification for an eth address for the user \\\\ (In order to delete verification `signer_uuid` must be approved)\n         * @summary Delete verification\n         * @param {UserApiDeleteVerificationRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)\n         *\n         */\n        deleteVerification(requestParameters, options) {\n            return localVarFp.deleteVerification(requestParameters.removeVerificationReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches information about multiple users based on FIDs\n         * @summary By FIDs\n         * @param {UserApiFetchBulkUsersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)\n         *\n         */\n        fetchBulkUsers(requestParameters, options) {\n            return localVarFp.fetchBulkUsers(requestParameters.fids, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.\n         * @summary By Eth or Sol addresses\n         * @param {UserApiFetchBulkUsersByEthOrSolAddressRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)\n         *\n         */\n        fetchBulkUsersByEthOrSolAddress(requestParameters, options) {\n            return localVarFp.fetchBulkUsersByEthOrSolAddress(requestParameters.addresses, requestParameters.addressTypes, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches power users based on Warpcast power badges. Information is updated once a day.\n         * @summary Power users\n         * @param {UserApiFetchPowerUsersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)\n         *\n         */\n        fetchPowerUsers(requestParameters = {}, options) {\n            return localVarFp.fetchPowerUsers(requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches power users and respond in a backwards compatible format to Warpcast\\'s deprecated power badge endpoint.\n         * @summary Power user FIDs\n         * @param {UserApiFetchPowerUsersLiteRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)\n         *\n         */\n        fetchPowerUsersLite(requestParameters = {}, options) {\n            return localVarFp.fetchPowerUsersLite(requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches a list of users given a location\n         * @summary By location\n         * @param {UserApiFetchUsersByLocationRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)\n         *\n         */\n        fetchUsersByLocation(requestParameters, options) {\n            return localVarFp.fetchUsersByLocation(requestParameters.latitude, requestParameters.longitude, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Follow a user \\\\ (In order to follow a user `signer_uuid` must be approved)\n         * @summary Follow user\n         * @param {UserApiFollowUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)\n         *\n         */\n        followUser(requestParameters, options) {\n            return localVarFp.followUser(requestParameters.followReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)\n         * @summary Fetch fresh FID\n         * @param {UserApiGetFreshAccountFIDRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)\n         *\n         */\n        getFreshAccountFID(requestParameters = {}, options) {\n            return localVarFp.getFreshAccountFID(requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Lookup a user by custody-address\n         * @summary By custody-address\n         * @param {UserApiLookupUserByCustodyAddressRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)\n         *\n         */\n        lookupUserByCustodyAddress(requestParameters, options) {\n            return localVarFp.lookupUserByCustodyAddress(requestParameters.custodyAddress, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches a single hydrated user object given a username\n         * @summary By username\n         * @param {UserApiLookupUserByUsernameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)\n         *\n         */\n        lookupUserByUsername(requestParameters, options) {\n            return localVarFp.lookupUserByUsername(requestParameters.username, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetches the users who have verified the specified X (Twitter) username\n         * @summary By X username\n         * @param {UserApiLookupUsersByXUsernameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)\n         *\n         */\n        lookupUsersByXUsername(requestParameters, options) {\n            return localVarFp.lookupUsersByXUsername(requestParameters.xUsername, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Adds verification for an eth address or contract for the user \\\\ (In order to add verification `signer_uuid` must be approved)\n         * @summary Add verification\n         * @param {UserApiPublishVerificationRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)\n         *\n         */\n        publishVerification(requestParameters, options) {\n            return localVarFp.publishVerification(requestParameters.addVerificationReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.\n         * @summary Register new account\n         * @param {UserApiRegisterAccountRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)\n         *\n         */\n        registerAccount(requestParameters, options) {\n            return localVarFp.registerAccount(requestParameters.registerUserReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Search for Usernames\n         * @summary Search for Usernames\n         * @param {UserApiSearchUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)\n         *\n         */\n        searchUser(requestParameters, options) {\n            return localVarFp.searchUser(requestParameters.q, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Unfollow a user \\\\ (In order to unfollow a user `signer_uuid` must be approved)\n         * @summary Unfollow user\n         * @param {UserApiUnfollowUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)\n         *\n         */\n        unfollowUser(requestParameters, options) {\n            return localVarFp.unfollowUser(requestParameters.followReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update user profile \\\\ (In order to update user\\'s profile `signer_uuid` must be approved)\n         * @summary Update user profile\n         * @param {UserApiUpdateUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)\n         *\n         */\n        updateUser(requestParameters, options) {\n            return localVarFp.updateUser(requestParameters.updateUserReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UserApiFactory = UserApiFactory;\n/**\n * UserApi - object-oriented interface\n * @export\n * @class UserApi\n * @extends {BaseAPI}\n */\nclass UserApi extends base_1.BaseAPI {\n    /**\n     * Removes verification for an eth address for the user \\\\ (In order to delete verification `signer_uuid` must be approved)\n     * @summary Delete verification\n     * @param {UserApiDeleteVerificationRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)\n     *\n     */\n    deleteVerification(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).deleteVerification(requestParameters.removeVerificationReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches information about multiple users based on FIDs\n     * @summary By FIDs\n     * @param {UserApiFetchBulkUsersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)\n     *\n     */\n    fetchBulkUsers(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).fetchBulkUsers(requestParameters.fids, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.\n     * @summary By Eth or Sol addresses\n     * @param {UserApiFetchBulkUsersByEthOrSolAddressRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)\n     *\n     */\n    fetchBulkUsersByEthOrSolAddress(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).fetchBulkUsersByEthOrSolAddress(requestParameters.addresses, requestParameters.addressTypes, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches power users based on Warpcast power badges. Information is updated once a day.\n     * @summary Power users\n     * @param {UserApiFetchPowerUsersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)\n     *\n     */\n    fetchPowerUsers(requestParameters = {}, options) {\n        return (0, exports.UserApiFp)(this.configuration).fetchPowerUsers(requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches power users and respond in a backwards compatible format to Warpcast\\'s deprecated power badge endpoint.\n     * @summary Power user FIDs\n     * @param {UserApiFetchPowerUsersLiteRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)\n     *\n     */\n    fetchPowerUsersLite(requestParameters = {}, options) {\n        return (0, exports.UserApiFp)(this.configuration).fetchPowerUsersLite(requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches a list of users given a location\n     * @summary By location\n     * @param {UserApiFetchUsersByLocationRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)\n     *\n     */\n    fetchUsersByLocation(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).fetchUsersByLocation(requestParameters.latitude, requestParameters.longitude, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Follow a user \\\\ (In order to follow a user `signer_uuid` must be approved)\n     * @summary Follow user\n     * @param {UserApiFollowUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)\n     *\n     */\n    followUser(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).followUser(requestParameters.followReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)\n     * @summary Fetch fresh FID\n     * @param {UserApiGetFreshAccountFIDRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)\n     *\n     */\n    getFreshAccountFID(requestParameters = {}, options) {\n        return (0, exports.UserApiFp)(this.configuration).getFreshAccountFID(requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Lookup a user by custody-address\n     * @summary By custody-address\n     * @param {UserApiLookupUserByCustodyAddressRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)\n     *\n     */\n    lookupUserByCustodyAddress(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).lookupUserByCustodyAddress(requestParameters.custodyAddress, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches a single hydrated user object given a username\n     * @summary By username\n     * @param {UserApiLookupUserByUsernameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)\n     *\n     */\n    lookupUserByUsername(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).lookupUserByUsername(requestParameters.username, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetches the users who have verified the specified X (Twitter) username\n     * @summary By X username\n     * @param {UserApiLookupUsersByXUsernameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)\n     *\n     */\n    lookupUsersByXUsername(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).lookupUsersByXUsername(requestParameters.xUsername, requestParameters.viewerFid, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Adds verification for an eth address or contract for the user \\\\ (In order to add verification `signer_uuid` must be approved)\n     * @summary Add verification\n     * @param {UserApiPublishVerificationRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)\n     *\n     */\n    publishVerification(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).publishVerification(requestParameters.addVerificationReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.\n     * @summary Register new account\n     * @param {UserApiRegisterAccountRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)\n     *\n     */\n    registerAccount(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).registerAccount(requestParameters.registerUserReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Search for Usernames\n     * @summary Search for Usernames\n     * @param {UserApiSearchUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)\n     *\n     */\n    searchUser(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).searchUser(requestParameters.q, requestParameters.viewerFid, requestParameters.limit, requestParameters.cursor, requestParameters.xNeynarExperimental, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Unfollow a user \\\\ (In order to unfollow a user `signer_uuid` must be approved)\n     * @summary Unfollow user\n     * @param {UserApiUnfollowUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)\n     *\n     */\n    unfollowUser(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).unfollowUser(requestParameters.followReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update user profile \\\\ (In order to update user\\'s profile `signer_uuid` must be approved)\n     * @summary Update user profile\n     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserApi\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)\n     *\n     */\n    updateUser(requestParameters, options) {\n        return (0, exports.UserApiFp)(this.configuration).updateUser(requestParameters.updateUserReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UserApi = UserApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3VzZXItYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsZ0NBQWdDO0FBQy9GLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywwRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7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QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNDQUFzQztBQUNyRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvYXBpL2FwaXMvdXNlci1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVzZXJBcGkgPSBleHBvcnRzLlVzZXJBcGlGYWN0b3J5ID0gZXhwb3J0cy5Vc2VyQXBpRnAgPSBleHBvcnRzLlVzZXJBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIFVzZXJBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBVc2VyQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3MgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgdmVyaWZpY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keX0gcmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtdmVyaWZpY2F0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlVmVyaWZpY2F0aW9uOiBhc3luYyAocmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdyZW1vdmVWZXJpZmljYXRpb25SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlbGV0ZVZlcmlmaWNhdGlvbicsICdyZW1vdmVWZXJpZmljYXRpb25SZXFCb2R5JywgcmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL3ZlcmlmaWNhdGlvbmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0RFTEVURScgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkocmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBtdWx0aXBsZSB1c2VycyBiYXNlZCBvbiBGSURzXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEZJRHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZHMgQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRklEcywgdXAgdG8gMTAwIGF0IGEgdGltZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQnVsa1VzZXJzOiBhc3luYyAoZmlkcywgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZHMnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hCdWxrVXNlcnMnLCAnZmlkcycsIGZpZHMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlci9idWxrYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZHMnXSA9IGZpZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhbGwgdXNlcnMgYmFzZWQgb24gbXVsdGlwbGUgRXRoZXJldW0gb3IgU29sYW5hIGFkZHJlc3Nlcy4gIEVhY2ggZmFyY2FzdGVyIHVzZXIgaGFzIGEgY3VzdG9keSBFdGhlcmV1bSBhZGRyZXNzIGFuZCBvcHRpb25hbGx5IHZlcmlmaWVkIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuIFRoaXMgZW5kcG9pbnQgcmV0dXJucyBhbGwgdXNlcnMgdGhhdCBoYXZlIGFueSBvZiB0aGUgZ2l2ZW4gYWRkcmVzc2VzIGFzIHRoZWlyIGN1c3RvZHkgb3IgdmVyaWZpZWQgRXRoZXJldW0gb3IgU29sYW5hIGFkZHJlc3Nlcy4gIEEgY3VzdG9keSBhZGRyZXNzIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggb25seSAxIGZhcmNhc3RlciB1c2VyIGF0IGEgdGltZSBidXQgYSB2ZXJpZmllZCBhZGRyZXNzIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggbXVsdGlwbGUgdXNlcnMuIFlvdSBjYW4gcGFzcyBpbiBFdGhlcmV1bSBhbmQgU29sYW5hIGFkZHJlc3NlcywgY29tbWEgc2VwYXJhdGVkLCBpbiB0aGUgc2FtZSByZXF1ZXN0LiBUaGUgcmVzcG9uc2Ugd2lsbCBjb250YWluIHVzZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzc2VzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBFdGggb3IgU29sIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc2VzIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIEV0aGVyZXVtIGFkZHJlc3NlcywgdXAgdG8gMzUwIGF0IGEgdGltZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEJ1bGtVc2VyQWRkcmVzc1R5cGU+fSBbYWRkcmVzc1R5cGVzXSBDdXN0b21pemUgd2hpY2ggYWRkcmVzcyB0eXBlcyB0aGUgcmVxdWVzdCBzaG91bGQgc2VhcmNoIGZvci4gVGhpcyBpcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgdGhhdCBjYW4gaW5jbHVkZSB0aGUgZm9sbG93aW5nIHZhbHVlczogXFwmIzM5O2N1c3RvZHlfYWRkcmVzc1xcJiMzOTsgYW5kIFxcJiMzOTt2ZXJpZmllZF9hZGRyZXNzXFwmIzM5Oy4gQnkgZGVmYXVsdCBhcGkgcmV0dXJucyBib3RoLiBUbyBzZWxlY3QgbXVsdGlwbGUgdHlwZXMsIHVzZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHRoZXNlIHZhbHVlcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc0J5QWRkcmVzc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzQnlBZGRyZXNzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstdXNlcnMtYnktZXRoLW9yLXNvbC1hZGRyZXNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzczogYXN5bmMgKGFkZHJlc3NlcywgYWRkcmVzc1R5cGVzLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc2VzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQnVsa1VzZXJzQnlFdGhPclNvbEFkZHJlc3MnLCAnYWRkcmVzc2VzJywgYWRkcmVzc2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvYnVsay1ieS1hZGRyZXNzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYWRkcmVzc2VzJ10gPSBhZGRyZXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGVzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnYWRkcmVzc190eXBlcyddID0gYWRkcmVzc1R5cGVzLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgcG93ZXIgdXNlcnMgYmFzZWQgb24gV2FycGNhc3QgcG93ZXIgYmFkZ2VzLiBJbmZvcm1hdGlvbiBpcyB1cGRhdGVkIG9uY2UgYSBkYXkuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvd2VyIHVzZXJzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcG93ZXIgdXNlcnMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1wb3dlci11c2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUG93ZXJVc2VyczogYXN5bmMgKHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL3Bvd2VyYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHBvd2VyIHVzZXJzIGFuZCByZXNwb25kIGluIGEgYmFja3dhcmRzIGNvbXBhdGlibGUgZm9ybWF0IHRvIFdhcnBjYXN0XFwncyBkZXByZWNhdGVkIHBvd2VyIGJhZGdlIGVuZHBvaW50LlxuICAgICAgICAgKiBAc3VtbWFyeSBQb3dlciB1c2VyIEZJRHNcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclBvd2VyTGl0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclBvd2VyTGl0ZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1wb3dlci11c2Vycy1saXRlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hQb3dlclVzZXJzTGl0ZTogYXN5bmMgKHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlci9wb3dlcl9saXRlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYSBsaXN0IG9mIHVzZXJzIGdpdmVuIGEgbG9jYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgQnkgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdGl0dWRlIExhdGl0dWRlIG9mIHRoZSBsb2NhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiB0aGUgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIEZJRCBvZiB0aGUgdXNlciB2aWV3aW5nIHRoZSBmZWVkLiBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgdXNlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWJ5LWxvY2F0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2Vyc0J5TG9jYXRpb246IGFzeW5jIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbGF0aXR1ZGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2Vyc0J5TG9jYXRpb24nLCAnbGF0aXR1ZGUnLCBsYXRpdHVkZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdsb25naXR1ZGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2Vyc0J5TG9jYXRpb24nLCAnbG9uZ2l0dWRlJywgbG9uZ2l0dWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvYnlfbG9jYXRpb25gO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGF0aXR1ZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xhdGl0dWRlJ10gPSBsYXRpdHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb25naXR1ZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xvbmdpdHVkZSddID0gbG9uZ2l0dWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdlckZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndmlld2VyX2ZpZCddID0gdmlld2VyRmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjdXJzb3InXSA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4TmV5bmFyRXhwZXJpbWVudGFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsneC1uZXluYXItZXhwZXJpbWVudGFsJ10gPSB0eXBlb2YgeE5leW5hckV4cGVyaW1lbnRhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyB4TmV5bmFyRXhwZXJpbWVudGFsXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoeE5leW5hckV4cGVyaW1lbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xsb3cgYSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3cgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge0ZvbGxvd1JlcUJvZHl9IGZvbGxvd1JlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa0ZvbGxvd1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0ZvbGxvd1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mb2xsb3ctdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZvbGxvd1VzZXI6IGFzeW5jIChmb2xsb3dSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZvbGxvd1JlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZm9sbG93VXNlcicsICdmb2xsb3dSZXFCb2R5JywgZm9sbG93UmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2ZvbGxvd2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGZvbGxvd1JlcUJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgRklEIHRvIFthc3NpZ24gaXQgdG8gbmV3IHVzZXJdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50KVxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBmcmVzaCBGSURcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlckZJRFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlckZJRFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9nZXQtZnJlc2gtYWNjb3VudC1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGcmVzaEFjY291bnRGSUQ6IGFzeW5jICh4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvZmlkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvb2t1cCBhIHVzZXIgYnkgY3VzdG9keS1hZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGN1c3RvZHktYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VzdG9keUFkZHJlc3MgQ3VzdG9keSBBZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBtbmVtb25pY1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLWJ5LWN1c3RvZHktYWRkcmVzcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJCeUN1c3RvZHlBZGRyZXNzOiBhc3luYyAoY3VzdG9keUFkZHJlc3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3VzdG9keUFkZHJlc3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwVXNlckJ5Q3VzdG9keUFkZHJlc3MnLCAnY3VzdG9keUFkZHJlc3MnLCBjdXN0b2R5QWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2N1c3RvZHktYWRkcmVzc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChjdXN0b2R5QWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnY3VzdG9keV9hZGRyZXNzJ10gPSBjdXN0b2R5QWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYSBzaW5nbGUgaHlkcmF0ZWQgdXNlciBvYmplY3QgZ2l2ZW4gYSB1c2VybmFtZVxuICAgICAgICAgKiBAc3VtbWFyeSBCeSB1c2VybmFtZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVXNlcm5hbWUgb2YgdGhlIHVzZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItYnktdXNlcm5hbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBVc2VyQnlVc2VybmFtZTogYXN5bmMgKHVzZXJuYW1lLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndXNlcm5hbWUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwVXNlckJ5VXNlcm5hbWUnLCAndXNlcm5hbWUnLCB1c2VybmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2J5X3VzZXJuYW1lYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHVzZXJuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd1c2VybmFtZSddID0gdXNlcm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyB0aGUgdXNlcnMgd2hvIGhhdmUgdmVyaWZpZWQgdGhlIHNwZWNpZmllZCBYIChUd2l0dGVyKSB1c2VybmFtZVxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBYIHVzZXJuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB4VXNlcm5hbWUgWCAoVHdpdHRlcikgdXNlcm5hbWUgdG8gc2VhcmNoIGZvciwgd2l0aG91dCB0aGUgQCBzeW1ib2xcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIEZJRCBvZiB0aGUgdmlld2VyIGZvciBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGxpa2UgZm9sbG93cyBhbmQgYmxvY2tzXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2Vycy1ieS14LXVzZXJuYW1lKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwVXNlcnNCeVhVc2VybmFtZTogYXN5bmMgKHhVc2VybmFtZSwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3hVc2VybmFtZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBVc2Vyc0J5WFVzZXJuYW1lJywgJ3hVc2VybmFtZScsIHhVc2VybmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci91c2VyL2J5X3hfdXNlcm5hbWVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoeFVzZXJuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd4X3VzZXJuYW1lJ10gPSB4VXNlcm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeE5leW5hckV4cGVyaW1lbnRhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddID0gdHlwZW9mIHhOZXluYXJFeHBlcmltZW50YWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8geE5leW5hckV4cGVyaW1lbnRhbFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHhOZXluYXJFeHBlcmltZW50YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB2ZXJpZmljYXRpb24gZm9yIGFuIGV0aCBhZGRyZXNzIG9yIGNvbnRyYWN0IGZvciB0aGUgdXNlciBcXFxcIChJbiBvcmRlciB0byBhZGQgdmVyaWZpY2F0aW9uIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIHZlcmlmaWNhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0FkZFZlcmlmaWNhdGlvblJlcUJvZHl9IGFkZFZlcmlmaWNhdGlvblJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC12ZXJpZmljYXRpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoVmVyaWZpY2F0aW9uOiBhc3luYyAoYWRkVmVyaWZpY2F0aW9uUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRWZXJpZmljYXRpb25SZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hWZXJpZmljYXRpb24nLCAnYWRkVmVyaWZpY2F0aW9uUmVxQm9keScsIGFkZFZlcmlmaWNhdGlvblJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlci92ZXJpZmljYXRpb25gO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShhZGRWZXJpZmljYXRpb25SZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhY2NvdW50IG9uIGZhcmNhc3Rlci4gICoqTm90ZToqKiBUaGlzIEFQSSBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gMTAgbWludXRlcyBvZiB0aGUgZmV0Y2ggRklEIEFQSSBjYWxsIChpLmUuLCAvdjIvZmFyY2FzdGVyL3VzZXIvZmlkKS4gT3RoZXJ3aXNlLCBOZXluYXIgd2lsbCBhc3NpZ24gdGhpcyBGSUQgdG8gYW5vdGhlciBhdmFpbGFibGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgbmV3IGFjY291bnRcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlclVzZXJSZXFCb2R5fSByZWdpc3RlclVzZXJSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZ2lzdGVyVXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVnaXN0ZXJVc2VyUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLWFjY291bnQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlckFjY291bnQ6IGFzeW5jIChyZWdpc3RlclVzZXJSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3JlZ2lzdGVyVXNlclJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVnaXN0ZXJBY2NvdW50JywgJ3JlZ2lzdGVyVXNlclJlcUJvZHknLCByZWdpc3RlclVzZXJSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXJgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZWdpc3RlclVzZXJSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2ggZm9yIFVzZXJuYW1lc1xuICAgICAgICAgKiBAc3VtbWFyeSBTZWFyY2ggZm9yIFVzZXJuYW1lc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gc2VhcmNoIHJlc3VsdHMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXJcXCYjMzk7cyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyAmI3g2MDt2aWV3ZXJfY29udGV4dCYjeDYwOy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHVzZXJzIHRvIGZldGNoICAoRGVmYXVsdDogNSwgTWF4aW11bTogMTApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclNlYXJjaFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclNlYXJjaFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaFVzZXI6IGFzeW5jIChxLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdzZWFyY2hVc2VyJywgJ3EnLCBxKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvc2VhcmNoYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3EnXSA9IHE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld2VyRmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd2aWV3ZXJfZmlkJ10gPSB2aWV3ZXJGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2N1cnNvciddID0gY3Vyc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhOZXluYXJFeHBlcmltZW50YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWyd4LW5leW5hci1leHBlcmltZW50YWwnXSA9IHR5cGVvZiB4TmV5bmFyRXhwZXJpbWVudGFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHhOZXluYXJFeHBlcmltZW50YWxcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh4TmV5bmFyRXhwZXJpbWVudGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuZm9sbG93IGEgdXNlciBcXFxcIChJbiBvcmRlciB0byB1bmZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93UmVxQm9keX0gZm9sbG93UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrRm9sbG93UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrRm9sbG93UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB1bmZvbGxvd1VzZXI6IGFzeW5jIChmb2xsb3dSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZvbGxvd1JlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndW5mb2xsb3dVc2VyJywgJ2ZvbGxvd1JlcUJvZHknLCBmb2xsb3dSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3VzZXIvZm9sbG93YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShmb2xsb3dSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdXNlciBwcm9maWxlIFxcXFwgKEluIG9yZGVyIHRvIHVwZGF0ZSB1c2VyXFwncyBwcm9maWxlIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIHVzZXIgcHJvZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVVzZXJSZXFCb2R5fSB1cGRhdGVVc2VyUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVVzZXI6IGFzeW5jICh1cGRhdGVVc2VyUmVxQm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd1cGRhdGVVc2VyUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCd1cGRhdGVVc2VyJywgJ3VwZGF0ZVVzZXJSZXFCb2R5JywgdXBkYXRlVXNlclJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvdXNlcmA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BBVENIJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKSh1cGRhdGVVc2VyUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Vc2VyQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBVc2VyQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFVzZXJBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBVc2VyQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Vc2VyQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3MgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgdmVyaWZpY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keX0gcmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtdmVyaWZpY2F0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZGVsZXRlVmVyaWZpY2F0aW9uKHJlbW92ZVZlcmlmaWNhdGlvblJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZVZlcmlmaWNhdGlvbihyZW1vdmVWZXJpZmljYXRpb25SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5kZWxldGVWZXJpZmljYXRpb24nXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgbXVsdGlwbGUgdXNlcnMgYmFzZWQgb24gRklEc1xuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSURzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWRzIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIEZJRHMsIHVwIHRvIDEwMCBhdCBhIHRpbWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstdXNlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEJ1bGtVc2VycyhmaWRzLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQnVsa1VzZXJzKGZpZHMsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1VzZXJBcGkuZmV0Y2hCdWxrVXNlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYWxsIHVzZXJzIGJhc2VkIG9uIG11bHRpcGxlIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuICBFYWNoIGZhcmNhc3RlciB1c2VyIGhhcyBhIGN1c3RvZHkgRXRoZXJldW0gYWRkcmVzcyBhbmQgb3B0aW9uYWxseSB2ZXJpZmllZCBFdGhlcmV1bSBvciBTb2xhbmEgYWRkcmVzc2VzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgYWxsIHVzZXJzIHRoYXQgaGF2ZSBhbnkgb2YgdGhlIGdpdmVuIGFkZHJlc3NlcyBhcyB0aGVpciBjdXN0b2R5IG9yIHZlcmlmaWVkIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuICBBIGN1c3RvZHkgYWRkcmVzcyBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIG9ubHkgMSBmYXJjYXN0ZXIgdXNlciBhdCBhIHRpbWUgYnV0IGEgdmVyaWZpZWQgYWRkcmVzcyBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIG11bHRpcGxlIHVzZXJzLiBZb3UgY2FuIHBhc3MgaW4gRXRoZXJldW0gYW5kIFNvbGFuYSBhZGRyZXNzZXMsIGNvbW1hIHNlcGFyYXRlZCwgaW4gdGhlIHNhbWUgcmVxdWVzdC4gVGhlIHJlc3BvbnNlIHdpbGwgY29udGFpbiB1c2VycyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFkZHJlc3Nlcy5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgRXRoIG9yIFNvbCBhZGRyZXNzZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NlcyBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBFdGhlcmV1bSBhZGRyZXNzZXMsIHVwIHRvIDM1MCBhdCBhIHRpbWVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxCdWxrVXNlckFkZHJlc3NUeXBlPn0gW2FkZHJlc3NUeXBlc10gQ3VzdG9taXplIHdoaWNoIGFkZHJlc3MgdHlwZXMgdGhlIHJlcXVlc3Qgc2hvdWxkIHNlYXJjaCBmb3IuIFRoaXMgaXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIHRoYXQgY2FuIGluY2x1ZGUgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IFxcJiMzOTtjdXN0b2R5X2FkZHJlc3NcXCYjMzk7IGFuZCBcXCYjMzk7dmVyaWZpZWRfYWRkcmVzc1xcJiMzOTsuIEJ5IGRlZmF1bHQgYXBpIHJldHVybnMgYm90aC4gVG8gc2VsZWN0IG11bHRpcGxlIHR5cGVzLCB1c2UgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGVzZSB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlld2VyRmlkXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrVXNlcnNCeUFkZHJlc3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtVc2Vyc0J5QWRkcmVzc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1idWxrLXVzZXJzLWJ5LWV0aC1vci1zb2wtYWRkcmVzcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQnVsa1VzZXJzQnlFdGhPclNvbEFkZHJlc3MoYWRkcmVzc2VzLCBhZGRyZXNzVHlwZXMsIHZpZXdlckZpZCwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzcyhhZGRyZXNzZXMsIGFkZHJlc3NUeXBlcywgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5mZXRjaEJ1bGtVc2Vyc0J5RXRoT3JTb2xBZGRyZXNzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHBvd2VyIHVzZXJzIGJhc2VkIG9uIFdhcnBjYXN0IHBvd2VyIGJhZGdlcy4gSW5mb3JtYXRpb24gaXMgdXBkYXRlZCBvbmNlIGEgZGF5LlxuICAgICAgICAgKiBAc3VtbWFyeSBQb3dlciB1c2Vyc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gTnVtYmVyIG9mIHBvd2VyIHVzZXJzIHRvIGZldGNoICAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JdIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcG93ZXItdXNlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFBvd2VyVXNlcnModmlld2VyRmlkLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFBvd2VyVXNlcnModmlld2VyRmlkLCBsaW1pdCwgY3Vyc29yLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5mZXRjaFBvd2VyVXNlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgcG93ZXIgdXNlcnMgYW5kIHJlc3BvbmQgaW4gYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmb3JtYXQgdG8gV2FycGNhc3RcXCdzIGRlcHJlY2F0ZWQgcG93ZXIgYmFkZ2UgZW5kcG9pbnQuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvd2VyIHVzZXIgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyUG93ZXJMaXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyUG93ZXJMaXRlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvd2VyLXVzZXJzLWxpdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFBvd2VyVXNlcnNMaXRlKHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoUG93ZXJVc2Vyc0xpdGUoeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1VzZXJBcGkuZmV0Y2hQb3dlclVzZXJzTGl0ZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhIGxpc3Qgb2YgdXNlcnMgZ2l2ZW4gYSBsb2NhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBsb2NhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgdGhlIGxvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIHRoZSBsb2NhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gRklEIG9mIHRoZSB1c2VyIHZpZXdpbmcgdGhlIGZlZWQuIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiB1c2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlclxcJiMzOTtzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzICYjeDYwO3ZpZXdlcl9jb250ZXh0JiN4NjA7LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAgKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yXSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt4TmV5bmFyRXhwZXJpbWVudGFsXSBFbmFibGVzIGV4cGVyaW1lbnRhbCBmZWF0dXJlcyBpbmNsdWRpbmcgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZSBOZXluYXIgc2NvcmUuIFNlZSBbZG9jc10oaHR0cHM6Ly9uZXluYXIubm90aW9uLnNpdGUvRXhwZXJpbWVudGFsLUZlYXR1cmVzLTFkMjY1NTE5NWE4YjgwZWI5OGI0ZDRhZTdiNzZhZTRhKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcnMtYnktbG9jYXRpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJzQnlMb2NhdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlcnNCeUxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1VzZXJBcGkuZmV0Y2hVc2Vyc0J5TG9jYXRpb24nXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvbGxvdyBhIHVzZXIgXFxcXCAoSW4gb3JkZXIgdG8gZm9sbG93IGEgdXNlciBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IEZvbGxvdyB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93UmVxQm9keX0gZm9sbG93UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrRm9sbG93UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrRm9sbG93UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZvbGxvdy11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZm9sbG93VXNlcihmb2xsb3dSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mb2xsb3dVc2VyKGZvbGxvd1JlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLmZvbGxvd1VzZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgRklEIHRvIFthc3NpZ24gaXQgdG8gbmV3IHVzZXJdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50KVxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBmcmVzaCBGSURcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlckZJRFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlckZJRFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9nZXQtZnJlc2gtYWNjb3VudC1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRGcmVzaEFjY291bnRGSUQoeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RnJlc2hBY2NvdW50RklEKHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLmdldEZyZXNoQWNjb3VudEZJRCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGEgdXNlciBieSBjdXN0b2R5LWFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgQnkgY3VzdG9keS1hZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b2R5QWRkcmVzcyBDdXN0b2R5IEFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIG1uZW1vbmljXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItYnktY3VzdG9keS1hZGRyZXNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwVXNlckJ5Q3VzdG9keUFkZHJlc3MoY3VzdG9keUFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFVzZXJCeUN1c3RvZHlBZGRyZXNzKGN1c3RvZHlBZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5sb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBhIHNpbmdsZSBoeWRyYXRlZCB1c2VyIG9iamVjdCBnaXZlbiBhIHVzZXJuYW1lXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IHVzZXJuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBVc2VybmFtZSBvZiB0aGUgdXNlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1ieS11c2VybmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cFVzZXJCeVVzZXJuYW1lKHVzZXJuYW1lLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFVzZXJCeVVzZXJuYW1lKHVzZXJuYW1lLCB2aWV3ZXJGaWQsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLmxvb2t1cFVzZXJCeVVzZXJuYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIHRoZSB1c2VycyB3aG8gaGF2ZSB2ZXJpZmllZCB0aGUgc3BlY2lmaWVkIFggKFR3aXR0ZXIpIHVzZXJuYW1lXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IFggdXNlcm5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHhVc2VybmFtZSBYIChUd2l0dGVyKSB1c2VybmFtZSB0byBzZWFyY2ggZm9yLCB3aXRob3V0IHRoZSBAIHN5bWJvbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdlckZpZF0gRklEIG9mIHRoZSB2aWV3ZXIgZm9yIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gbGlrZSBmb2xsb3dzIGFuZCBibG9ja3NcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbeE5leW5hckV4cGVyaW1lbnRhbF0gRW5hYmxlcyBleHBlcmltZW50YWwgZmVhdHVyZXMgaW5jbHVkaW5nIGZpbHRlcmluZyBiYXNlZCBvbiB0aGUgTmV5bmFyIHNjb3JlLiBTZWUgW2RvY3NdKGh0dHBzOi8vbmV5bmFyLm5vdGlvbi5zaXRlL0V4cGVyaW1lbnRhbC1GZWF0dXJlcy0xZDI2NTUxOTVhOGI4MGViOThiNGQ0YWU3Yjc2YWU0YSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXJzLWJ5LXgtdXNlcm5hbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsb29rdXBVc2Vyc0J5WFVzZXJuYW1lKHhVc2VybmFtZSwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5sb29rdXBVc2Vyc0J5WFVzZXJuYW1lKHhVc2VybmFtZSwgdmlld2VyRmlkLCB4TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5sb29rdXBVc2Vyc0J5WFVzZXJuYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3Mgb3IgY29udHJhY3QgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGFkZCB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBBZGQgdmVyaWZpY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7QWRkVmVyaWZpY2F0aW9uUmVxQm9keX0gYWRkVmVyaWZpY2F0aW9uUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLXZlcmlmaWNhdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hWZXJpZmljYXRpb24oYWRkVmVyaWZpY2F0aW9uUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucHVibGlzaFZlcmlmaWNhdGlvbihhZGRWZXJpZmljYXRpb25SZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS5wdWJsaXNoVmVyaWZpY2F0aW9uJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhY2NvdW50IG9uIGZhcmNhc3Rlci4gICoqTm90ZToqKiBUaGlzIEFQSSBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gMTAgbWludXRlcyBvZiB0aGUgZmV0Y2ggRklEIEFQSSBjYWxsIChpLmUuLCAvdjIvZmFyY2FzdGVyL3VzZXIvZmlkKS4gT3RoZXJ3aXNlLCBOZXluYXIgd2lsbCBhc3NpZ24gdGhpcyBGSUQgdG8gYW5vdGhlciBhdmFpbGFibGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgbmV3IGFjY291bnRcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlclVzZXJSZXFCb2R5fSByZWdpc3RlclVzZXJSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZ2lzdGVyVXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVnaXN0ZXJVc2VyUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLWFjY291bnQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZWdpc3RlckFjY291bnQocmVnaXN0ZXJVc2VyUmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVnaXN0ZXJBY2NvdW50KHJlZ2lzdGVyVXNlclJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLnJlZ2lzdGVyQWNjb3VudCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoIGZvciBVc2VybmFtZXNcbiAgICAgICAgICogQHN1bW1hcnkgU2VhcmNoIGZvciBVc2VybmFtZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt2aWV3ZXJGaWRdIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIHNlYXJjaCByZXN1bHRzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyXFwmIzM5O3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgJiN4NjA7dmlld2VyX2NvbnRleHQmI3g2MDsuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIE51bWJlciBvZiB1c2VycyB0byBmZXRjaCAgKERlZmF1bHQ6IDUsIE1heGltdW06IDEwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvcl0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3hOZXluYXJFeHBlcmltZW50YWxdIEVuYWJsZXMgZXhwZXJpbWVudGFsIGZlYXR1cmVzIGluY2x1ZGluZyBmaWx0ZXJpbmcgYmFzZWQgb24gdGhlIE5leW5hciBzY29yZS4gU2VlIFtkb2NzXShodHRwczovL25leW5hci5ub3Rpb24uc2l0ZS9FeHBlcmltZW50YWwtRmVhdHVyZXMtMWQyNjU1MTk1YThiODBlYjk4YjRkNGFlN2I3NmFlNGEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJTZWFyY2hSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBzZWFyY2hVc2VyKHEsIHZpZXdlckZpZCwgbGltaXQsIGN1cnNvciwgeE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3Iuc2VhcmNoVXNlcihxLCB2aWV3ZXJGaWQsIGxpbWl0LCBjdXJzb3IsIHhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLnNlYXJjaFVzZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuZm9sbG93IGEgdXNlciBcXFxcIChJbiBvcmRlciB0byB1bmZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Rm9sbG93UmVxQm9keX0gZm9sbG93UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrRm9sbG93UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrRm9sbG93UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1bmZvbGxvd1VzZXIoZm9sbG93UmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IudW5mb2xsb3dVc2VyKGZvbGxvd1JlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyQXBpLnVuZm9sbG93VXNlciddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHVzZXIgcHJvZmlsZSBcXFxcIChJbiBvcmRlciB0byB1cGRhdGUgdXNlclxcJ3MgcHJvZmlsZSBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSB1c2VyIHByb2ZpbGVcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVVc2VyUmVxQm9keX0gdXBkYXRlVXNlclJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1cGRhdGVVc2VyKHVwZGF0ZVVzZXJSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci51cGRhdGVVc2VyKHVwZGF0ZVVzZXJSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlckFwaS51cGRhdGVVc2VyJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlVzZXJBcGlGcCA9IFVzZXJBcGlGcDtcbi8qKlxuICogVXNlckFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Vc2VyQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3MgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgdmVyaWZpY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaURlbGV0ZVZlcmlmaWNhdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLXZlcmlmaWNhdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVZlcmlmaWNhdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlVmVyaWZpY2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLnJlbW92ZVZlcmlmaWNhdGlvblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IG11bHRpcGxlIHVzZXJzIGJhc2VkIG9uIEZJRHNcbiAgICAgICAgICogQHN1bW1hcnkgQnkgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge1VzZXJBcGlGZXRjaEJ1bGtVc2Vyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQnVsa1VzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEJ1bGtVc2VycyhyZXF1ZXN0UGFyYW1ldGVycy5maWRzLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaGVzIGFsbCB1c2VycyBiYXNlZCBvbiBtdWx0aXBsZSBFdGhlcmV1bSBvciBTb2xhbmEgYWRkcmVzc2VzLiAgRWFjaCBmYXJjYXN0ZXIgdXNlciBoYXMgYSBjdXN0b2R5IEV0aGVyZXVtIGFkZHJlc3MgYW5kIG9wdGlvbmFsbHkgdmVyaWZpZWQgRXRoZXJldW0gb3IgU29sYW5hIGFkZHJlc3Nlcy4gVGhpcyBlbmRwb2ludCByZXR1cm5zIGFsbCB1c2VycyB0aGF0IGhhdmUgYW55IG9mIHRoZSBnaXZlbiBhZGRyZXNzZXMgYXMgdGhlaXIgY3VzdG9keSBvciB2ZXJpZmllZCBFdGhlcmV1bSBvciBTb2xhbmEgYWRkcmVzc2VzLiAgQSBjdXN0b2R5IGFkZHJlc3MgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBvbmx5IDEgZmFyY2FzdGVyIHVzZXIgYXQgYSB0aW1lIGJ1dCBhIHZlcmlmaWVkIGFkZHJlc3MgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBtdWx0aXBsZSB1c2Vycy4gWW91IGNhbiBwYXNzIGluIEV0aGVyZXVtIGFuZCBTb2xhbmEgYWRkcmVzc2VzLCBjb21tYSBzZXBhcmF0ZWQsIGluIHRoZSBzYW1lIHJlcXVlc3QuIFRoZSByZXNwb25zZSB3aWxsIGNvbnRhaW4gdXNlcnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBhZGRyZXNzZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEV0aCBvciBTb2wgYWRkcmVzc2VzXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaUZldGNoQnVsa1VzZXJzQnlFdGhPclNvbEFkZHJlc3NSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc0J5QWRkcmVzc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzQnlBZGRyZXNzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstdXNlcnMtYnktZXRoLW9yLXNvbC1hZGRyZXNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycy5hZGRyZXNzZXMsIHJlcXVlc3RQYXJhbWV0ZXJzLmFkZHJlc3NUeXBlcywgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBwb3dlciB1c2VycyBiYXNlZCBvbiBXYXJwY2FzdCBwb3dlciBiYWRnZXMuIEluZm9ybWF0aW9uIGlzIHVwZGF0ZWQgb25jZSBhIGRheS5cbiAgICAgICAgICogQHN1bW1hcnkgUG93ZXIgdXNlcnNcbiAgICAgICAgICogQHBhcmFtIHtVc2VyQXBpRmV0Y2hQb3dlclVzZXJzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcG93ZXItdXNlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFBvd2VyVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hQb3dlclVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgcG93ZXIgdXNlcnMgYW5kIHJlc3BvbmQgaW4gYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmb3JtYXQgdG8gV2FycGNhc3RcXCdzIGRlcHJlY2F0ZWQgcG93ZXIgYmFkZ2UgZW5kcG9pbnQuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBvd2VyIHVzZXIgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge1VzZXJBcGlGZXRjaFBvd2VyVXNlcnNMaXRlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyUG93ZXJMaXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyUG93ZXJMaXRlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvd2VyLXVzZXJzLWxpdGUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFBvd2VyVXNlcnNMaXRlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoUG93ZXJVc2Vyc0xpdGUocmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYSBsaXN0IG9mIHVzZXJzIGdpdmVuIGEgbG9jYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgQnkgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtVc2VyQXBpRmV0Y2hVc2Vyc0J5TG9jYXRpb25SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2Vycy1ieS1sb2NhdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlcnNCeUxvY2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJzQnlMb2NhdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5sYXRpdHVkZSwgcmVxdWVzdFBhcmFtZXRlcnMubG9uZ2l0dWRlLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2xsb3cgYSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBGb2xsb3cgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge1VzZXJBcGlGb2xsb3dVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrRm9sbG93UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrRm9sbG93UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZvbGxvdy11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZm9sbG93VXNlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZm9sbG93VXNlcihyZXF1ZXN0UGFyYW1ldGVycy5mb2xsb3dSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyBGSUQgdG8gW2Fzc2lnbiBpdCB0byBuZXcgdXNlcl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLWFjY291bnQpXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGZyZXNoIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge1VzZXJBcGlHZXRGcmVzaEFjY291bnRGSURSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJGSURSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJGSURSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZ2V0LWZyZXNoLWFjY291bnQtZmlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RnJlc2hBY2NvdW50RklEKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEZyZXNoQWNjb3VudEZJRChyZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGEgdXNlciBieSBjdXN0b2R5LWFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgQnkgY3VzdG9keS1hZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaUxvb2t1cFVzZXJCeUN1c3RvZHlBZGRyZXNzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLWJ5LWN1c3RvZHktYWRkcmVzcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJCeUN1c3RvZHlBZGRyZXNzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycy5jdXN0b2R5QWRkcmVzcywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoZXMgYSBzaW5nbGUgaHlkcmF0ZWQgdXNlciBvYmplY3QgZ2l2ZW4gYSB1c2VybmFtZVxuICAgICAgICAgKiBAc3VtbWFyeSBCeSB1c2VybmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1VzZXJBcGlMb29rdXBVc2VyQnlVc2VybmFtZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1ieS11c2VybmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJCeVVzZXJuYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBVc2VyQnlVc2VybmFtZShyZXF1ZXN0UGFyYW1ldGVycy51c2VybmFtZSwgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2hlcyB0aGUgdXNlcnMgd2hvIGhhdmUgdmVyaWZpZWQgdGhlIHNwZWNpZmllZCBYIChUd2l0dGVyKSB1c2VybmFtZVxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBYIHVzZXJuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaUxvb2t1cFVzZXJzQnlYVXNlcm5hbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2Vycy1ieS14LXVzZXJuYW1lKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwVXNlcnNCeVhVc2VybmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwVXNlcnNCeVhVc2VybmFtZShyZXF1ZXN0UGFyYW1ldGVycy54VXNlcm5hbWUsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgdmVyaWZpY2F0aW9uIGZvciBhbiBldGggYWRkcmVzcyBvciBjb250cmFjdCBmb3IgdGhlIHVzZXIgXFxcXCAoSW4gb3JkZXIgdG8gYWRkIHZlcmlmaWNhdGlvbiBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICAgICAqIEBzdW1tYXJ5IEFkZCB2ZXJpZmljYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtVc2VyQXBpUHVibGlzaFZlcmlmaWNhdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC12ZXJpZmljYXRpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoVmVyaWZpY2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoVmVyaWZpY2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLmFkZFZlcmlmaWNhdGlvblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhY2NvdW50IG9uIGZhcmNhc3Rlci4gICoqTm90ZToqKiBUaGlzIEFQSSBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gMTAgbWludXRlcyBvZiB0aGUgZmV0Y2ggRklEIEFQSSBjYWxsIChpLmUuLCAvdjIvZmFyY2FzdGVyL3VzZXIvZmlkKS4gT3RoZXJ3aXNlLCBOZXluYXIgd2lsbCBhc3NpZ24gdGhpcyBGSUQgdG8gYW5vdGhlciBhdmFpbGFibGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgbmV3IGFjY291bnRcbiAgICAgICAgICogQHBhcmFtIHtVc2VyQXBpUmVnaXN0ZXJBY2NvdW50UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWdpc3RlclVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlZ2lzdGVyVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJBY2NvdW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5yZWdpc3RlckFjY291bnQocmVxdWVzdFBhcmFtZXRlcnMucmVnaXN0ZXJVc2VyUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaCBmb3IgVXNlcm5hbWVzXG4gICAgICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBmb3IgVXNlcm5hbWVzXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaVNlYXJjaFVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJTZWFyY2hSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBzZWFyY2hVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5zZWFyY2hVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLnEsIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZXdlckZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGltaXQsIHJlcXVlc3RQYXJhbWV0ZXJzLmN1cnNvciwgcmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuZm9sbG93IGEgdXNlciBcXFxcIChJbiBvcmRlciB0byB1bmZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaVVuZm9sbG93VXNlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa0ZvbGxvd1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0ZvbGxvd1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91bmZvbGxvdy11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdW5mb2xsb3dVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC51bmZvbGxvd1VzZXIocmVxdWVzdFBhcmFtZXRlcnMuZm9sbG93UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB1c2VyIHByb2ZpbGUgXFxcXCAoSW4gb3JkZXIgdG8gdXBkYXRlIHVzZXJcXCdzIHByb2ZpbGUgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgdXNlciBwcm9maWxlXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckFwaVVwZGF0ZVVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VwZGF0ZS11c2VyKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAudXBkYXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2VyUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlckFwaUZhY3RvcnkgPSBVc2VyQXBpRmFjdG9yeTtcbi8qKlxuICogVXNlckFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBVc2VyQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVXNlckFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3MgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IERlbGV0ZSB2ZXJpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlEZWxldGVWZXJpZmljYXRpb25SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS12ZXJpZmljYXRpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVWZXJpZmljYXRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVWZXJpZmljYXRpb24ocmVxdWVzdFBhcmFtZXRlcnMucmVtb3ZlVmVyaWZpY2F0aW9uUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgbXVsdGlwbGUgdXNlcnMgYmFzZWQgb24gRklEc1xuICAgICAqIEBzdW1tYXJ5IEJ5IEZJRHNcbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlGZXRjaEJ1bGtVc2Vyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrVXNlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtVc2Vyc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoQnVsa1VzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Vc2VyQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hCdWxrVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkcywgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgdXNlcnMgYmFzZWQgb24gbXVsdGlwbGUgRXRoZXJldW0gb3IgU29sYW5hIGFkZHJlc3Nlcy4gIEVhY2ggZmFyY2FzdGVyIHVzZXIgaGFzIGEgY3VzdG9keSBFdGhlcmV1bSBhZGRyZXNzIGFuZCBvcHRpb25hbGx5IHZlcmlmaWVkIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuIFRoaXMgZW5kcG9pbnQgcmV0dXJucyBhbGwgdXNlcnMgdGhhdCBoYXZlIGFueSBvZiB0aGUgZ2l2ZW4gYWRkcmVzc2VzIGFzIHRoZWlyIGN1c3RvZHkgb3IgdmVyaWZpZWQgRXRoZXJldW0gb3IgU29sYW5hIGFkZHJlc3Nlcy4gIEEgY3VzdG9keSBhZGRyZXNzIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggb25seSAxIGZhcmNhc3RlciB1c2VyIGF0IGEgdGltZSBidXQgYSB2ZXJpZmllZCBhZGRyZXNzIGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggbXVsdGlwbGUgdXNlcnMuIFlvdSBjYW4gcGFzcyBpbiBFdGhlcmV1bSBhbmQgU29sYW5hIGFkZHJlc3NlcywgY29tbWEgc2VwYXJhdGVkLCBpbiB0aGUgc2FtZSByZXF1ZXN0LiBUaGUgcmVzcG9uc2Ugd2lsbCBjb250YWluIHVzZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzc2VzLlxuICAgICAqIEBzdW1tYXJ5IEJ5IEV0aCBvciBTb2wgYWRkcmVzc2VzXG4gICAgICogQHBhcmFtIHtVc2VyQXBpRmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrVXNlcnNCeUFkZHJlc3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtVc2Vyc0J5QWRkcmVzc1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2Vycy1ieS1ldGgtb3Itc29sLWFkZHJlc3MpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEJ1bGtVc2Vyc0J5RXRoT3JTb2xBZGRyZXNzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Vc2VyQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycy5hZGRyZXNzZXMsIHJlcXVlc3RQYXJhbWV0ZXJzLmFkZHJlc3NUeXBlcywgcmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBwb3dlciB1c2VycyBiYXNlZCBvbiBXYXJwY2FzdCBwb3dlciBiYWRnZXMuIEluZm9ybWF0aW9uIGlzIHVwZGF0ZWQgb25jZSBhIGRheS5cbiAgICAgKiBAc3VtbWFyeSBQb3dlciB1c2Vyc1xuICAgICAqIEBwYXJhbSB7VXNlckFwaUZldGNoUG93ZXJVc2Vyc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvd2VyLXVzZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hQb3dlclVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFBvd2VyVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMudmlld2VyRmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW1pdCwgcmVxdWVzdFBhcmFtZXRlcnMuY3Vyc29yLCByZXF1ZXN0UGFyYW1ldGVycy54TmV5bmFyRXhwZXJpbWVudGFsLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBwb3dlciB1c2VycyBhbmQgcmVzcG9uZCBpbiBhIGJhY2t3YXJkcyBjb21wYXRpYmxlIGZvcm1hdCB0byBXYXJwY2FzdFxcJ3MgZGVwcmVjYXRlZCBwb3dlciBiYWRnZSBlbmRwb2ludC5cbiAgICAgKiBAc3VtbWFyeSBQb3dlciB1c2VyIEZJRHNcbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlGZXRjaFBvd2VyVXNlcnNMaXRlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJQb3dlckxpdGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJQb3dlckxpdGVSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvd2VyLXVzZXJzLWxpdGUpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFBvd2VyVXNlcnNMaXRlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFBvd2VyVXNlcnNMaXRlKHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgbGlzdCBvZiB1c2VycyBnaXZlbiBhIGxvY2F0aW9uXG4gICAgICogQHN1bW1hcnkgQnkgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlGZXRjaFVzZXJzQnlMb2NhdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWJ5LWxvY2F0aW9uKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2Vyc0J5TG9jYXRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJzQnlMb2NhdGlvbihyZXF1ZXN0UGFyYW1ldGVycy5sYXRpdHVkZSwgcmVxdWVzdFBhcmFtZXRlcnMubG9uZ2l0dWRlLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2xsb3cgYSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGZvbGxvdyBhIHVzZXIgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IEZvbGxvdyB1c2VyXG4gICAgICogQHBhcmFtIHtVc2VyQXBpRm9sbG93VXNlclJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWxrRm9sbG93UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrRm9sbG93UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mb2xsb3ctdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGZvbGxvd1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mb2xsb3dVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLmZvbGxvd1JlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIEZJRCB0byBbYXNzaWduIGl0IHRvIG5ldyB1c2VyXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItYWNjb3VudClcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBmcmVzaCBGSURcbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlHZXRGcmVzaEFjY291bnRGSURSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlckZJRFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlckZJRFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZ2V0LWZyZXNoLWFjY291bnQtZmlkKVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0RnJlc2hBY2NvdW50RklEKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRGcmVzaEFjY291bnRGSUQocmVxdWVzdFBhcmFtZXRlcnMueE5leW5hckV4cGVyaW1lbnRhbCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhIHVzZXIgYnkgY3VzdG9keS1hZGRyZXNzXG4gICAgICogQHN1bW1hcnkgQnkgY3VzdG9keS1hZGRyZXNzXG4gICAgICogQHBhcmFtIHtVc2VyQXBpTG9va3VwVXNlckJ5Q3VzdG9keUFkZHJlc3NSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItYnktY3VzdG9keS1hZGRyZXNzKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwVXNlckJ5Q3VzdG9keUFkZHJlc3MocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycy5jdXN0b2R5QWRkcmVzcywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBzaW5nbGUgaHlkcmF0ZWQgdXNlciBvYmplY3QgZ2l2ZW4gYSB1c2VybmFtZVxuICAgICAqIEBzdW1tYXJ5IEJ5IHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtVc2VyQXBpTG9va3VwVXNlckJ5VXNlcm5hbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItYnktdXNlcm5hbWUpXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBVc2VyQnlVc2VybmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVXNlckFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cFVzZXJCeVVzZXJuYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJuYW1lLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSB1c2VycyB3aG8gaGF2ZSB2ZXJpZmllZCB0aGUgc3BlY2lmaWVkIFggKFR3aXR0ZXIpIHVzZXJuYW1lXG4gICAgICogQHN1bW1hcnkgQnkgWCB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7VXNlckFwaUxvb2t1cFVzZXJzQnlYVXNlcm5hbWVSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2Vycy1ieS14LXVzZXJuYW1lKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwVXNlcnNCeVhVc2VybmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVXNlckFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxvb2t1cFVzZXJzQnlYVXNlcm5hbWUocmVxdWVzdFBhcmFtZXRlcnMueFVzZXJuYW1lLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3Mgb3IgY29udHJhY3QgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGFkZCB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IEFkZCB2ZXJpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlQdWJsaXNoVmVyaWZpY2F0aW9uUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLXZlcmlmaWNhdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2hWZXJpZmljYXRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5wdWJsaXNoVmVyaWZpY2F0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLmFkZFZlcmlmaWNhdGlvblJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhY2NvdW50IG9uIGZhcmNhc3Rlci4gICoqTm90ZToqKiBUaGlzIEFQSSBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gMTAgbWludXRlcyBvZiB0aGUgZmV0Y2ggRklEIEFQSSBjYWxsIChpLmUuLCAvdjIvZmFyY2FzdGVyL3VzZXIvZmlkKS4gT3RoZXJ3aXNlLCBOZXluYXIgd2lsbCBhc3NpZ24gdGhpcyBGSUQgdG8gYW5vdGhlciBhdmFpbGFibGUgdXNlci5cbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBuZXcgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7VXNlckFwaVJlZ2lzdGVyQWNjb3VudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWdpc3RlclVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlZ2lzdGVyVXNlclJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVnaXN0ZXItYWNjb3VudClcbiAgICAgKlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWNjb3VudChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVXNlckFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlZ2lzdGVyQWNjb3VudChyZXF1ZXN0UGFyYW1ldGVycy5yZWdpc3RlclVzZXJSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBVc2VybmFtZXNcbiAgICAgKiBAc3VtbWFyeSBTZWFyY2ggZm9yIFVzZXJuYW1lc1xuICAgICAqIEBwYXJhbSB7VXNlckFwaVNlYXJjaFVzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclNlYXJjaFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclNlYXJjaFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Vc2VyQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc2VhcmNoVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5xLCByZXF1ZXN0UGFyYW1ldGVycy52aWV3ZXJGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0LCByZXF1ZXN0UGFyYW1ldGVycy5jdXJzb3IsIHJlcXVlc3RQYXJhbWV0ZXJzLnhOZXluYXJFeHBlcmltZW50YWwsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZvbGxvdyBhIHVzZXIgXFxcXCAoSW4gb3JkZXIgdG8gdW5mb2xsb3cgYSB1c2VyIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyB1c2VyXG4gICAgICogQHBhcmFtIHtVc2VyQXBpVW5mb2xsb3dVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtGb2xsb3dSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJ1bGtGb2xsb3dSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VuZm9sbG93LXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICB1bmZvbGxvd1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS51bmZvbGxvd1VzZXIocmVxdWVzdFBhcmFtZXRlcnMuZm9sbG93UmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB1c2VyIHByb2ZpbGUgXFxcXCAoSW4gb3JkZXIgdG8gdXBkYXRlIHVzZXJcXCdzIHByb2ZpbGUgYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSB1c2VyIHByb2ZpbGVcbiAgICAgKiBAcGFyYW0ge1VzZXJBcGlVcGRhdGVVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlckFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS51cGRhdGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJBcGkgPSBVc2VyQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/user-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/webhook-api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/apis/webhook-api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebhookApi = exports.WebhookApiFactory = exports.WebhookApiFp = exports.WebhookApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n * WebhookApi - axios parameter creator\n * @export\n */\nconst WebhookApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {WebhookDeleteReqBody} webhookDeleteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)\n         *\n         */\n        deleteWebhook: async (webhookDeleteReqBody, options = {}) => {\n            // verify required parameter 'webhookDeleteReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('deleteWebhook', 'webhookDeleteReqBody', webhookDeleteReqBody);\n            const localVarPath = `/farcaster/webhook`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookDeleteReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of webhooks associated to a user\n         * @summary Associated webhooks of user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)\n         *\n         */\n        fetchWebhooks: async (options = {}) => {\n            const localVarPath = `/farcaster/webhook/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a webhook\n         * @summary Fetch a webhook\n         * @param {string} webhookId\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)\n         *\n         */\n        lookupWebhook: async (webhookId, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('lookupWebhook', 'webhookId', webhookId);\n            const localVarPath = `/farcaster/webhook`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (webhookId !== undefined) {\n                localVarQueryParameter['webhook_id'] = webhookId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a webhook\n         * @summary Create a webhook\n         * @param {WebhookPostReqBody} webhookPostReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)\n         *\n         */\n        publishWebhook: async (webhookPostReqBody, options = {}) => {\n            // verify required parameter 'webhookPostReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('publishWebhook', 'webhookPostReqBody', webhookPostReqBody);\n            const localVarPath = `/farcaster/webhook`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookPostReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {WebhookPutReqBody} webhookPutReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)\n         *\n         */\n        updateWebhook: async (webhookPutReqBody, options = {}) => {\n            // verify required parameter 'webhookPutReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('updateWebhook', 'webhookPutReqBody', webhookPutReqBody);\n            const localVarPath = `/farcaster/webhook`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookPutReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update webhook active status\n         * @summary Update webhook status\n         * @param {WebhookPatchReqBody} webhookPatchReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)\n         *\n         */\n        updateWebhookActiveStatus: async (webhookPatchReqBody, options = {}) => {\n            // verify required parameter 'webhookPatchReqBody' is not null or undefined\n            (0, common_1.assertParamExists)('updateWebhookActiveStatus', 'webhookPatchReqBody', webhookPatchReqBody);\n            const localVarPath = `/farcaster/webhook`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookPatchReqBody, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WebhookApiAxiosParamCreator = WebhookApiAxiosParamCreator;\n/**\n * WebhookApi - functional programming interface\n * @export\n */\nconst WebhookApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WebhookApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {WebhookDeleteReqBody} webhookDeleteReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)\n         *\n         */\n        async deleteWebhook(webhookDeleteReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookDeleteReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of webhooks associated to a user\n         * @summary Associated webhooks of user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)\n         *\n         */\n        async fetchWebhooks(options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebhooks(options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.fetchWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a webhook\n         * @summary Fetch a webhook\n         * @param {string} webhookId\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)\n         *\n         */\n        async lookupWebhook(webhookId, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupWebhook(webhookId, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.lookupWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a webhook\n         * @summary Create a webhook\n         * @param {WebhookPostReqBody} webhookPostReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)\n         *\n         */\n        async publishWebhook(webhookPostReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishWebhook(webhookPostReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.publishWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {WebhookPutReqBody} webhookPutReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)\n         *\n         */\n        async updateWebhook(webhookPutReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookPutReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.updateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update webhook active status\n         * @summary Update webhook status\n         * @param {WebhookPatchReqBody} webhookPatchReqBody\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)\n         *\n         */\n        async updateWebhookActiveStatus(webhookPatchReqBody, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookActiveStatus(webhookPatchReqBody, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhookApi.updateWebhookActiveStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WebhookApiFp = WebhookApiFp;\n/**\n * WebhookApi - factory interface\n * @export\n */\nconst WebhookApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WebhookApiFp)(configuration);\n    return {\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {WebhookApiDeleteWebhookRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)\n         *\n         */\n        deleteWebhook(requestParameters, options) {\n            return localVarFp.deleteWebhook(requestParameters.webhookDeleteReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of webhooks associated to a user\n         * @summary Associated webhooks of user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)\n         *\n         */\n        fetchWebhooks(options) {\n            return localVarFp.fetchWebhooks(options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a webhook\n         * @summary Fetch a webhook\n         * @param {WebhookApiLookupWebhookRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)\n         *\n         */\n        lookupWebhook(requestParameters, options) {\n            return localVarFp.lookupWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a webhook\n         * @summary Create a webhook\n         * @param {WebhookApiPublishWebhookRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)\n         *\n         */\n        publishWebhook(requestParameters, options) {\n            return localVarFp.publishWebhook(requestParameters.webhookPostReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {WebhookApiUpdateWebhookRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)\n         *\n         */\n        updateWebhook(requestParameters, options) {\n            return localVarFp.updateWebhook(requestParameters.webhookPutReqBody, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update webhook active status\n         * @summary Update webhook status\n         * @param {WebhookApiUpdateWebhookActiveStatusRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)\n         *\n         */\n        updateWebhookActiveStatus(requestParameters, options) {\n            return localVarFp.updateWebhookActiveStatus(requestParameters.webhookPatchReqBody, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WebhookApiFactory = WebhookApiFactory;\n/**\n * WebhookApi - object-oriented interface\n * @export\n * @class WebhookApi\n * @extends {BaseAPI}\n */\nclass WebhookApi extends base_1.BaseAPI {\n    /**\n     * Delete a webhook\n     * @summary Delete a webhook\n     * @param {WebhookApiDeleteWebhookRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)\n     *\n     */\n    deleteWebhook(requestParameters, options) {\n        return (0, exports.WebhookApiFp)(this.configuration).deleteWebhook(requestParameters.webhookDeleteReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of webhooks associated to a user\n     * @summary Associated webhooks of user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)\n     *\n     */\n    fetchWebhooks(options) {\n        return (0, exports.WebhookApiFp)(this.configuration).fetchWebhooks(options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a webhook\n     * @summary Fetch a webhook\n     * @param {WebhookApiLookupWebhookRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)\n     *\n     */\n    lookupWebhook(requestParameters, options) {\n        return (0, exports.WebhookApiFp)(this.configuration).lookupWebhook(requestParameters.webhookId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a webhook\n     * @summary Create a webhook\n     * @param {WebhookApiPublishWebhookRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)\n     *\n     */\n    publishWebhook(requestParameters, options) {\n        return (0, exports.WebhookApiFp)(this.configuration).publishWebhook(requestParameters.webhookPostReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a webhook\n     * @summary Update a webhook\n     * @param {WebhookApiUpdateWebhookRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)\n     *\n     */\n    updateWebhook(requestParameters, options) {\n        return (0, exports.WebhookApiFp)(this.configuration).updateWebhook(requestParameters.webhookPutReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update webhook active status\n     * @summary Update webhook status\n     * @param {WebhookApiUpdateWebhookActiveStatusRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhookApi\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)\n     *\n     */\n    updateWebhookActiveStatus(requestParameters, options) {\n        return (0, exports.WebhookApiFp)(this.configuration).updateWebhookActiveStatus(requestParameters.webhookPatchReqBody, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WebhookApi = WebhookApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9hcGlzL3dlYmhvb2stYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxtQ0FBbUM7QUFDM0csZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztB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cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9hcGkvYXBpcy93ZWJob29rLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgQVBJIFYyXG4gKiBUaGUgRmFyY2FzdGVyIEFQSSBhbGxvd3MgeW91IHRvIGludGVyYWN0IHdpdGggdGhlIEZhcmNhc3RlciBwcm90b2NvbC4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi40Ni4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViaG9va0FwaSA9IGV4cG9ydHMuV2ViaG9va0FwaUZhY3RvcnkgPSBleHBvcnRzLldlYmhvb2tBcGlGcCA9IGV4cG9ydHMuV2ViaG9va0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogV2ViaG9va0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdlYmhvb2tBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge1dlYmhvb2tEZWxldGVSZXFCb2R5fSB3ZWJob29rRGVsZXRlUmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS13ZWJob29rKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlV2ViaG9vazogYXN5bmMgKHdlYmhvb2tEZWxldGVSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dlYmhvb2tEZWxldGVSZXFCb2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlbGV0ZVdlYmhvb2snLCAnd2ViaG9va0RlbGV0ZVJlcUJvZHknLCB3ZWJob29rRGVsZXRlUmVxQm9keSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci93ZWJob29rYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnREVMRVRFJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKSh3ZWJob29rRGVsZXRlUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHdlYmhvb2tzIGFzc29jaWF0ZWQgdG8gYSB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEFzc29jaWF0ZWQgd2ViaG9va3Mgb2YgdXNlclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va0xpc3RSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtd2ViaG9va3MpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFdlYmhvb2tzOiBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL2ZhcmNhc3Rlci93ZWJob29rL2xpc3RgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtd2ViaG9vaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFdlYmhvb2s6IGFzeW5jICh3ZWJob29rSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2ViaG9va0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cFdlYmhvb2snLCAnd2ViaG9va0lkJywgd2ViaG9va0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3dlYmhvb2tgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAod2ViaG9va0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd3ZWJob29rX2lkJ10gPSB3ZWJob29rSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtXZWJob29rUG9zdFJlcUJvZHl9IHdlYmhvb2tQb3N0UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtd2ViaG9vaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hXZWJob29rOiBhc3luYyAod2ViaG9va1Bvc3RSZXFCb2R5LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dlYmhvb2tQb3N0UmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdwdWJsaXNoV2ViaG9vaycsICd3ZWJob29rUG9zdFJlcUJvZHknLCB3ZWJob29rUG9zdFJlcUJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC9mYXJjYXN0ZXIvd2ViaG9va2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHdlYmhvb2tQb3N0UmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7V2ViaG9va1B1dFJlcUJvZHl9IHdlYmhvb2tQdXRSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLXdlYmhvb2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVXZWJob29rOiBhc3luYyAod2ViaG9va1B1dFJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2ViaG9va1B1dFJlcUJvZHknIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndXBkYXRlV2ViaG9vaycsICd3ZWJob29rUHV0UmVxQm9keScsIHdlYmhvb2tQdXRSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3dlYmhvb2tgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQVVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHdlYmhvb2tQdXRSZXFCb2R5LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgd2ViaG9vayBhY3RpdmUgc3RhdHVzXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSB3ZWJob29rIHN0YXR1c1xuICAgICAgICAgKiBAcGFyYW0ge1dlYmhvb2tQYXRjaFJlcUJvZHl9IHdlYmhvb2tQYXRjaFJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vay1hY3RpdmUtc3RhdHVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1czogYXN5bmMgKHdlYmhvb2tQYXRjaFJlcUJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2ViaG9va1BhdGNoUmVxQm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCd1cGRhdGVXZWJob29rQWN0aXZlU3RhdHVzJywgJ3dlYmhvb2tQYXRjaFJlcUJvZHknLCB3ZWJob29rUGF0Y2hSZXFCb2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvZmFyY2FzdGVyL3dlYmhvb2tgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQQVRDSCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkod2ViaG9va1BhdGNoUmVxQm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XZWJob29rQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBXZWJob29rQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFdlYmhvb2tBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBXZWJob29rQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5XZWJob29rQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtXZWJob29rRGVsZXRlUmVxQm9keX0gd2ViaG9va0RlbGV0ZVJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtd2ViaG9vaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGRlbGV0ZVdlYmhvb2sod2ViaG9va0RlbGV0ZVJlcUJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZVdlYmhvb2sod2ViaG9va0RlbGV0ZVJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rQXBpLmRlbGV0ZVdlYmhvb2snXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB3ZWJob29rcyBhc3NvY2lhdGVkIHRvIGEgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBBc3NvY2lhdGVkIHdlYmhvb2tzIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXdlYmhvb2tzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hXZWJob29rcyhvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFdlYmhvb2tzKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rQXBpLmZldGNoV2ViaG9va3MnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC13ZWJob29rKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va0FwaS5sb29rdXBXZWJob29rJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtXZWJob29rUG9zdFJlcUJvZHl9IHdlYmhvb2tQb3N0UmVxQm9keVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtd2ViaG9vaylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHB1Ymxpc2hXZWJob29rKHdlYmhvb2tQb3N0UmVxQm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucHVibGlzaFdlYmhvb2sod2ViaG9va1Bvc3RSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va0FwaS5wdWJsaXNoV2ViaG9vayddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7V2ViaG9va1B1dFJlcUJvZHl9IHdlYmhvb2tQdXRSZXFCb2R5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLXdlYmhvb2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1cGRhdGVXZWJob29rKHdlYmhvb2tQdXRSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci51cGRhdGVXZWJob29rKHdlYmhvb2tQdXRSZXFCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va0FwaS51cGRhdGVXZWJob29rJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgd2ViaG9vayBhY3RpdmUgc3RhdHVzXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSB3ZWJob29rIHN0YXR1c1xuICAgICAgICAgKiBAcGFyYW0ge1dlYmhvb2tQYXRjaFJlcUJvZHl9IHdlYmhvb2tQYXRjaFJlcUJvZHlcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vay1hY3RpdmUtc3RhdHVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgdXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyh3ZWJob29rUGF0Y2hSZXFCb2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci51cGRhdGVXZWJob29rQWN0aXZlU3RhdHVzKHdlYmhvb2tQYXRjaFJlcUJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rQXBpLnVwZGF0ZVdlYmhvb2tBY3RpdmVTdGF0dXMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2ViaG9va0FwaUZwID0gV2ViaG9va0FwaUZwO1xuLyoqXG4gKiBXZWJob29rQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2ViaG9va0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLldlYmhvb2tBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge1dlYmhvb2tBcGlEZWxldGVXZWJob29rUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS13ZWJob29rKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlV2ViaG9vayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlV2ViaG9vayhyZXF1ZXN0UGFyYW1ldGVycy53ZWJob29rRGVsZXRlUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB3ZWJob29rcyBhc3NvY2lhdGVkIHRvIGEgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBBc3NvY2lhdGVkIHdlYmhvb2tzIG9mIHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXdlYmhvb2tzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hXZWJob29rcyhvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFdlYmhvb2tzKG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7V2ViaG9va0FwaUxvb2t1cFdlYmhvb2tSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXdlYmhvb2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLndlYmhvb2tJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge1dlYmhvb2tBcGlQdWJsaXNoV2ViaG9va1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLXdlYmhvb2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaXNoV2ViaG9vayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucHVibGlzaFdlYmhvb2socmVxdWVzdFBhcmFtZXRlcnMud2ViaG9va1Bvc3RSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7V2ViaG9va0FwaVVwZGF0ZVdlYmhvb2tSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLXdlYmhvb2spXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC51cGRhdGVXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLndlYmhvb2tQdXRSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHdlYmhvb2sgYWN0aXZlIHN0YXR1c1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgd2ViaG9vayBzdGF0dXNcbiAgICAgICAgICogQHBhcmFtIHtXZWJob29rQXBpVXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vay1hY3RpdmUtc3RhdHVzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAudXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyhyZXF1ZXN0UGFyYW1ldGVycy53ZWJob29rUGF0Y2hSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XZWJob29rQXBpRmFjdG9yeSA9IFdlYmhvb2tBcGlGYWN0b3J5O1xuLyoqXG4gKiBXZWJob29rQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFdlYmhvb2tBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBXZWJob29rQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICogQHBhcmFtIHtXZWJob29rQXBpRGVsZXRlV2ViaG9va1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIGRlbGV0ZVdlYmhvb2socmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLndlYmhvb2tEZWxldGVSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIHdlYmhvb2tzIGFzc29jaWF0ZWQgdG8gYSB1c2VyXG4gICAgICogQHN1bW1hcnkgQXNzb2NpYXRlZCB3ZWJob29rcyBvZiB1c2VyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tMaXN0UmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC13ZWJob29rcylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoV2ViaG9va3Mob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoV2ViaG9va3Mob3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgd2ViaG9va1xuICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgd2ViaG9va1xuICAgICAqIEBwYXJhbSB7V2ViaG9va0FwaUxvb2t1cFdlYmhvb2tSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXdlYmhvb2spXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwV2ViaG9vayhyZXF1ZXN0UGFyYW1ldGVycy53ZWJob29rSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3ZWJob29rXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgd2ViaG9va1xuICAgICAqIEBwYXJhbSB7V2ViaG9va0FwaVB1Ymxpc2hXZWJob29rUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2hXZWJob29rKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaFdlYmhvb2socmVxdWVzdFBhcmFtZXRlcnMud2ViaG9va1Bvc3RSZXFCb2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgKiBAcGFyYW0ge1dlYmhvb2tBcGlVcGRhdGVXZWJob29rUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3VwZGF0ZS13ZWJob29rKVxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlV2ViaG9vayhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnVwZGF0ZVdlYmhvb2socmVxdWVzdFBhcmFtZXRlcnMud2ViaG9va1B1dFJlcUJvZHksIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2ViaG9vayBhY3RpdmUgc3RhdHVzXG4gICAgICogQHN1bW1hcnkgVXBkYXRlIHdlYmhvb2sgc3RhdHVzXG4gICAgICogQHBhcmFtIHtXZWJob29rQXBpVXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vay1hY3RpdmUtc3RhdHVzKVxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnVwZGF0ZVdlYmhvb2tBY3RpdmVTdGF0dXMocmVxdWVzdFBhcmFtZXRlcnMud2ViaG9va1BhdGNoUmVxQm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJob29rQXBpID0gV2ViaG9va0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/webhook-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/base.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nexports.BASE_PATH = \"https://api.neynar.com/v2\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        var _a;\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n/**\n *\n * @export\n */\nexports.operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCO0FBQ3JILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcGVyYXRpb25TZXJ2ZXJNYXAgPSBleHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBleHBvcnRzLkJhc2VBUEkgPSBleHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IGV4cG9ydHMuQkFTRV9QQVRIID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSBcImh0dHBzOi8vYXBpLm5leW5hci5jb20vdjJcIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IHtcbiAgICBjc3Y6IFwiLFwiLFxuICAgIHNzdjogXCIgXCIsXG4gICAgdHN2OiBcIlxcdFwiLFxuICAgIHBpcGVzOiBcInxcIixcbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQmFzZUFQSVxuICovXG5jbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBiYXNlUGF0aCA9IGV4cG9ydHMuQkFTRV9QQVRILCBheGlvcyA9IGF4aW9zXzEuZGVmYXVsdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5heGlvcyA9IGF4aW9zO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSAoX2EgPSBjb25maWd1cmF0aW9uLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFQSSA9IEJhc2VBUEk7XG47XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUmVxdWlyZWRFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBSZXF1aXJlZEVycm9yO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js":
/*!*************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = async function (object, keyParamName, configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = async function (object, configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = async function (object, name, scopes, configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n};\nexports.setOAuthToObject = setOAuthToObject;\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        var _a;\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: (axios.defaults.baseURL ? '' : (_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDelIsZUFBZSxtQkFBTyxDQUFDLHlFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVyxxQ0FBcUMsYUFBYTtBQUNySTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSSxFQUFFLHNCQUFzQixFQUFFLFdBQVc7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3Qiw0TEFBNEw7QUFDblI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEFQSSBWMlxuICogVGhlIEZhcmNhc3RlciBBUEkgYWxsb3dzIHlvdSB0byBpbnRlcmFjdCB3aXRoIHRoZSBGYXJjYXN0ZXIgcHJvdG9jb2wuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuNDYuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGV4cG9ydHMudG9QYXRoU3RyaW5nID0gZXhwb3J0cy5zZXJpYWxpemVEYXRhSWZOZWVkZWQgPSBleHBvcnRzLnNldFNlYXJjaFBhcmFtcyA9IGV4cG9ydHMuc2V0T0F1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QmVhcmVyQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRCYXNpY0F1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QXBpS2V5VG9PYmplY3QgPSBleHBvcnRzLmFzc2VydFBhcmFtRXhpc3RzID0gZXhwb3J0cy5EVU1NWV9CQVNFX1VSTCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuRFVNTVlfQkFTRV9VUkwgPSAnaHR0cHM6Ly9leGFtcGxlLmNvbSc7XG4vKipcbiAqXG4gKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICogQGV4cG9ydFxuICovXG5jb25zdCBhc3NlcnRQYXJhbUV4aXN0cyA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUsIHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSkge1xuICAgIGlmIChwYXJhbVZhbHVlID09PSBudWxsIHx8IHBhcmFtVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgYmFzZV8xLlJlcXVpcmVkRXJyb3IocGFyYW1OYW1lLCBgUmVxdWlyZWQgcGFyYW1ldGVyICR7cGFyYW1OYW1lfSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nICR7ZnVuY3Rpb25OYW1lfS5gKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRQYXJhbUV4aXN0cyA9IGFzc2VydFBhcmFtRXhpc3RzO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRBcGlLZXlUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIGtleVBhcmFtTmFtZSwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IGxvY2FsVmFyQXBpS2V5VmFsdWUgPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hcGlLZXkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hcGlLZXkoa2V5UGFyYW1OYW1lKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgb2JqZWN0W2tleVBhcmFtTmFtZV0gPSBsb2NhbFZhckFwaUtleVZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLnNldEFwaUtleVRvT2JqZWN0ID0gc2V0QXBpS2V5VG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldEJhc2ljQXV0aFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIChjb25maWd1cmF0aW9uLnVzZXJuYW1lIHx8IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQpKSB7XG4gICAgICAgIG9iamVjdFtcImF1dGhcIl0gPSB7IHVzZXJuYW1lOiBjb25maWd1cmF0aW9uLnVzZXJuYW1lLCBwYXNzd29yZDogY29uZmlndXJhdGlvbi5wYXNzd29yZCB9O1xuICAgIH1cbn07XG5leHBvcnRzLnNldEJhc2ljQXV0aFRvT2JqZWN0ID0gc2V0QmFzaWNBdXRoVG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldEJlYXJlckF1dGhUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbigpXG4gICAgICAgICAgICA6IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgIG9iamVjdFtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIGFjY2Vzc1Rva2VuO1xuICAgIH1cbn07XG5leHBvcnRzLnNldEJlYXJlckF1dGhUb09iamVjdCA9IHNldEJlYXJlckF1dGhUb09iamVjdDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0T0F1dGhUb09iamVjdCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHNjb3BlcywgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgbG9jYWxWYXJBY2Nlc3NUb2tlblZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbihuYW1lLCBzY29wZXMpXG4gICAgICAgICAgICA6IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgIG9iamVjdFtcIkF1dGhvcml6YXRpb25cIl0gPSBcIkJlYXJlciBcIiArIGxvY2FsVmFyQWNjZXNzVG9rZW5WYWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRPQXV0aFRvT2JqZWN0ID0gc2V0T0F1dGhUb09iamVjdDtcbmZ1bmN0aW9uIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyLCBrZXkgPSBcIlwiKSB7XG4gICAgaWYgKHBhcmFtZXRlciA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgcGFyYW1ldGVyLmZvckVhY2goaXRlbSA9PiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIGl0ZW0sIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5mb3JFYWNoKGN1cnJlbnRLZXkgPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBwYXJhbWV0ZXJbY3VycmVudEtleV0sIGAke2tleX0ke2tleSAhPT0gJycgPyAnLicgOiAnJ30ke2N1cnJlbnRLZXl9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXJsU2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVybFNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAodXJsLCAuLi5vYmplY3RzKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuc2VhcmNoKTtcbiAgICBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyhzZWFyY2hQYXJhbXMsIG9iamVjdHMpO1xuICAgIHVybC5zZWFyY2ggPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbn07XG5leHBvcnRzLnNldFNlYXJjaFBhcmFtcyA9IHNldFNlYXJjaFBhcmFtcztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gZnVuY3Rpb24gKHZhbHVlLCByZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IG5vblN0cmluZyA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZyc7XG4gICAgY29uc3QgbmVlZHNTZXJpYWxpemF0aW9uID0gbm9uU3RyaW5nICYmIGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5pc0pzb25NaW1lXG4gICAgICAgID8gY29uZmlndXJhdGlvbi5pc0pzb25NaW1lKHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKVxuICAgICAgICA6IG5vblN0cmluZztcbiAgICByZXR1cm4gbmVlZHNTZXJpYWxpemF0aW9uXG4gICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pXG4gICAgICAgIDogKHZhbHVlIHx8IFwiXCIpO1xufTtcbmV4cG9ydHMuc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCB0b1BhdGhTdHJpbmcgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbn07XG5leHBvcnRzLnRvUGF0aFN0cmluZyA9IHRvUGF0aFN0cmluZztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gKGF4aW9zQXJncywgZ2xvYmFsQXhpb3MsIEJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiAoYXhpb3MgPSBnbG9iYWxBeGlvcywgYmFzZVBhdGggPSBCQVNFX1BBVEgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBheGlvc1JlcXVlc3RBcmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBheGlvc0FyZ3Mub3B0aW9ucyksIHsgdXJsOiAoYXhpb3MuZGVmYXVsdHMuYmFzZVVSTCA/ICcnIDogKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBiYXNlUGF0aCkgKyBheGlvc0FyZ3MudXJsIH0pO1xuICAgICAgICByZXR1cm4gYXhpb3MucmVxdWVzdChheGlvc1JlcXVlc3RBcmdzKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uID0gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/configuration.js":
/*!********************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/api/configuration.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster API V2\n * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.46.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxzQkFBc0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2FwaS9jb25maWd1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBBUEkgVjJcbiAqIFRoZSBGYXJjYXN0ZXIgQVBJIGFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgRmFyY2FzdGVyIHByb3RvY29sLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjQ2LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBwYXJhbS5hcGlLZXk7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSBwYXJhbS51c2VybmFtZTtcbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHBhcmFtLnBhc3N3b3JkO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcGFyYW0uYWNjZXNzVG9rZW47XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwYXJhbS5iYXNlUGF0aDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmRleCA9IHBhcmFtLnNlcnZlckluZGV4O1xuICAgICAgICB0aGlzLmJhc2VPcHRpb25zID0gcGFyYW0uYmFzZU9wdGlvbnM7XG4gICAgICAgIHRoaXMuZm9ybURhdGFDdG9yID0gcGFyYW0uZm9ybURhdGFDdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBhIEpTT04gTUlNRS5cbiAgICAgKiBKU09OIE1JTUUgZXhhbXBsZXM6XG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURjhcbiAgICAgKiAgIEFQUExJQ0FUSU9OL0pTT05cbiAgICAgKiAgIGFwcGxpY2F0aW9uL3ZuZC5jb21wYW55K2pzb25cbiAgICAgKiBAcGFyYW0gbWltZSAtIE1JTUUgKE11bHRpcHVycG9zZSBJbnRlcm5ldCBNYWlsIEV4dGVuc2lvbnMpXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBNSU1FIGlzIEpTT04sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0pzb25NaW1lKG1pbWUpIHtcbiAgICAgICAgY29uc3QganNvbk1pbWUgPSBuZXcgUmVnRXhwKCdeKGFwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig7LiopPyQnLCAnaScpO1xuICAgICAgICByZXR1cm4gbWltZSAhPT0gbnVsbCAmJiAoanNvbk1pbWUudGVzdChtaW1lKSB8fCBtaW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhcHBsaWNhdGlvbi9qc29uLXBhdGNoK2pzb24nKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarAPIClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/clients/NeynarAPIClient.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NeynarAPIClient = void 0;\nconst accounts_1 = __webpack_require__(/*! viem/accounts */ \"(rsc)/./node_modules/viem/_cjs/accounts/index.js\");\nconst logger_1 = __webpack_require__(/*! ../common/logger */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/logger.js\");\nconst axios_1 = __importStar(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nconst configuration_1 = __webpack_require__(/*! ../api/configuration */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/configuration.js\");\nconst constants_1 = __webpack_require__(/*! ../common/constants */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/constants.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/index.js\");\nconst action_api_1 = __webpack_require__(/*! ../api/apis/action-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/action-api.js\");\nconst agents_api_1 = __webpack_require__(/*! ../api/apis/agents-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/agents-api.js\");\nconst app_host_api_1 = __webpack_require__(/*! ../api/apis/app-host-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/app-host-api.js\");\nconst ban_api_1 = __webpack_require__(/*! ../api/apis/ban-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/ban-api.js\");\nconst block_api_1 = __webpack_require__(/*! ../api/apis/block-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/block-api.js\");\nconst cast_api_1 = __webpack_require__(/*! ../api/apis/cast-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/cast-api.js\");\nconst channel_api_1 = __webpack_require__(/*! ../api/apis/channel-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/channel-api.js\");\nconst feed_api_1 = __webpack_require__(/*! ../api/apis/feed-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/feed-api.js\");\nconst fname_api_1 = __webpack_require__(/*! ../api/apis/fname-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/fname-api.js\");\nconst follows_api_1 = __webpack_require__(/*! ../api/apis/follows-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/follows-api.js\");\nconst frame_api_1 = __webpack_require__(/*! ../api/apis/frame-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/frame-api.js\");\nconst login_api_1 = __webpack_require__(/*! ../api/apis/login-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/login-api.js\");\nconst metrics_api_1 = __webpack_require__(/*! ../api/apis/metrics-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/metrics-api.js\");\nconst mute_api_1 = __webpack_require__(/*! ../api/apis/mute-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/mute-api.js\");\nconst notifications_api_1 = __webpack_require__(/*! ../api/apis/notifications-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/notifications-api.js\");\nconst onchain_api_1 = __webpack_require__(/*! ../api/apis/onchain-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/onchain-api.js\");\nconst reaction_api_1 = __webpack_require__(/*! ../api/apis/reaction-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/reaction-api.js\");\nconst signer_api_1 = __webpack_require__(/*! ../api/apis/signer-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/signer-api.js\");\nconst storage_api_1 = __webpack_require__(/*! ../api/apis/storage-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/storage-api.js\");\nconst subscribers_api_1 = __webpack_require__(/*! ../api/apis/subscribers-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/subscribers-api.js\");\nconst user_api_1 = __webpack_require__(/*! ../api/apis/user-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/user-api.js\");\nconst webhook_api_1 = __webpack_require__(/*! ../api/apis/webhook-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/api/apis/webhook-api.js\");\nconst { version: sdkVersion } = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/package.json\");\n/**\n * Converts a camelCase string to snake_case.\n * If the input string is not in camelCase format, it returns the original string.\n *\n * @param {string} str - The string to convert.\n * @returns {string} The converted string in snake_case, or the original string if not camelCase.\n */\nfunction camelToSnakeCase(str) {\n    // Check if the string is camelCase\n    if (/^[a-z]+([A-Z][a-z]*)+$/.test(str)) {\n        return str.replace(/([A-Z])/g, '_$1').toLowerCase();\n    }\n    return str; // Return the original string if it's not camelCase\n}\n/**\n * Converts the top-level keys of an object from camelCase to snake_case.\n * If a key is not in camelCase, it retains its original format.\n * Nested objects or arrays are left unchanged.\n * This is done to revert the conversion of top-level keys since we accept snake_case keys in the API but convert them to camelCase in the wrapper.\n *\n * @param {object} obj - The object whose top-level keys are to be converted.\n * @returns {object} A new object with top-level keys converted to snake_case.\n */\nfunction camelCaseToSnakeCaseKeys(obj) {\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {\n        // Convert only the top-level keys\n        return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n            camelToSnakeCase(key), // Convert only camelCase keys\n            value, // Leave the value untouched\n        ]));\n    }\n    return obj; // If not an object, return as is\n}\nclass NeynarAPIClient {\n    constructor(config, options = {}) {\n        if (typeof config === 'string') {\n            console.error('Error: config must be of type Configuration');\n            console.log(`\nSeems, like you are using sdk v2 but the syntax on client instantiation is for sdk v1.\nSDK v1 -> v2 migration guide: https://docs.neynar.com/reference/neynar-nodejs-sdk-v1-to-v2-migration-guide\n\nCorrect usage way to instantiate the client:\n\nimport { NeynarAPIClient, Configuration } from \"@neynar/nodejs-sdk\";\n\nconst config = new Configuration({\n  apiKey: \"API_KEY\",\n  baseOptions: {\n    headers: {\n      \"x-neynar-experimental\": true,\n    },\n  },\n});\n\nconst client = new NeynarAPIClient(config);\\n`);\n            throw new Error('Invalid configuration type. Expected Configuration object but received string.');\n        }\n        const { logger = logger_1.silentLogger, axiosInstance: customAxiosInstance } = options;\n        this.logger = logger;\n        this.config = new configuration_1.Configuration({\n            apiKey: config.apiKey,\n            basePath: config.basePath,\n            baseOptions: config.baseOptions,\n        });\n        const axiosInstance = customAxiosInstance || axios_1.default.create({\n            headers: {\n                \"x-sdk-version\": sdkVersion,\n                \"x-sdk\": \"node\"\n            },\n        });\n        axiosInstance.defaults.decompress = true;\n        axiosInstance.interceptors.response.use((response) => response, (error) => {\n            if (error.response && [302].includes(error.response.status)) {\n                return {\n                    data: {\n                        location: error.response.headers.location,\n                    },\n                };\n            }\n            if (NeynarAPIClient.isApiErrorResponse(error)) {\n                const apiErrors = error.response.data;\n                this.logger.warn(`API errors: ${JSON.stringify(apiErrors)}`);\n            }\n            throw error;\n        });\n        this.apis = {\n            actionApi: new action_api_1.ActionApi(this.config, undefined, axiosInstance),\n            agentsApi: new agents_api_1.AgentsApi(this.config, undefined, axiosInstance),\n            appHostApi: new app_host_api_1.AppHostApi(this.config, undefined, axiosInstance),\n            banApi: new ban_api_1.BanApi(this.config, undefined, axiosInstance),\n            blockApi: new block_api_1.BlockApi(this.config, undefined, axiosInstance),\n            castApi: new cast_api_1.CastApi(this.config, undefined, axiosInstance),\n            channelApi: new channel_api_1.ChannelApi(this.config, undefined, axiosInstance),\n            feedApi: new feed_api_1.FeedApi(this.config, undefined, axiosInstance),\n            fnameApi: new fname_api_1.FnameApi(this.config, undefined, axiosInstance),\n            followsApi: new follows_api_1.FollowsApi(this.config, undefined, axiosInstance),\n            frameApi: new frame_api_1.FrameApi(this.config, undefined, axiosInstance),\n            loginApi: new login_api_1.LoginApi(this.config, undefined, axiosInstance),\n            metricsApi: new metrics_api_1.MetricsApi(this.config, undefined, axiosInstance),\n            muteApi: new mute_api_1.MuteApi(this.config, undefined, axiosInstance),\n            notificationsApi: new notifications_api_1.NotificationsApi(this.config, undefined, axiosInstance),\n            onchainApi: new onchain_api_1.OnchainApi(this.config, undefined, axiosInstance),\n            reactionApi: new reaction_api_1.ReactionApi(this.config, undefined, axiosInstance),\n            signerApi: new signer_api_1.SignerApi(this.config, undefined, axiosInstance),\n            storageApi: new storage_api_1.StorageApi(this.config, undefined, axiosInstance),\n            subscribersApi: new subscribers_api_1.SubscribersApi(this.config, undefined, axiosInstance),\n            userApi: new user_api_1.UserApi(this.config, undefined, axiosInstance),\n            webhookApi: new webhook_api_1.WebhookApi(this.config, undefined, axiosInstance),\n        };\n    }\n    static isApiErrorResponse(error) {\n        var _a;\n        if (!(error instanceof axios_1.AxiosError))\n            return false;\n        return (((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== undefined && \"message\" in error.response.data);\n    }\n    /**\n     * Securely communicate and perform actions on behalf of users across different apps. It enables an app to send data or trigger actions in another app on behalf of a mutual user by signing messages using the user\\'s Farcaster signer.\n     *\n     * @summary User actions across apps\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - The signer_uuid of the user on behalf of whom the action is being performed.\n     * @param {string} params.baseUrl  - The base URL of the app on which the action is being performed.\n     * @param {FarcasterActionReqBodyAction} params.action\n     *\n     * @returns {Promise<{ [key: string]: any; }>} A promise that resolves to a `{ [key: string]: any; }` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const baseUrl =\n     * const action =\n     *\n     * client.publishFarcasterAction({signerUuid, baseUrl, action}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/docs/farcaster-actions-spec)\n     *\n     */\n    async publishFarcasterAction(params) {\n        const adjustedParams = {};\n        const _params = { farcasterActionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.actionApi.publishFarcasterAction(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Creates a new transaction pay mini app that can be used to collect payments through a mini app\n     *\n     * @summary Create transaction pay mini app\n     *\n     * @param {object} params\n     * @param {FramePayTransactionRequestBody} params.framePayTransactionRequestBody\n     *\n     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const framePayTransactionRequestBody =\n     *\n     * client.createTransactionPayFrame({ framePayTransactionRequestBody }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async createTransactionPayFrame(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.agentsApi.createTransactionPayFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of interactions between two users\n     *\n     * @summary User interactions\n     *\n     * @param {object} params\n     * @param {number[]} params.fids  - Comma separated list of two FIDs\n     * @param {Array<NotificationType>} params.type [optional]  - Comma seperated list of Interaction type to fetch\n     *\n     * @returns {Promise<FetchUserInteractions200Response>} A promise that resolves to a `FetchUserInteractions200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fids =\n     * const type =\n     *\n     * client.fetchUserInteractions({ fids, type }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async fetchUserInteractions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.map(value => (String(value)));\n        }\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.join(\",\");\n        }\n        const response = await this.apis.agentsApi.fetchUserInteractions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Generates a summary of all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL.  Summary is generated by an LLM and is intended to be passed as a context to AI agents.\n     *\n     * @summary Cast conversation summary\n     *\n     * @param {object} params\n     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)\n     * @param {number} params.limit [optional]  - Number of casts to consider in a summary up to a point of target cast (Default: 20, Maximum: 50)\n     * @param {string} params.prompt [optional]  - Additional prompt used to generate a summary\n     *\n     * @returns {Promise<ConversationSummary>} A promise that resolves to a `ConversationSummary` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const identifier =\n     * const limit =\n     * const prompt =\n     *\n     * client.lookupCastConversationSummary({ identifier, limit, prompt }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation-summary)\n     *\n     */\n    async lookupCastConversationSummary(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.agentsApi.lookupCastConversationSummary(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns event object for app host events. Used if the app host intends to sign the event message instead of using Neynar-hosted signers.\n     *\n     * @summary Get app host event\n     *\n     * @param {object} params\n     * @param {string} params.appDomain  - The domain of the mini app\n     * @param {number} params.fid  - The FID of the user who initiated the event\n     * @param {AppHostEventType} params.event  - The type of event\n     *\n     * @returns {Promise<AppHostGetEventResponse>} A promise that resolves to a `AppHostGetEventResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const appDomain =\n     * const fid =\n     * const event =\n     *\n     * client.appHostGetEvent({ appDomain, fid, event }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async appHostGetEvent(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.appHostApi.appHostGetEvent(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns the current notification state for a specific user across all mini app domains in this app host. Shows which domains have notifications enabled.\n     *\n     * @summary Get the user\\'s notification subscriptions\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the user\n     *\n     * @returns {Promise<AppHostUserStateResponse>} A promise that resolves to a `AppHostUserStateResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     *\n     * client.appHostGetUserState({ fid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async appHostGetUserState(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.appHostApi.appHostGetUserState(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Post an app_host event to the domain\\'s webhook. Events such as enabling or disabling notifications for a user. Provide either a signed message or the signer UUID of an authorized neynar-hosted signers.\n     *\n     * @summary Process app host event\n     *\n     * @param {object} params\n     * @param {AppHostPostEventBody} params.appHostPostEventBody\n     *\n     * @returns {Promise<AppHostPostEventResponse>} A promise that resolves to a `AppHostPostEventResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const appHostPostEventBody =\n     *\n     * client.appHostPostEvent({ appHostPostEventBody }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async appHostPostEvent(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.appHostApi.appHostPostEvent(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Deletes a list of FIDs from the app associated with your API key.\n     *\n     * @summary Unban FIDs from app\n     *\n     * @param {object} params\n     * @param {Array<number>} params.fids\n     *\n     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fids =\n     *\n     * client.deleteBans({fids}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-bans)\n     *\n     */\n    async deleteBans(params) {\n        const adjustedParams = {};\n        const _params = { banReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.banApi.deleteBans(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all FIDs that your app has banned.\n     *\n     * @summary Banned FIDs of app\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<BanListResponse>} A promise that resolves to a `BanListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     *\n     * client.fetchBanList({ limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-ban-list)\n     *\n     */\n    async fetchBanList(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.banApi.fetchBanList(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Bans a list of FIDs from the app associated with your API key. Banned users, their casts and reactions will not appear in feeds.\n     *\n     * @summary Ban FIDs from app\n     *\n     * @param {object} params\n     * @param {Array<number>} params.fids\n     *\n     * @returns {Promise<BanResponse>} A promise that resolves to a `BanResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fids =\n     *\n     * client.publishBans({fids}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-bans)\n     *\n     */\n    async publishBans(params) {\n        const adjustedParams = {};\n        const _params = { banReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.banApi.publishBans(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Deletes a block for a given FID.\n     *\n     * @summary Unblock FID\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {number} params.blockedFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const blockedFid =\n     *\n     * client.deleteBlock({signerUuid, blockedFid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-block)\n     *\n     */\n    async deleteBlock(params) {\n        const adjustedParams = {};\n        const _params = { blockReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.blockApi.deleteBlock(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all FIDs that a user has blocked or has been blocked by\n     *\n     * @summary Blocked / Blocked by FIDs\n     *\n     * @param {object} params\n     * @param {number} params.blockerFid [optional]  - Providing this will return the users that this user has blocked\n     * @param {number} params.blockedFid [optional]  - Providing this will return the users that have blocked this user\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<BlockListResponse>} A promise that resolves to a `BlockListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const blockerFid =\n     * const blockedFid =\n     * const limit =\n     *\n     * client.fetchBlockList({ blockerFid, blockedFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-block-list)\n     *\n     */\n    async fetchBlockList(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.blockApi.fetchBlockList(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Adds a block for a given FID.\n     *\n     * @summary Block FID\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {number} params.blockedFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const blockedFid =\n     *\n     * client.publishBlock({signerUuid, blockedFid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-block)\n     *\n     */\n    async publishBlock(params) {\n        const adjustedParams = {};\n        const _params = { blockReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.blockApi.publishBlock(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Delete an existing cast. \\\\ (In order to delete a cast `signer_uuid` must be approved)\n     *\n     * @summary Delete a cast\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.targetHash  - Cast Hash\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const targetHash =\n     *\n     * client.deleteCast({signerUuid, targetHash}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-cast)\n     *\n     */\n    async deleteCast(params) {\n        const adjustedParams = {};\n        const _params = { deleteCastReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.castApi.deleteCast(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch multiple casts using their respective hashes.\n     *\n     * @summary Bulk fetch casts\n     *\n     * @param {object} params\n     * @param {string[]} params.casts  - Hashes of the cast to be retrived (Comma separated, no spaces)\n     * @param {number} params.viewerFid [optional]  - adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n     * @param {FetchBulkCastsSortTypeEnum} params.sortType [optional]  - Optional parameter to sort the casts based on different criteria\n     *\n     * @returns {Promise<CastsResponse>} A promise that resolves to a `CastsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const casts =\n     * const viewerFid =\n     * const sortType =\n     *\n     * client.fetchBulkCasts({ casts, viewerFid, sortType }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-casts)\n     *\n     */\n    async fetchBulkCasts(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        if (adjustedParams.casts && Array.isArray(adjustedParams.casts)) {\n            adjustedParams.casts = adjustedParams.casts.join(\",\");\n        }\n        const response = await this.apis.castApi.fetchBulkCasts(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all composer actions on Warpcast. You can filter by top or featured.\n     *\n     * @summary Fetch composer actions\n     *\n     * @param {object} params\n     * @param {CastComposerType} params.list  - Type of list to fetch.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 25)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<CastComposerActionsListResponse>} A promise that resolves to a `CastComposerActionsListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const list =\n     * const limit =\n     *\n     * client.fetchComposerActions({ list, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-composer-actions)\n     *\n     */\n    async fetchComposerActions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castApi.fetchComposerActions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Crawls the given URL and returns metadata useful when embedding the URL in a cast.\n     *\n     * @summary Embedded URL metadata\n     *\n     * @param {object} params\n     * @param {string} params.url  - URL to crawl metadata of\n     *\n     * @returns {Promise<CastEmbedCrawlResponse>} A promise that resolves to a `CastEmbedCrawlResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const url =\n     *\n     * client.fetchEmbeddedUrlMetadata({ url }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-embedded-url-metadata)\n     *\n     */\n    async fetchEmbeddedUrlMetadata(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castApi.fetchEmbeddedUrlMetadata(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Gets information about an individual cast by passing in a Farcaster web URL or cast hash\n     *\n     * @summary By hash or URL\n     *\n     * @param {object} params\n     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)\n     * @param {CastParamType} params.type\n     * @param {number} params.viewerFid [optional]  - adds viewer_context to cast object to show whether viewer has liked or recasted the cast.\n     *\n     * @returns {Promise<CastResponse>} A promise that resolves to a `CastResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const identifier =\n     * const type =\n     * const viewerFid =\n     *\n     * client.lookupCastByHashOrWarpcastUrl({ identifier, type, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-or-warpcast-url)\n     *\n     */\n    async lookupCastByHashOrWarpcastUrl(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.castApi.lookupCastByHashOrWarpcastUrl(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Farcaster URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.\n     *\n     * @summary Conversation for a cast\n     *\n     * @param {object} params\n     * @param {string} params.identifier  - Cast identifier (Its either a url or a hash)\n     * @param {CastParamType} params.type\n     * @param {number} params.replyDepth [optional]  - The depth of replies in the conversation that will be returned (default 2)\n     * @param {boolean} params.includeChronologicalParentCasts [optional]  - Include all parent casts in chronological order\n     * @param {number} params.viewerFid [optional]  - Providing this will return a conversation that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {CastConversationSortType} params.sortType [optional]  - Sort type for the ordering of descendants. Default is `chron`\n     * @param {LookupCastConversationFoldEnum} params.fold [optional]  - Show conversation above or below the fold. Lower quality responses are hidden below the fold. Not passing in a value shows the full conversation without any folding.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 50)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<Conversation>} A promise that resolves to a `Conversation` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const identifier =\n     * const type =\n     * const replyDepth =\n     * const includeChronologicalParentCasts =\n     * const viewerFid =\n     * const sortType =\n     * const fold =\n     * const limit =\n     *\n     * client.lookupCastConversation({ identifier, type, replyDepth, includeChronologicalParentCasts, viewerFid, sortType, fold, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-conversation)\n     *\n     */\n    async lookupCastConversation(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.castApi.lookupCastConversation(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Posts a cast or cast reply. Works with mentions and embeds.   (In order to post a cast `signer_uuid` must be approved)\n     *\n     * @summary Post a cast\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.text [optional]\n     * @param {Array<PostCastReqBodyEmbeds>} params.embeds [optional]\n     * @param {string} params.parent [optional]  - parent_url of the channel the cast is in, or hash of the cast\n     * @param {string} params.channelId [optional]  - Channel ID of the channel where the cast is to be posted. e.g. neynar, farcaster, warpcast\n     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.\n     * @param {number} params.parentAuthorFid [optional]  - The unique identifier of a farcaster user or app (unsigned integer)\n     *\n     * @returns {Promise<PostCastResponse>} A promise that resolves to a `PostCastResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const text =\n     * const embeds =\n     * const parent =\n     * const channelId =\n     * const idem =\n     * const parentAuthorFid =\n     *\n     * client.publishCast({signerUuid, text, embeds, parent, channelId, idem, parentAuthorFid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-cast)\n     *\n     */\n    async publishCast(params) {\n        const adjustedParams = {};\n        const _params = { postCastReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.castApi.publishCast(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Search for casts based on a query string, with optional AND filters\n     *\n     * @summary Search for casts\n     *\n     * @param {object} params\n     * @param {string} params.q  - Query string to search for casts. Supported operators:  | Operator  | Description                                                                                              | | --------- | -------------------------------------------------------------------------------------------------------- | | `+`       | Acts as the AND operator. This is the default operator between terms and can usually be omitted.         | | `|`      | Acts as the OR operator.                                                                                 | | `*`       | When used at the end of a term, signifies a prefix query.                                                  | | `\"`       | Wraps several terms into a phrase (for example, `\"star wars\"`).                                          | | `(`, `)`  | Wrap a clause for precedence (for example, `star + (wars | trek)`).                                     | | `~n`      | When used after a term (for example, `satr~3`), sets `fuzziness`. When used after a phrase, sets `slop`. | | `-`       | Negates the term.                                                                                        | | `before:` | Search for casts before a specific date. (e.g. `before:2025-04-20`)                                       | | `after:`  | Search for casts after a specific date. (e.g. `after:2025-04-20`)                                         |\n     * @param {SearchCastsModeEnum} params.mode [optional]  - Choices are: - `literal` - Searches for the words in the query string (default) - `semantic` - Searches for the meaning of the query string - `hybrid` - Combines both literal and semantic results\n     * @param {SearchSortType} params.sortType [optional]  - Choices are: - `desc_chron` - All casts sorted by time (default) - `algorithmic` - Casts sorted by engagement and time\n     * @param {number} params.authorFid [optional]  - Fid of the user whose casts you want to search\n     * @param {number} params.viewerFid [optional]  - Providing this will return search results that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {string} params.parentUrl [optional]  - Parent URL of the casts you want to search\n     * @param {string} params.channelId [optional]  - Channel ID of the casts you want to search\n     * @param {boolean} params.priorityMode [optional]  - When true, only returns search results from power badge users and users that the viewer follows (if viewer_fid is provided).\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     *\n     * @returns {Promise<CastsSearchResponse>} A promise that resolves to a `CastsSearchResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const q =\n     * const mode =\n     * const sortType =\n     * const authorFid =\n     * const viewerFid =\n     * const parentUrl =\n     * const channelId =\n     * const priorityMode =\n     * const limit =\n     *\n     * client.searchCasts({ q, mode, sortType, authorFid, viewerFid, parentUrl, channelId, priorityMode, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-casts)\n     *\n     */\n    async searchCasts(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.castApi.searchCasts(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of all channels with their details\n     *\n     * @summary Fetch all channels with their details\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 200)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     *\n     * client.fetchAllChannels({ limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-channels)\n     *\n     */\n    async fetchAllChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchAllChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns details of multiple channels\n     *\n     * @summary Bulk fetch\n     *\n     * @param {object} params\n     * @param {string[]} params.ids  - Comma separated list of channel IDs or parent_urls, up to 100 at a time\n     * @param {ChannelType} params.type [optional]  - Type of identifier being used to query the channels. Defaults to ID.\n     * @param {number} params.viewerFid [optional]  - FID of the user viewing the channels.\n     *\n     * @returns {Promise<ChannelResponseBulk>} A promise that resolves to a `ChannelResponseBulk` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const ids =\n     * const type =\n     * const viewerFid =\n     *\n     * client.fetchBulkChannels({ ids, type, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-channels)\n     *\n     */\n    async fetchBulkChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.ids && Array.isArray(adjustedParams.ids)) {\n            adjustedParams.ids = adjustedParams.ids.join(\",\");\n        }\n        const response = await this.apis.channelApi.fetchBulkChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of invites, either in a channel or for a user. If both are provided, open channel invite for that user is returned.\n     *\n     * @summary Open invites\n     *\n     * @param {object} params\n     * @param {string} params.channelId [optional]  - Channel ID for the channel being queried\n     * @param {number} params.invitedFid [optional]  - FID of the user being invited\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelMemberInviteListResponse>} A promise that resolves to a `ChannelMemberInviteListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const channelId =\n     * const invitedFid =\n     * const limit =\n     *\n     * client.fetchChannelInvites({ channelId, invitedFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-invites)\n     *\n     */\n    async fetchChannelInvites(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchChannelInvites(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of members in a channel\n     *\n     * @summary Fetch members\n     *\n     * @param {object} params\n     * @param {string} params.channelId  - Channel ID for the channel being queried\n     * @param {number} params.fid [optional]  - FID of the user being queried. Specify this to check if a user is a member of the channel without paginating through all members.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const channelId =\n     * const fid =\n     * const limit =\n     *\n     * client.fetchChannelMembers({ channelId, fid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-members)\n     *\n     */\n    async fetchChannelMembers(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.channelApi.fetchChannelMembers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of followers for a specific channel. Max limit is 1000. Use cursor for pagination.\n     *\n     * @summary For channel\n     *\n     * @param {object} params\n     * @param {string} params.id  - Channel ID for the channel being queried\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     * @param {number} params.limit [optional]  - Number of followers to fetch (Default: 25, Maximum: 1000)\n     *\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const id =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchFollowersForAChannel({ id, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-followers-for-a-channel)\n     *\n     */\n    async fetchFollowersForAChannel(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.channelApi.fetchFollowersForAChannel(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of relevant channel followers for a specific FID. This usually shows on a channel as \\\"X, Y, Z follow this channel\\\".\n     *\n     * @summary Relevant followers\n     *\n     * @param {object} params\n     * @param {string} params.id  - Channel ID being queried\n     * @param {number} params.viewerFid  - The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.\n     *\n     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const id =\n     * const viewerFid =\n     *\n     * client.fetchRelevantFollowersForAChannel({ id, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers-for-a-channel)\n     *\n     */\n    async fetchRelevantFollowersForAChannel(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.channelApi.fetchRelevantFollowersForAChannel(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of trending channels based on activity\n     *\n     * @summary Channels by activity\n     *\n     * @param {object} params\n     * @param {FetchTrendingChannelsTimeWindowEnum} params.timeWindow [optional]\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 10, Maximum: 25)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<TrendingChannelResponse>} A promise that resolves to a `TrendingChannelResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const timeWindow =\n     * const limit =\n     *\n     * client.fetchTrendingChannels({ timeWindow, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-channels)\n     *\n     */\n    async fetchTrendingChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchTrendingChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of all channels with their details that an FID is a member of. Data may have a delay of up to 1 hour.\n     *\n     * @summary Member of\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the user.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelMemberListResponse>} A promise that resolves to a `ChannelMemberListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const limit =\n     *\n     * client.fetchUserChannelMemberships({ fid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channel-memberships)\n     *\n     */\n    async fetchUserChannelMemberships(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchUserChannelMemberships(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of all channels with their details that a FID follows.\n     *\n     * @summary Following\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the user.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelListResponse>} A promise that resolves to a `ChannelListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const limit =\n     *\n     * client.fetchUserChannels({ fid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-channels)\n     *\n     */\n    async fetchUserChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchUserChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all channels that a user has casted in, in reverse chronological order.\n     *\n     * @summary Fetch channels that user is active in\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The user's FID (identifier)\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<UsersActiveChannelsResponse>} A promise that resolves to a `UsersActiveChannelsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const limit =\n     *\n     * client.fetchUsersActiveChannels({ fid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-active-channels)\n     *\n     */\n    async fetchUsersActiveChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.fetchUsersActiveChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Follow a channel\n     *\n     * @summary Follow a channel\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.channelId  - The unique identifier of a farcaster channel\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const channelId =\n     *\n     * client.followChannel({signerUuid, channelId}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-channel)\n     *\n     */\n    async followChannel(params) {\n        const adjustedParams = {};\n        const _params = { channelFollowReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.channelApi.followChannel(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Invite a user to a channel\n     *\n     * @summary Invite\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.channelId  - The unique identifier of a farcaster channel\n     * @param {number} params.fid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {ChannelMemberRole} params.role\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const channelId =\n     * const fid =\n     * const role =\n     *\n     * client.inviteChannelMember({signerUuid, channelId, fid, role}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/invite-channel-member)\n     *\n     */\n    async inviteChannelMember(params) {\n        const adjustedParams = {};\n        const _params = { inviteChannelMemberReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.channelApi.inviteChannelMember(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns details of a channel\n     *\n     * @summary By ID or parent_url\n     *\n     * @param {object} params\n     * @param {string} params.id  - Channel ID for the channel being queried\n     * @param {ChannelType} params.type [optional]  - Type of identifier being used to query the channel. Defaults to ID.\n     * @param {number} params.viewerFid [optional]  - FID of the user viewing the channel.\n     *\n     * @returns {Promise<ChannelResponse>} A promise that resolves to a `ChannelResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const id =\n     * const type =\n     * const viewerFid =\n     *\n     * client.lookupChannel({ id, type, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-channel)\n     *\n     */\n    async lookupChannel(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.lookupChannel(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Remove a user from a channel or a user\\'s invite to a channel role\n     *\n     * @summary Remove user\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.channelId  - The unique identifier of a farcaster channel\n     * @param {number} params.fid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {ChannelMemberRole} params.role\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const channelId =\n     * const fid =\n     * const role =\n     *\n     * client.removeChannelMember({signerUuid, channelId, fid, role}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/remove-channel-member)\n     *\n     */\n    async removeChannelMember(params) {\n        const adjustedParams = {};\n        const _params = { removeChannelMemberReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.channelApi.removeChannelMember(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Accept or reject a channel invite\n     *\n     * @summary Accept or reject an invite\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.channelId  - The unique identifier of a farcaster channel\n     * @param {ChannelMemberRole} params.role\n     * @param {boolean} params.accept  - Accept or reject the invite\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const channelId =\n     * const role =\n     * const accept =\n     *\n     * client.respondChannelInvite({signerUuid, channelId, role, accept}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/respond-channel-invite)\n     *\n     */\n    async respondChannelInvite(params) {\n        const adjustedParams = {};\n        const _params = { respondChannelInviteReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.channelApi.respondChannelInvite(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of channels based on ID or name\n     *\n     * @summary Search by ID or name\n     *\n     * @param {object} params\n     * @param {string} params.q  - Channel ID or name for the channel being queried\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 200)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ChannelSearchResponse>} A promise that resolves to a `ChannelSearchResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const q =\n     * const limit =\n     *\n     * client.searchChannels({ q, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-channels)\n     *\n     */\n    async searchChannels(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.channelApi.searchChannels(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Unfollow a channel\n     *\n     * @summary Unfollow a channel\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.channelId  - The unique identifier of a farcaster channel\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const channelId =\n     *\n     * client.unfollowChannel({signerUuid, channelId}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-channel)\n     *\n     */\n    async unfollowChannel(params) {\n        const adjustedParams = {};\n        const _params = { channelFollowReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.channelApi.unfollowChannel(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel\n     *\n     * @summary Chronologically\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of user whose recent casts you want to fetch\n     * @param {number} params.appFid [optional]  - Optionally filter to casts created via a specific app FID, e.g. 9152 for Warpcast\n     * @param {number} params.viewerFid [optional]  - FID of the user viewing the feed\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 150)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     * @param {boolean} params.includeReplies [optional]  - Include reply casts by the author in the response, true by default\n     * @param {string} params.parentUrl [optional]  - Parent URL to filter the feed; mutually exclusive with channel_id\n     * @param {string} params.channelId [optional]  - Channel ID to filter the feed; mutually exclusive with parent_url\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const appFid =\n     * const viewerFid =\n     * const limit =\n     * const includeReplies =\n     * const parentUrl =\n     * const channelId =\n     *\n     * client.fetchCastsForUser({ fid, appFid, viewerFid, limit, includeReplies, parentUrl, channelId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-for-user)\n     *\n     */\n    async fetchCastsForUser(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchCastsForUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.\n     *\n     * @summary By filters\n     *\n     * @param {object} params\n     * @param {FeedType} params.feedType  - Defaults to following (requires FID or address). If set to filter (requires filter_type)\n     * @param {FilterType} params.filterType [optional]  - Used when feed_type=filter. Can be set to FIDs (requires FIDs) or parent_url (requires parent_url) or channel_id (requires channel_id)\n     * @param {number} params.fid [optional]  - (Optional) FID of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type\n     * @param {string} params.fids [optional]  - Used when filter_type=FIDs . Create a feed based on a list of FIDs. Max array size is 100. Requires feed_type and filter_type.\n     * @param {string} params.parentUrl [optional]  - Used when filter_type=parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type.\n     * @param {string} params.channelId [optional]  - Used when filter_type=channel_id can be used to fetch casts under a channel. Requires feed_type and filter_type.\n     * @param {boolean} params.membersOnly [optional]  - Used when filter_type=channel_id. Only include casts from members of the channel. True by default.\n     * @param {string} params.embedUrl [optional]  - Used when filter_type=embed_url. Casts with embedded URLs prefixed by this embed_url param will be returned. We normalize your given URL prefix and prepend 'https://' if no protocol is included. Requires feed_type and filter_type.\n     * @param {Array<EmbedType>} params.embedTypes [optional]  - Used when filter_type=embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type.\n     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const feedType =\n     * const filterType =\n     * const fid =\n     * const fids =\n     * const parentUrl =\n     * const channelId =\n     * const membersOnly =\n     * const embedUrl =\n     * const embedTypes =\n     * const withRecasts =\n     * const limit =\n     * const viewerFid =\n     *\n     * client.fetchFeed({ feedType, filterType, fid, fids, parentUrl, channelId, membersOnly, embedUrl, embedTypes, withRecasts, limit, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed)\n     *\n     */\n    async fetchFeed(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchFeed(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch feed based on channel IDs\n     *\n     * @summary By channel IDs\n     *\n     * @param {object} params\n     * @param {string[]} params.channelIds  - Comma separated list of up to 10 channel IDs e.g. neynar,farcaster\n     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {boolean} params.withReplies [optional]  - Include replies in the response, false by default\n     * @param {boolean} params.membersOnly [optional]  - Only include casts from members of the channel. True by default.\n     * @param {number[]} params.fids [optional]  - Comma separated list of FIDs to filter the feed by, up to 10 at a time\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     * @param {boolean} params.shouldModerate [optional]  - If true, only casts that have been liked by the moderator (if one exists) will be returned.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const channelIds =\n     * const withRecasts =\n     * const viewerFid =\n     * const withReplies =\n     * const membersOnly =\n     * const fids =\n     * const limit =\n     * const shouldModerate =\n     *\n     * client.fetchFeedByChannelIds({ channelIds, withRecasts, viewerFid, withReplies, membersOnly, fids, limit, shouldModerate }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-channel-ids)\n     *\n     */\n    async fetchFeedByChannelIds(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        if (adjustedParams.channelIds && Array.isArray(adjustedParams.channelIds)) {\n            adjustedParams.channelIds = adjustedParams.channelIds.join(\",\");\n        }\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.map(value => (String(value)));\n        }\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.join(\",\");\n        }\n        const response = await this.apis.feedApi.fetchFeedByChannelIds(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch feed based on parent URLs\n     *\n     * @summary By parent URLs\n     *\n     * @param {object} params\n     * @param {string[]} params.parentUrls  - Comma separated list of parent_urls\n     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {boolean} params.withReplies [optional]  - Include replies in the response, false by default\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const parentUrls =\n     * const withRecasts =\n     * const viewerFid =\n     * const withReplies =\n     * const limit =\n     *\n     * client.fetchFeedByParentUrls({ parentUrls, withRecasts, viewerFid, withReplies, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-by-parent-urls)\n     *\n     */\n    async fetchFeedByParentUrls(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        if (adjustedParams.parentUrls && Array.isArray(adjustedParams.parentUrls)) {\n            adjustedParams.parentUrls = adjustedParams.parentUrls.join(\",\");\n        }\n        const response = await this.apis.feedApi.fetchFeedByParentUrls(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a personalized For You feed for a user\n     *\n     * @summary For you\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of user whose feed you want to create\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {ForYouProvider} params.provider [optional]\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 50)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     * @param {string} params.providerMetadata [optional]  - provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     * const provider =\n     * const limit =\n     * const providerMetadata =\n     *\n     * client.fetchFeedForYou({ fid, viewerFid, provider, limit, providerMetadata }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-feed-for-you)\n     *\n     */\n    async fetchFeedForYou(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchFeedForYou(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch feed of casts with mini apps, reverse chronological order\n     *\n     * @summary Casts with mini apps\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     * const viewerFid =\n     *\n     * client.fetchFramesOnlyFeed({ limit, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frames-only-feed)\n     *\n     */\n    async fetchFramesOnlyFeed(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchFramesOnlyFeed(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first\n     *\n     * @summary 10 most popular casts\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of user whose feed you want to create\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<BulkCastsResponse>} A promise that resolves to a `BulkCastsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     *\n     * client.fetchPopularCastsByUser({ fid, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-popular-casts-by-user)\n     *\n     */\n    async fetchPopularCastsByUser(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.feedApi.fetchPopularCastsByUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch recent replies and recasts for a given user FID; sorted by most recent first\n     *\n     * @summary Replies and recasts\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of user whose replies and recasts you want to fetch\n     * @param {FetchRepliesAndRecastsForUserFilterEnum} params.filter [optional]  - filter to fetch only replies or recasts\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 50)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const filter =\n     * const limit =\n     * const viewerFid =\n     *\n     * client.fetchRepliesAndRecastsForUser({ fid, filter, limit, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-replies-and-recasts-for-user)\n     *\n     */\n    async fetchRepliesAndRecastsForUser(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.feedApi.fetchRepliesAndRecastsForUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.\n     *\n     * @summary Trending feeds\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 10, Maximum: 10)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {FetchTrendingFeedTimeWindowEnum} params.timeWindow [optional]  - Time window for trending casts (7d window for channel feeds only)\n     * @param {string} params.channelId [optional]  - Channel ID to filter trending casts. Less active channels might have no casts in the time window selected. Provide either `channel_id` or `parent_url`, not both.\n     * @param {string} params.parentUrl [optional]  - Parent URL to filter trending casts. Less active channels might have no casts in the time window selected. Provide either `channel_id` or `parent_url`, not both.\n     * @param {FeedTrendingProvider} params.provider [optional]  - The provider of the trending casts feed.\n     * @param {string} params.providerMetadata [optional]  - provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     * const viewerFid =\n     * const timeWindow =\n     * const channelId =\n     * const parentUrl =\n     * const provider =\n     * const providerMetadata =\n     *\n     * client.fetchTrendingFeed({ limit, viewerFid, timeWindow, channelId, parentUrl, provider, providerMetadata }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-trending-feed)\n     *\n     */\n    async fetchTrendingFeed(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchTrendingFeed(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch feed based on who a user is following\n     *\n     * @summary Following\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of user whose feed you want to create\n     * @param {number} params.viewerFid [optional]  - Providing this will return a feed that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {boolean} params.withRecasts [optional]  - Include recasts in the response, true by default\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<FeedResponse>} A promise that resolves to a `FeedResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     * const withRecasts =\n     * const limit =\n     *\n     * client.fetchUserFollowingFeed({ fid, viewerFid, withRecasts, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following-feed)\n     *\n     */\n    async fetchUserFollowingFeed(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.feedApi.fetchUserFollowingFeed(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Check if a given fname is available\n     *\n     * @summary Check fname availability\n     *\n     * @param {object} params\n     * @param {string} params.fname\n     *\n     * @returns {Promise<FnameAvailabilityResponse>} A promise that resolves to a `FnameAvailabilityResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fname =\n     *\n     * client.isFnameAvailable({ fname }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/is-fname-available)\n     *\n     */\n    async isFnameAvailable(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.fnameApi.isFnameAvailable(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of suggested users to follow. Used to help users discover new users to follow\n     *\n     * @summary Suggest Follows\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user whose following you want to fetch.\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     *\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchFollowSuggestions({ fid, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-follow-suggestions)\n     *\n     */\n    async fetchFollowSuggestions(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.followsApi.fetchFollowSuggestions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of relevant followers for a specific FID. This usually shows on a profile as \\\"X, Y and Z follow this user\\\".\n     *\n     * @summary Relevant followers\n     *\n     * @param {object} params\n     * @param {number} params.targetFid  - User who's profile you are looking at\n     * @param {number} params.viewerFid  - The FID of the user to customize this response for. Providing this will also return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.\n     *\n     * @returns {Promise<RelevantFollowersResponse>} A promise that resolves to a `RelevantFollowersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const targetFid =\n     * const viewerFid =\n     *\n     * client.fetchRelevantFollowers({ targetFid, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-followers)\n     *\n     */\n    async fetchRelevantFollowers(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.followsApi.fetchRelevantFollowers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of followers for a specific FID.\n     *\n     * @summary Followers\n     *\n     * @param {object} params\n     * @param {number} params.fid  - User who's profile you are looking at\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of followers that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {FollowSortType} params.sortType [optional]  - Sort type for fetch followers. Default is `desc_chron`\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     * const sortType =\n     * const limit =\n     *\n     * client.fetchUserFollowers({ fid, viewerFid, sortType, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n     *\n     */\n    async fetchUserFollowers(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.followsApi.fetchUserFollowers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of users who a given user is following. Can optionally include a viewer_fid and sort_type.\n     *\n     * @summary Following\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user whose following you want to fetch.\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {FollowSortType} params.sortType [optional]  - Optional parameter to sort the users based on different criteria.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<FollowersResponse>} A promise that resolves to a `FollowersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const viewerFid =\n     * const sortType =\n     * const limit =\n     *\n     * client.fetchUserFollowing({ fid, viewerFid, sortType, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n     *\n     */\n    async fetchUserFollowing(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.followsApi.fetchUserFollowing(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Delete an existing mini app, if it was made by the developer (identified by API key)\n     *\n     * @summary Delete mini app\n     *\n     * @param {object} params\n     * @param {string} params.uuid [optional]\n     *\n     * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const uuid =\n     *\n     * client.deleteNeynarFrame({uuid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)\n     *\n     */\n    async deleteNeynarFrame(params) {\n        const adjustedParams = {};\n        const _params = { deleteFrameReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.deleteNeynarFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * A curated list of featured mini apps\n     *\n     * @summary Mini apps catalog\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 100, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     * @param {MiniAppTimeWindow} params.timeWindow [optional]  - Time window used to calculate the change in trending score for each mini app, used to sort mini app results\n     * @param {Array<FetchFrameCatalogCategoriesEnum>} params.categories [optional]  - Comma separated list of categories to include in the results.  Includes all if left blank.  Example: `categories=games,social` OR: `categories=games&categories=social`\n     *\n     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     * const timeWindow =\n     * const categories =\n     *\n     * client.fetchFrameCatalog({ limit, timeWindow, categories }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async fetchFrameCatalog(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.fetchFrameCatalog(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches the mini app meta tags from the URL\n     *\n     * @summary Meta tags from URL\n     *\n     * @param {object} params\n     * @param {string} params.url  - The mini app URL to crawl\n     *\n     * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const url =\n     *\n     * client.fetchFrameMetaTagsFromUrl({ url }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)\n     *\n     */\n    async fetchFrameMetaTagsFromUrl(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.fetchFrameMetaTagsFromUrl(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of mini apps made by the developer (identified by API key)\n     *\n     * @summary List of mini apps\n     *\n     *\n     * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object.\n     *\n     * @example\n     *\n     * client.fetchNeynarFrames().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)\n     *\n     */\n    async fetchNeynarFrames() {\n        const response = await this.apis.frameApi.fetchNeynarFrames();\n        return response.data;\n    }\n    /**\n     * Returns a list of notifications tokens related to a mini app\n     *\n     * @summary List of mini app notification tokens\n     *\n     * @param {object} params\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {number[]} params.fids [optional]  - Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don't pass in FIDs, you will get back all the notification tokens for the mini app.\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     *\n     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const limit =\n     * const fids =\n     *\n     * client.fetchNotificationTokens({ limit, fids }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)\n     *\n     */\n    async fetchNotificationTokens(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.map(value => (String(value)));\n        }\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.join(\",\");\n        }\n        const response = await this.apis.frameApi.fetchNotificationTokens(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user\n     *\n     * @summary Relevant mini apps\n     *\n     * @param {object} params\n     * @param {number} params.viewerFid  - FID of the user to fetch relevant mini apps for\n     * @param {MiniAppTimeWindow} params.timeWindow [optional]  - Time window used to limit statistics used to calculate mini app relevance\n     *\n     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const viewerFid =\n     * const timeWindow =\n     *\n     * client.fetchRelevantFrames({ viewerFid, timeWindow }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-relevant)\n     *\n     */\n    async fetchRelevantFrames(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.fetchRelevantFrames(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.\n     *\n     * @summary Analytics for the mini app\n     *\n     * @param {object} params\n     * @param {string} params.frameUrl\n     * @param {ValidateFrameAnalyticsType} params.analyticsType\n     * @param {string} params.start\n     * @param {string} params.stop\n     * @param {ValidateFrameAggregateWindow} params.aggregateWindow [optional]  - Required for `analytics_type=interactions-per-cast`\n     *\n     * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const frameUrl =\n     * const analyticsType =\n     * const start =\n     * const stop =\n     * const aggregateWindow =\n     *\n     * client.fetchValidateFrameAnalytics({ frameUrl, analyticsType, start, stop, aggregateWindow }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)\n     *\n     */\n    async fetchValidateFrameAnalytics(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.fetchValidateFrameAnalytics(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of all the mini apps validated by a user\n     *\n     * @summary All mini apps validated by user\n     *\n     *\n     * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object.\n     *\n     * @example\n     *\n     * client.fetchValidateFrameList().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)\n     *\n     */\n    async fetchValidateFrameList() {\n        const response = await this.apis.frameApi.fetchValidateFrameList();\n        return response.data;\n    }\n    /**\n     * Retrieve notification delivery and opened stats for notification campaigns\n     *\n     * @summary Get notification campaign stats\n     *\n     * @param {object} params\n     * @param {string} params.campaignId [optional]  - An ID of a specific notification campaign to query\n     * @param {number} params.limit [optional]  - The number of results to return (Default: 100,\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     *\n     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const campaignId =\n     * const limit =\n     *\n     * client.getNotificationCampaignStats({ campaignId, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async getNotificationCampaignStats(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.getNotificationCampaignStats(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Retrieves details about a transaction pay mini app by ID\n     *\n     * @summary Get transaction pay mini app\n     *\n     * @param {object} params\n     * @param {string} params.id  - ID of the transaction mini app to retrieve\n     *\n     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const id =\n     *\n     * client.getTransactionPayFrame({ id }).then(response => {\n     *   console.log('response:', response);\n     * });\n     */\n    async getTransactionPayFrame(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.getTransactionPayFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a mini app either by UUID or Neynar URL\n     *\n     * @summary Mini app by UUID or URL\n     *\n     * @param {object} params\n     * @param {FrameType} params.type\n     * @param {string} params.uuid [optional]  - UUID of the mini app to fetch\n     * @param {string} params.url [optional]  - URL of the Neynar mini app to fetch\n     *\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const type =\n     * const uuid =\n     * const url =\n     *\n     * client.lookupNeynarFrame({ type, uuid, url }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)\n     *\n     */\n    async lookupNeynarFrame(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.lookupNeynarFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Post mini app actions, cast actions or cast composer actions to the server  \\\\ (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.\n     *\n     * @summary Post a mini app action, cast action or a cast composer action\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.castHash [optional]  - Cast Hash\n     * @param {FrameAction} params.action\n     *\n     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const castHash =\n     * const action =\n     *\n     * client.postFrameAction({signerUuid, castHash, action}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)\n     *\n     */\n    async postFrameAction(params) {\n        const adjustedParams = {};\n        const _params = { frameActionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.postFrameAction(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.\n     *\n     * @summary Signature packet\n     *\n     * @param {object} params\n     * @param {string} params.castHash [optional]  - Cast Hash\n     * @param {FrameAction} params.action\n     * @param {FrameSignaturePacket} params.signaturePacket\n     *\n     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const castHash =\n     * const action =\n     * const signaturePacket =\n     *\n     * client.postFrameActionDeveloperManaged({castHash, action, signaturePacket}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)\n     *\n     */\n    async postFrameActionDeveloperManaged(params) {\n        const adjustedParams = {};\n        const _params = { frameDeveloperManagedActionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.postFrameActionDeveloperManaged(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Send notifications to interactors of a mini app\n     *\n     * @summary Send notifications\n     *\n     * @param {object} params\n     * @param {Array<number>} params.targetFids  - An array of target FIDs to whom the notifications should be sent. Each FID must be a positive integer. Pass an empty array to send notifications to all FIDs with notifications enabled for the mini app.\n     * @param {SendFrameNotificationsReqBodyNotification} params.notification\n     * @param {SendFrameNotificationsReqBodyFilters} params.filters [optional]\n     *\n     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const targetFids =\n     * const notification =\n     * const filters =\n     *\n     * client.publishFrameNotifications({targetFids, notification, filters}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)\n     *\n     */\n    async publishFrameNotifications(params) {\n        const adjustedParams = {};\n        const _params = { sendFrameNotificationsReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.publishFrameNotifications(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Create a new mini app with a list of pages.\n     *\n     * @summary Create mini app\n     *\n     * @param {object} params\n     * @param {string} params.name  - The name of the mini app.\n     * @param {Array<NeynarFramePage>} params.pages\n     *\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const name =\n     * const pages =\n     *\n     * client.publishNeynarFrame({name, pages}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)\n     *\n     */\n    async publishNeynarFrame(params) {\n        const adjustedParams = {};\n        const _params = { neynarFrameCreationReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.publishNeynarFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Search for mini apps based on a query string\n     *\n     * @summary Search mini apps\n     *\n     * @param {object} params\n     * @param {string} params.q  - Query string to search for mini apps\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     *\n     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const q =\n     * const limit =\n     *\n     * client.searchFrames({ q, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)\n     *\n     */\n    async searchFrames(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.frameApi.searchFrames(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)\n     *\n     * @summary Update mini app\n     *\n     * @param {object} params\n     * @param {string} params.uuid  - The UUID of the mini app to update.\n     * @param {string} params.name [optional]  - The name of the mini app.\n     * @param {Array<NeynarFramePage>} params.pages\n     *\n     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const uuid =\n     * const name =\n     * const pages =\n     *\n     * client.updateNeynarFrame({uuid, name, pages}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)\n     *\n     */\n    async updateNeynarFrame(params) {\n        const adjustedParams = {};\n        const _params = { neynarFrameUpdateReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.updateNeynarFrame(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Validates a mini app against by an interacting user against a Farcaster Hub \\\\ (In order to validate a mini app, message bytes from Frame Action must be provided in hex)\n     *\n     * @summary Validate mini app action\n     *\n     * @param {object} params\n     * @param {string} params.messageBytesInHex  - Hexadecimal string of message bytes.\n     * @param {boolean} params.castReactionContext [optional]  - Adds viewer_context inside the cast object to indicate whether the interactor reacted to the cast housing the mini app.\n     * @param {boolean} params.followContext [optional]  - Adds viewer_context inside the user (interactor) object to indicate whether the interactor follows or is followed by the cast author.\n     * @param {boolean} params.signerContext [optional]  - Adds context about the app used by the user inside `frame.action`.\n     * @param {boolean} params.channelFollowContext [optional]  - Adds context about the channel that the cast belongs to inside of the cast object.\n     *\n     * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const messageBytesInHex =\n     * const castReactionContext =\n     * const followContext =\n     * const signerContext =\n     * const channelFollowContext =\n     *\n     * client.validateFrameAction({messageBytesInHex, castReactionContext, followContext, signerContext, channelFollowContext}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)\n     *\n     */\n    async validateFrameAction(params) {\n        const adjustedParams = {};\n        const _params = { validateFrameActionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.frameApi.validateFrameAction(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Nonce to sign a message\n     *\n     * @summary Fetch nonce\n     *\n     *\n     * @returns {Promise<NonceResponse>} A promise that resolves to a `NonceResponse` object.\n     *\n     * @example\n     *\n     * client.fetchNonce().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-nonce)\n     *\n     */\n    async fetchNonce() {\n        const response = await this.apis.loginApi.fetchNonce();\n        return response.data;\n    }\n    /**\n     * Fetches metrics casts matching a query\n     *\n     * @summary Metrics for casts\n     *\n     * @param {object} params\n     * @param {string} params.q  - Query string to search for casts\n     * @param {FetchCastMetricsIntervalEnum} params.interval [optional]  - Interval of time for which to fetch metrics. Default is 30d.\n     * @param {number} params.authorFid [optional]  - Fid of the user whose casts you want to search\n     * @param {string} params.channelId [optional]  - Channel ID of the casts you want to search\n     *\n     * @returns {Promise<CastsMetricsResponse>} A promise that resolves to a `CastsMetricsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const q =\n     * const interval =\n     * const authorFid =\n     * const channelId =\n     *\n     * client.fetchCastMetrics({ q, interval, authorFid, channelId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-metrics)\n     *\n     */\n    async fetchCastMetrics(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.metricsApi.fetchCastMetrics(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Deletes a mute for a given FID. This is an allowlisted API, reach out if you want access.\n     *\n     * @summary Unmute FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {number} params.mutedFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     *\n     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const mutedFid =\n     *\n     * client.deleteMute({fid, mutedFid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-mute)\n     *\n     */\n    async deleteMute(params) {\n        const adjustedParams = {};\n        const _params = { muteReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.muteApi.deleteMute(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all FIDs that a user has muted.\n     *\n     * @summary Muted FIDs of user\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The user's FID (identifier)\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 20, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<MuteListResponse>} A promise that resolves to a `MuteListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const limit =\n     *\n     * client.fetchMuteList({ fid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-mute-list)\n     *\n     */\n    async fetchMuteList(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.muteApi.fetchMuteList(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Adds a mute for a given FID. This is an allowlisted API, reach out if you want access.\n     *\n     * @summary Mute FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {number} params.mutedFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     *\n     * @returns {Promise<MuteResponse>} A promise that resolves to a `MuteResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const mutedFid =\n     *\n     * client.publishMute({fid, mutedFid}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-mute)\n     *\n     */\n    async publishMute(params) {\n        const adjustedParams = {};\n        const _params = { muteReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.muteApi.publishMute(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of notifications for a specific FID.\n     *\n     * @summary For user\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.\n     * @param {Array<NotificationType>} params.type [optional]  - Notification type to fetch. Comma separated values of follows, recasts, likes, mentions, replies.\n     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the user follows.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const type =\n     * const priorityMode =\n     * const limit =\n     *\n     * client.fetchAllNotifications({ fid, type, priorityMode, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-all-notifications)\n     *\n     */\n    async fetchAllNotifications(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.notificationsApi.fetchAllNotifications(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of notifications for a user in specific channels\n     *\n     * @summary For user by channel\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.\n     * @param {string[]} params.channelIds  - Comma separated channel_ids (find list of all channels here - https://docs.neynar.com/reference/list-all-channels)\n     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the user follows.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const channelIds =\n     * const priorityMode =\n     * const limit =\n     *\n     * client.fetchChannelNotificationsForUser({ fid, channelIds, priorityMode, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-channel-notifications-for-user)\n     *\n     */\n    async fetchChannelNotificationsForUser(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.channelIds && Array.isArray(adjustedParams.channelIds)) {\n            adjustedParams.channelIds = adjustedParams.channelIds.join(\",\");\n        }\n        const response = await this.apis.notificationsApi.fetchChannelNotificationsForUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Returns a list of notifications for a user in specific parent_urls\n     *\n     * @summary For user by parent_urls\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user you you want to fetch notifications for. The response will respect this user's mutes and blocks.\n     * @param {string[]} params.parentUrls  - Comma separated parent_urls\n     * @param {boolean} params.priorityMode [optional]  - When true, only returns notifications from power badge users and users that the user follows.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 15, Maximum: 25)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<NotificationsResponse>} A promise that resolves to a `NotificationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const parentUrls =\n     * const priorityMode =\n     * const limit =\n     *\n     * client.fetchNotificationsByParentUrlForUser({ fid, parentUrls, priorityMode, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notifications-by-parent-url-for-user)\n     *\n     */\n    async fetchNotificationsByParentUrlForUser(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.parentUrls && Array.isArray(adjustedParams.parentUrls)) {\n            adjustedParams.parentUrls = adjustedParams.parentUrls.join(\",\");\n        }\n        const response = await this.apis.notificationsApi.fetchNotificationsByParentUrlForUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Mark notifications as seen. You can choose one of two authorization methods, either:   1. Provide a valid signer_uuid in the request body (Most common)   2. Provide a valid, signed \\\"Bearer\\\" token in the request\\'s `Authorization` header similar to the      approach described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication)\n     *\n     * @summary Mark as seen\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid [optional]  - The UUID of a signer with at least one write permission.  Required unless a valid Authorization Bearer token is provided in the header.\n     * @param {NotificationType} params.type [optional]\n     * @param {string} params.authorization [optional]  - Optional Bearer token for certain endpoints. The token format is described [here](https://docs.farcaster.xyz/reference/warpcast/api#authentication).\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const type =\n     * const authorization =\n     *\n     * client.markNotificationsAsSeen({signerUuid, type, authorization}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/mark-notifications-as-seen)\n     *\n     */\n    async markNotificationsAsSeen(params) {\n        const adjustedParams = {};\n        const _params = { markNotificationsAsSeenReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.notificationsApi.markNotificationsAsSeen(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Creates a new token.\n     *\n     * @summary Deploy fungible\n     *\n     * @param {object} params\n     * @param {string} params.owner  - Ethereum address of the one who is creating the token\n     * @param {string} params.symbol  - Symbol/Ticker for the token\n     * @param {string} params.name  - Name of the token\n     * @param {File} params.metadataMedia [optional]  - Media file associated with the token.  Supported formats are image/jpeg, image/gif and image/png\n     * @param {string} params.metadataDescription [optional]  - Description of the token\n     * @param {DeployFungibleMetadataNsfwEnum} params.metadataNsfw [optional]  - Indicates if the token is NSFW (Not Safe For Work).\n     * @param {string} params.metadataWebsiteLink [optional]  - Website link related to the token\n     * @param {string} params.metadataTwitter [optional]  - Twitter profile link\n     * @param {string} params.metadataDiscord [optional]  - Discord server link\n     * @param {string} params.metadataTelegram [optional]  - Telegram link\n     * @param {DeployFungibleNetworkEnum} params.network [optional]  - Network/Chain name\n     * @param {DeployFungibleFactoryEnum} params.factory [optional]  - Factory name - wow -> [wow.xyz](https://wow.xyz) - clanker -> [clanker.world](https://www.clanker.world)\n     *\n     * @returns {Promise<DeployFungibleResponse>} A promise that resolves to a `DeployFungibleResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const owner =\n     * const symbol =\n     * const name =\n     * const metadataMedia =\n     * const metadataDescription =\n     * const metadataNsfw =\n     * const metadataWebsiteLink =\n     * const metadataTwitter =\n     * const metadataDiscord =\n     * const metadataTelegram =\n     * const network =\n     * const factory =\n     *\n     * client.deployFungible({ owner, symbol, name, metadataMedia, metadataDescription, metadataNsfw, metadataWebsiteLink, metadataTwitter, metadataDiscord, metadataTelegram, network, factory }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/deploy-fungible)\n     *\n     */\n    async deployFungible(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onchainApi.deployFungible(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of relevant owners for a specific FID. This usually shows on a fungible asset page as \\\"X, Y, Z and N others you know own this asset\\\".\n     *\n     * @summary Relevant owners\n     *\n     * @param {object} params\n     * @param {string} params.contractAddress  - Contract address of the fungible asset\n     * @param {FungibleOwnerRelevantNetwork} params.network  - Network of the fungible asset.\n     * @param {number} params.viewerFid [optional]  - If you provide a viewer_fid, the response will include token holders from the user's network, respecting their mutes and blocks and including viewer_context; if not provided, the response will show top token holders across the network—both sets can be combined to generate a longer list if desired.\n     *\n     * @returns {Promise<RelevantFungibleOwnersResponse>} A promise that resolves to a `RelevantFungibleOwnersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const contractAddress =\n     * const network =\n     * const viewerFid =\n     *\n     * client.fetchRelevantFungibleOwners({ contractAddress, network, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-fungible-owners)\n     *\n     */\n    async fetchRelevantFungibleOwners(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onchainApi.fetchRelevantFungibleOwners(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches the token balances of a user given their FID\n     *\n     * @summary Token balance\n     *\n     * @param {object} params\n     * @param {number} params.fid  - FID of the user to fetch\n     * @param {Array<Network>} params.networks  - Comma separated list of networks to fetch balances for\n     *\n     * @returns {Promise<BalanceResponse>} A promise that resolves to a `BalanceResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const networks =\n     *\n     * client.fetchUserBalance({ fid, networks }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-balance)\n     *\n     */\n    async fetchUserBalance(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onchainApi.fetchUserBalance(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Register a new farcaster account onchain. Optionally you can pass in signers along to register a new account and create multiple signers in a single transaction\n     *\n     * @summary Register Farcaster account onchain\n     *\n     * @param {object} params\n     * @param {RegisterUserOnChainReqBodyRegistration} params.registration\n     * @param {number} params.storageUnits [optional]\n     * @param {Array<RegisterUserOnChainReqBodySignersInner>} params.signers [optional]\n     * @param {Array<RegisterUserOnChainReqBodyPreRegistrationCallsInner>} params.preRegistrationCalls [optional]\n     * @param {string} params.idem [optional]\n     *\n     * @returns {Promise<RegisterUserOnChainResponse>} A promise that resolves to a `RegisterUserOnChainResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const registration =\n     * const storageUnits =\n     * const signers =\n     * const preRegistrationCalls =\n     * const idem =\n     *\n     * client.registerAccountOnchain({registration, storageUnits, signers, preRegistrationCalls, idem}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account-onchain)\n     *\n     */\n    async registerAccountOnchain(params) {\n        const adjustedParams = {};\n        const _params = { registerUserOnChainReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.onchainApi.registerAccountOnchain(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Send fungibles in bulk to several farcaster users. A funded wallet is to required use this API. React out to us on the Neynar channel on farcaster to get your wallet address.\n     *\n     * @summary Send fungibles\n     *\n     * @param {object} params\n     * @param {string} params.xWalletId  - Wallet ID to use for transactions\n     * @param {TransactionSendFungiblesRequest} params.transactionSendFungiblesRequest\n     *\n     * @returns {Promise<TransactionSendFungiblesResponse>} A promise that resolves to a `TransactionSendFungiblesResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const xWalletId =\n     * const transactionSendFungiblesRequest =\n     *\n     * client.sendFungiblesToUsers({ xWalletId, transactionSendFungiblesRequest }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/send-fungibles-to-users)\n     *\n     */\n    async sendFungiblesToUsers(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onchainApi.sendFungiblesToUsers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Delete a reaction (like or recast) to a cast \\\\ (In order to delete a reaction `signer_uuid` must be approved)\n     *\n     * @summary Delete reaction\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {ReactionType} params.reactionType\n     * @param {string} params.target  - Target cast hash (hex string starting with 0x) OR a valid URL.\n     * @param {number} params.targetAuthorFid [optional]  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const reactionType =\n     * const target =\n     * const targetAuthorFid =\n     * const idem =\n     *\n     * client.deleteReaction({signerUuid, reactionType, target, targetAuthorFid, idem}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-reaction)\n     *\n     */\n    async deleteReaction(params) {\n        const adjustedParams = {};\n        const _params = { reactionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.reactionApi.deleteReaction(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches reactions for a given cast\n     *\n     * @summary Reactions for cast\n     *\n     * @param {object} params\n     * @param {string} params.hash\n     * @param {Array<ReactionsType>} params.types  - Customize which reaction types the request should search for. This is a comma-separated string that can include the following values: 'likes' and 'recasts'. By default api returns both. To select multiple types, use a comma-separated list of these values.\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of reactions that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ReactionsCastResponse>} A promise that resolves to a `ReactionsCastResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const hash =\n     * const types =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchCastReactions({ hash, types, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n     *\n     */\n    async fetchCastReactions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionApi.fetchCastReactions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches reactions for a given user\n     *\n     * @summary Reactions for user\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     * @param {ReactionsType} params.type  - Type of reaction to fetch (likes or recasts or all)\n     * @param {number} params.viewerFid [optional]  - Providing this will return a list of reactions that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<ReactionsResponse>} A promise that resolves to a `ReactionsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const type =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchUserReactions({ fid, type, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n     *\n     */\n    async fetchUserReactions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionApi.fetchUserReactions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Post a reaction (like or recast) to a given cast \\\\ (In order to post a reaction `signer_uuid` must be approved)\n     *\n     * @summary Post a reaction\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {ReactionType} params.reactionType\n     * @param {string} params.target  - Target cast hash (hex string starting with 0x) OR a valid URL.\n     * @param {number} params.targetAuthorFid [optional]  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const reactionType =\n     * const target =\n     * const targetAuthorFid =\n     * const idem =\n     *\n     * client.publishReaction({signerUuid, reactionType, target, targetAuthorFid, idem}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-reaction)\n     *\n     */\n    async publishReaction(params) {\n        const adjustedParams = {};\n        const _params = { reactionReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.reactionApi.publishReaction(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Creates a signer and returns the signer status. \\\\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.\n     *\n     * @summary Create signer\n     *\n     *\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.\n     *\n     * @example\n     *\n     * client.createSigner().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/create-signer)\n     *\n     */\n    async createSigner() {\n        const response = await this.apis.signerApi.createSigner();\n        return response.data;\n    }\n    /**\n     * Fetch authorization url (Fetched authorized url useful for SIWN login operation)\n     *\n     * @summary Fetch authorization url\n     *\n     * @param {object} params\n     * @param {string} params.clientId\n     * @param {AuthorizationUrlResponseType} params.responseType\n     *\n     * @returns {Promise<AuthorizationUrlResponse>} A promise that resolves to a `AuthorizationUrlResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const clientId =\n     * const responseType =\n     *\n     * client.fetchAuthorizationUrl({ clientId, responseType }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-authorization-url)\n     *\n     */\n    async fetchAuthorizationUrl(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.signerApi.fetchAuthorizationUrl(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches a list of signers for a custody address\n     *\n     * @summary List signers\n     *\n     * @param {object} params\n     * @param {string} params.message  - A Sign-In with Ethereum (SIWE) message that the user's Ethereum wallet signs. This message includes details such as the domain, address, statement, URI, nonce, and other relevant information following the EIP-4361 standard. It should be structured and URL-encoded.  example:  example.com wants you to sign in with your Ethereum account:n0x23A...F232nnSign in to continue.nnURI: example.comnVersion: 1nChain ID: 1nNonce: xyz123nIssued At: 2021-09-01T14:52:07Z  Note: This is just an example message (So, message is invalid, since we don't want any signers related to NEYNAR_API_DOCS to be exposed).   [Checkout fetch-signers API documentation for more details.](https://docs.neynar.com/docs/fetch-signers-1)\n     * @param {string} params.signature  - The digital signature produced by signing the provided SIWE message with the user's Ethereum private key. This signature is used to verify the authenticity of the message and the identity of the signer.\n     *\n     * @returns {Promise<SignerListResponse>} A promise that resolves to a `SignerListResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const message =\n     * const signature =\n     *\n     * client.fetchSigners({ message, signature }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-signers)\n     *\n     */\n    async fetchSigners(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.signerApi.fetchSigners(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches the status of a developer managed signer by public key\n     *\n     * @summary Status by public key\n     *\n     * @param {object} params\n     * @param {string} params.publicKey\n     *\n     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const publicKey =\n     *\n     * client.lookupDeveloperManagedSigner({ publicKey }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-developer-managed-signer)\n     *\n     */\n    async lookupDeveloperManagedSigner(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.signerApi.lookupDeveloperManagedSigner(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)\n     *\n     * @summary Status\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid\n     *\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     *\n     * client.lookupSigner({ signerUuid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-signer)\n     *\n     */\n    async lookupSigner(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.signerApi.lookupSigner(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.\n     *\n     * @summary Publish message\n     *\n     * @param {object} params\n     * @param {object} params.body\n     *\n     * @returns {Promise<object>} A promise that resolves to a `object` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const body =\n     *\n     * client.publishMessageToFarcaster({ body }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-message-to-farcaster)\n     *\n     */\n    async publishMessageToFarcaster(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.signerApi.publishMessageToFarcaster(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Registers an app FID, deadline and a signature. Returns the signer status with an approval url.\n     *\n     * @summary Register Signed Key\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.signature  - Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key\n     * @param {number} params.appFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {number} params.deadline  - unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended)\n     * @param {string} params.redirectUrl [optional]  - Url to redirect to after the signer is approved.  **Note** : This should only be used when requesting a signer from a native mobile application.\n     * @param {SignedKeyRequestSponsor} params.sponsor [optional]\n     *\n     * @returns {Promise<Signer>} A promise that resolves to a `Signer` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const signature =\n     * const appFid =\n     * const deadline =\n     * const redirectUrl =\n     * const sponsor =\n     *\n     * client.registerSignedKey({signerUuid, signature, appFid, deadline, redirectUrl, sponsor}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key)\n     *\n     */\n    async registerSignedKey(params) {\n        const adjustedParams = {};\n        const _params = { registerSignerKeyReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.signerApi.registerSignedKey(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Registers an signed key and returns the developer managed signer status with an approval url.\n     *\n     * @summary Register Signed Key\n     *\n     * @param {object} params\n     * @param {string} params.publicKey  - Ed25519 public key\n     * @param {string} params.signature  - Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key\n     * @param {number} params.appFid  - The unique identifier of a farcaster user or app (unsigned integer)\n     * @param {number} params.deadline  - unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended)\n     * @param {string} params.redirectUrl [optional]  - Url to redirect to after the signer is approved.  **Note** : This should only be used when requesting a signer from a native mobile application.\n     * @param {SignedKeyRequestSponsor} params.sponsor [optional]\n     *\n     * @returns {Promise<DeveloperManagedSigner>} A promise that resolves to a `DeveloperManagedSigner` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const publicKey =\n     * const signature =\n     * const appFid =\n     * const deadline =\n     * const redirectUrl =\n     * const sponsor =\n     *\n     * client.registerSignedKeyForDeveloperManagedSigner({publicKey, signature, appFid, deadline, redirectUrl, sponsor}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-signed-key-for-developer-managed-signer)\n     *\n     */\n    async registerSignedKeyForDeveloperManagedSigner(params) {\n        const adjustedParams = {};\n        const _params = { registerDeveloperManagedSignedKeyReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.signerApi.registerSignedKeyForDeveloperManagedSigner(adjustedParams);\n        return response.data;\n    }\n    /**\n     * This api will help you rent units of storage for an year for a specific FID. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n     *\n     * @summary Buy storage\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     * @param {number} params.units [optional]  - Number of storage units to buy. A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.\n     * @param {string} params.idem [optional]  - An Idempotency key is a unique identifier for the request. **Note:**  1) This is used to prevent duplicate requests. Use the same idem key on retry attempts. 2) This should be a unique identifier for each request. 3) Recommended format is a 16-character string generated by the developer at the time of making this request.\n     *\n     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const units =\n     * const idem =\n     *\n     * client.buyStorage({fid, units, idem}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/buy-storage)\n     *\n     */\n    async buyStorage(params) {\n        const adjustedParams = {};\n        const _params = { buyStorageReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.storageApi.buyStorage(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches storage allocations for a given user\n     *\n     * @summary Allocation of user\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     *\n     * @returns {Promise<StorageAllocationsResponse>} A promise that resolves to a `StorageAllocationsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     *\n     * client.lookupUserStorageAllocations({ fid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-allocations)\n     *\n     */\n    async lookupUserStorageAllocations(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.storageApi.lookupUserStorageAllocations(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches storage usage for a given user\n     *\n     * @summary Usage of user\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     *\n     * @returns {Promise<StorageUsageResponse>} A promise that resolves to a `StorageUsageResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     *\n     * client.lookupUserStorageUsage({ fid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-usage)\n     *\n     */\n    async lookupUserStorageUsage(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.storageApi.lookupUserStorageUsage(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch what FIDs and contracts a FID is subscribed to.\n     *\n     * @summary Subscribed to\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     * @param {SubscriptionProvider} params.subscriptionProvider\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<SubscribedToResponse>} A promise that resolves to a `SubscribedToResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const subscriptionProvider =\n     * const viewerFid =\n     *\n     * client.fetchSubscribedToForFid({ fid, subscriptionProvider, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribed-to-for-fid)\n     *\n     */\n    async fetchSubscribedToForFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.subscribersApi.fetchSubscribedToForFid(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch subscribers for a given FID\\'s contracts. Doesn\\'t return addresses that don\\'t have an FID.\n     *\n     * @summary Subscribers of a user\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     * @param {SubscriptionProviders} params.subscriptionProvider\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<SubscribersResponse>} A promise that resolves to a `SubscribersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const subscriptionProvider =\n     * const viewerFid =\n     *\n     * client.fetchSubscribersForFid({ fid, subscriptionProvider, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscribers-for-fid)\n     *\n     */\n    async fetchSubscribersForFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.subscribersApi.fetchSubscribersForFid(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Check if a wallet address is subscribed to a given STP (Hypersub) contract.\n     *\n     * @summary Hypersub subscription check\n     *\n     * @param {object} params\n     * @param {string[]} params.addresses  - Comma separated list of Ethereum addresses, up to 350 at a time\n     * @param {string} params.contractAddress  - Ethereum address of the STP contract\n     * @param {string} params.chainId  - Chain ID of the STP contract\n     *\n     * @returns {Promise<SubscriptionCheckResponse>} A promise that resolves to a `SubscriptionCheckResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const addresses =\n     * const contractAddress =\n     * const chainId =\n     *\n     * client.fetchSubscriptionCheck({ addresses, contractAddress, chainId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscription-check)\n     *\n     */\n    async fetchSubscriptionCheck(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        if (adjustedParams.addresses && Array.isArray(adjustedParams.addresses)) {\n            adjustedParams.addresses = adjustedParams.addresses.join(\",\");\n        }\n        const response = await this.apis.subscribersApi.fetchSubscriptionCheck(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch created subscriptions for a given FID\\'s.\n     *\n     * @summary Subscriptions created by FID\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     * @param {SubscriptionProvider} params.subscriptionProvider\n     *\n     * @returns {Promise<SubscriptionsResponse>} A promise that resolves to a `SubscriptionsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const subscriptionProvider =\n     *\n     * client.fetchSubscriptionsForFid({ fid, subscriptionProvider }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-subscriptions-for-fid)\n     *\n     */\n    async fetchSubscriptionsForFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.subscribersApi.fetchSubscriptionsForFid(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Removes verification for an eth address for the user \\\\ (In order to delete verification `signer_uuid` must be approved)\n     *\n     * @summary Delete verification\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.address  - Ethereum address\n     * @param {string} params.blockHash\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const address =\n     * const blockHash =\n     *\n     * client.deleteVerification({signerUuid, address, blockHash}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-verification)\n     *\n     */\n    async deleteVerification(params) {\n        const adjustedParams = {};\n        const _params = { removeVerificationReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.deleteVerification(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches information about multiple users based on FIDs\n     *\n     * @summary By FIDs\n     *\n     * @param {object} params\n     * @param {number[]} params.fids  - Comma separated list of FIDs, up to 100 at a time\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fids =\n     * const viewerFid =\n     *\n     * client.fetchBulkUsers({ fids, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users)\n     *\n     */\n    async fetchBulkUsers(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.map(value => (String(value)));\n        }\n        if (adjustedParams.fids && Array.isArray(adjustedParams.fids)) {\n            adjustedParams.fids = adjustedParams.fids.join(\",\");\n        }\n        const response = await this.apis.userApi.fetchBulkUsers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.\n     *\n     * @summary By Eth or Sol addresses\n     *\n     * @param {object} params\n     * @param {string[]} params.addresses  - Comma separated list of Ethereum addresses, up to 350 at a time\n     * @param {Array<BulkUserAddressType>} params.addressTypes [optional]  - Customize which address types the request should search for. This is a comma-separated string that can include the following values: 'custody_address' and 'verified_address'. By default api returns both. To select multiple types, use a comma-separated list of these values.\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<BulkUsersByAddressResponse>} A promise that resolves to a `BulkUsersByAddressResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const addresses =\n     * const addressTypes =\n     * const viewerFid =\n     *\n     * client.fetchBulkUsersByEthOrSolAddress({ addresses, addressTypes, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-bulk-users-by-eth-or-sol-address)\n     *\n     */\n    async fetchBulkUsersByEthOrSolAddress(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        if (adjustedParams.addresses && Array.isArray(adjustedParams.addresses)) {\n            adjustedParams.addresses = adjustedParams.addresses.join(\",\");\n        }\n        const response = await this.apis.userApi.fetchBulkUsersByEthOrSolAddress(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches power users based on Warpcast power badges. Information is updated once a day.\n     *\n     * @summary Power users\n     *\n     * @param {object} params\n     * @param {number} params.viewerFid [optional]\n     * @param {number} params.limit [optional]  - Number of power users to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchPowerUsers({ viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users)\n     *\n     */\n    async fetchPowerUsers(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.fetchPowerUsers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches power users and respond in a backwards compatible format to Warpcast\\'s deprecated power badge endpoint.\n     *\n     * @summary Power user FIDs\n     *\n     * @param {object} params\n     *\n     * @returns {Promise<UserPowerLiteResponse>} A promise that resolves to a `UserPowerLiteResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     *\n     * client.fetchPowerUsersLite().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-power-users-lite)\n     *\n     */\n    async fetchPowerUsersLite() {\n        var _a, _b;\n        const adjustedParams = {};\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.fetchPowerUsersLite(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches a list of users given a location\n     *\n     * @summary By location\n     *\n     * @param {object} params\n     * @param {number} params.latitude  - Latitude of the location\n     * @param {number} params.longitude  - Longitude of the location\n     * @param {number} params.viewerFid [optional]  - FID of the user viewing the feed. Providing this will return a list of users that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {number} params.limit [optional]  - Number of results to fetch (Default: 25, Maximum: 100)\n     * @param {string} params.cursor [optional]  - Pagination cursor\n     *\n     * @returns {Promise<UsersResponse>} A promise that resolves to a `UsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const latitude =\n     * const longitude =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.fetchUsersByLocation({ latitude, longitude, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-by-location)\n     *\n     */\n    async fetchUsersByLocation(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.fetchUsersByLocation(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Follow a user \\\\ (In order to follow a user `signer_uuid` must be approved)\n     *\n     * @summary Follow user\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {Array<number>} params.targetFids\n     *\n     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const targetFids =\n     *\n     * client.followUser({signerUuid, targetFids}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/follow-user)\n     *\n     */\n    async followUser(params) {\n        const adjustedParams = {};\n        const _params = { followReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.followUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-account)\n     *\n     * @summary Fetch fresh FID\n     *\n     * @param {object} params\n     *\n     * @returns {Promise<UserFIDResponse>} A promise that resolves to a `UserFIDResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     *\n     * client.getFreshAccountFID().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-fresh-account-fid)\n     *\n     */\n    async getFreshAccountFID() {\n        var _a, _b;\n        const adjustedParams = {};\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.getFreshAccountFID(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Lookup a user by custody-address\n     *\n     * @summary By custody-address\n     *\n     * @param {object} params\n     * @param {string} params.custodyAddress  - Custody Address associated with mnemonic\n     *\n     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const custodyAddress =\n     *\n     * client.lookupUserByCustodyAddress({ custodyAddress }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-custody-address)\n     *\n     */\n    async lookupUserByCustodyAddress(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.userApi.lookupUserByCustodyAddress(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches a single hydrated user object given a username\n     *\n     * @summary By username\n     *\n     * @param {object} params\n     * @param {string} params.username  - Username of the user to fetch\n     * @param {number} params.viewerFid [optional]\n     *\n     * @returns {Promise<UserResponse>} A promise that resolves to a `UserResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const username =\n     * const viewerFid =\n     *\n     * client.lookupUserByUsername({ username, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-by-username)\n     *\n     */\n    async lookupUserByUsername(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.lookupUserByUsername(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetches the users who have verified the specified X (Twitter) username\n     *\n     * @summary By X username\n     *\n     * @param {object} params\n     * @param {string} params.xUsername  - X (Twitter) username to search for, without the @ symbol\n     * @param {number} params.viewerFid [optional]  - FID of the viewer for contextual information like follows and blocks\n     *\n     * @returns {Promise<BulkUsersResponse>} A promise that resolves to a `BulkUsersResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const xUsername =\n     * const viewerFid =\n     *\n     * client.lookupUsersByXUsername({ xUsername, viewerFid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-users-by-x-username)\n     *\n     */\n    async lookupUsersByXUsername(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.lookupUsersByXUsername(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Adds verification for an eth address or contract for the user \\\\ (In order to add verification `signer_uuid` must be approved)\n     *\n     * @summary Add verification\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.address  - Ethereum address\n     * @param {string} params.blockHash\n     * @param {string} params.ethSignature\n     * @param {VerificationType} params.verificationType [optional]\n     * @param {VerificationChainId} params.chainId [optional]\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const address =\n     * const blockHash =\n     * const ethSignature =\n     * const verificationType =\n     * const chainId =\n     *\n     * client.publishVerification({signerUuid, address, blockHash, ethSignature, verificationType, chainId}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-verification)\n     *\n     */\n    async publishVerification(params) {\n        const adjustedParams = {};\n        const _params = { addVerificationReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.publishVerification(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user.\n     *\n     * @summary Register new account\n     *\n     * @param {object} params\n     * @param {string} params.signature\n     * @param {number} params.fid\n     * @param {string} params.requestedUserCustodyAddress\n     * @param {number} params.deadline\n     * @param {string} params.fname [optional]\n     * @param {RegisterUserReqBodyMetadata} params.metadata [optional]\n     *\n     * @returns {Promise<RegisterUserResponse>} A promise that resolves to a `RegisterUserResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signature =\n     * const fid =\n     * const requestedUserCustodyAddress =\n     * const deadline =\n     * const fname =\n     * const metadata =\n     *\n     * client.registerAccount({signature, fid, requestedUserCustodyAddress, deadline, fname, metadata}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/register-account)\n     *\n     */\n    async registerAccount(params) {\n        const adjustedParams = {};\n        const _params = { registerUserReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.registerAccount(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Search for Usernames\n     *\n     * @summary Search for Usernames\n     *\n     * @param {object} params\n     * @param {string} params.q\n     * @param {number} params.viewerFid [optional]  - Providing this will return search results that respects this user's mutes and blocks and includes `viewer_context`.\n     * @param {number} params.limit [optional]  - Number of users to fetch (Default: 5, Maximum: 10)\n     * @param {string} params.cursor [optional]  - Pagination cursor.\n     *\n     * @returns {Promise<UserSearchResponse>} A promise that resolves to a `UserSearchResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const q =\n     * const viewerFid =\n     * const limit =\n     *\n     * client.searchUser({ q, viewerFid, limit }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-user)\n     *\n     */\n    async searchUser(params) {\n        var _a, _b;\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        adjustedParams['xNeynarExperimental'] = (_b = (_a = this.config.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b['x-neynar-experimental'];\n        const response = await this.apis.userApi.searchUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Unfollow a user \\\\ (In order to unfollow a user `signer_uuid` must be approved)\n     *\n     * @summary Unfollow user\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {Array<number>} params.targetFids\n     *\n     * @returns {Promise<BulkFollowResponse>} A promise that resolves to a `BulkFollowResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const targetFids =\n     *\n     * client.unfollowUser({signerUuid, targetFids}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/unfollow-user)\n     *\n     */\n    async unfollowUser(params) {\n        const adjustedParams = {};\n        const _params = { followReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.unfollowUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Update user profile \\\\ (In order to update user\\'s profile `signer_uuid` must be approved)\n     *\n     * @summary Update user profile\n     *\n     * @param {object} params\n     * @param {string} params.signerUuid  - UUID of the signer. `signer_uuid` is paired with API key, can't use a `uuid` made with a different API key.\n     * @param {string} params.bio [optional]\n     * @param {string} params.pfpUrl [optional]\n     * @param {string} params.url [optional]\n     * @param {string} params.username [optional]\n     * @param {string} params.displayName [optional]\n     * @param {UpdateUserReqBodyLocation} params.location [optional]\n     * @param {UpdateUserReqBodyVerifiedAccounts} params.verifiedAccounts [optional]\n     *\n     * @returns {Promise<OperationResponse>} A promise that resolves to a `OperationResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const signerUuid =\n     * const bio =\n     * const pfpUrl =\n     * const url =\n     * const username =\n     * const displayName =\n     * const location =\n     * const verifiedAccounts =\n     *\n     * client.updateUser({signerUuid, bio, pfpUrl, url, username, displayName, location, verifiedAccounts}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-user)\n     *\n     */\n    async updateUser(params) {\n        const adjustedParams = {};\n        const _params = { updateUserReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.userApi.updateUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Delete a webhook\n     *\n     * @summary Delete a webhook\n     *\n     * @param {object} params\n     * @param {string} params.webhookId\n     *\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const webhookId =\n     *\n     * client.deleteWebhook({webhookId}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-webhook)\n     *\n     */\n    async deleteWebhook(params) {\n        const adjustedParams = {};\n        const _params = { webhookDeleteReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.webhookApi.deleteWebhook(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of webhooks associated to a user\n     *\n     * @summary Associated webhooks of user\n     *\n     *\n     * @returns {Promise<WebhookListResponse>} A promise that resolves to a `WebhookListResponse` object.\n     *\n     * @example\n     *\n     * client.fetchWebhooks().then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-webhooks)\n     *\n     */\n    async fetchWebhooks() {\n        const response = await this.apis.webhookApi.fetchWebhooks();\n        return response.data;\n    }\n    /**\n     * Fetch a webhook\n     *\n     * @summary Fetch a webhook\n     *\n     * @param {object} params\n     * @param {string} params.webhookId\n     *\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const webhookId =\n     *\n     * client.lookupWebhook({ webhookId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-webhook)\n     *\n     */\n    async lookupWebhook(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.webhookApi.lookupWebhook(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Create a webhook\n     *\n     * @summary Create a webhook\n     *\n     * @param {object} params\n     * @param {string} params.name\n     * @param {string} params.url\n     * @param {WebhookSubscriptionFilters} params.subscription [optional]\n     *\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const name =\n     * const url =\n     * const subscription =\n     *\n     * client.publishWebhook({name, url, subscription}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-webhook)\n     *\n     */\n    async publishWebhook(params) {\n        const adjustedParams = {};\n        const _params = { webhookPostReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.webhookApi.publishWebhook(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Update a webhook\n     *\n     * @summary Update a webhook\n     *\n     * @param {object} params\n     * @param {string} params.name\n     * @param {string} params.url\n     * @param {WebhookSubscriptionFilters} params.subscription [optional]\n     * @param {string} params.webhookId\n     *\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const name =\n     * const url =\n     * const subscription =\n     * const webhookId =\n     *\n     * client.updateWebhook({name, url, subscription, webhookId}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook)\n     *\n     */\n    async updateWebhook(params) {\n        const adjustedParams = {};\n        const _params = { webhookPutReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.webhookApi.updateWebhook(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Update webhook active status\n     *\n     * @summary Update webhook status\n     *\n     * @param {object} params\n     * @param {string} params.webhookId\n     * @param {WebhookPatchReqBodyActiveEnum} params.active\n     *\n     * @returns {Promise<WebhookResponse>} A promise that resolves to a `WebhookResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const webhookId =\n     * const active =\n     *\n     * client.updateWebhookActiveStatus({webhookId, active}).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-webhook-active-status)\n     *\n     */\n    async updateWebhookActiveStatus(params) {\n        const adjustedParams = {};\n        const _params = { webhookPatchReqBody: camelCaseToSnakeCaseKeys(params) };\n        Object.assign(adjustedParams, _params);\n        const response = await this.apis.webhookApi.updateWebhookActiveStatus(adjustedParams);\n        return response.data;\n    }\n    /**\n       * Creates a signer and registers a signed key for the signer.\n       * It returns a Signer which includes `signer_approval_url` that can be used to create a QR Code for the user to scan and approve the signer.\n       *\n       * @param {Object} [options] - Optional parameters for the request.\n       * @param {string} [options.farcasterDeveloperMnemonic] - mnemonic of the farcaster developer account\n       * @param {number} [options.deadline] - (Optional) Unix timestamp in seconds that controls how long the signed key\n       *   request is valid for. A 24-hour duration from now is recommended.\n       *\n       * @returns {Promise<Signer>} A promise that resolves to a `Signer` object,\n       *   that includes signer_approval_url.\n       *\n       * @example\n       *\n       * // Fill in the appropriate values\n       *\n       * const farcasterDeveloperMnemonic =\n       * const deadline =\n       *\n       * client.createSignerAndRegisterSignedKey({ farcasterDeveloperMnemonic, deadline: 1693927665 }).then(response => {\n       *   console.log('Signer', response);\n       * });\n       */\n    async createSignerAndRegisterSignedKey(params) {\n        const { farcasterDeveloperMnemonic, deadline } = params;\n        try {\n            const { public_key: signerPublicKey, signer_uuid } = await this.createSigner();\n            const account = (0, accounts_1.mnemonicToAccount)(farcasterDeveloperMnemonic);\n            const { user: farcasterDeveloper } = await this.lookupUserByCustodyAddress({\n                custodyAddress: account.address,\n            });\n            // Generates an expiration date for the signature\n            // e.g. 1693927665\n            const signed_key_deadline = deadline !== null && deadline !== void 0 ? deadline : Math.floor(Date.now() / 1000) + 86400; // signature is valid for 1 day from now\n            let signature = await account.signTypedData({\n                domain: constants_1.SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN,\n                types: {\n                    SignedKeyRequest: constants_1.SIGNED_KEY_REQUEST_TYPE,\n                },\n                primaryType: \"SignedKeyRequest\",\n                message: {\n                    requestFid: BigInt(farcasterDeveloper.fid),\n                    key: signerPublicKey,\n                    deadline: BigInt(signed_key_deadline),\n                },\n            });\n            let signer_pending = await this.registerSignedKey({\n                signerUuid: signer_uuid,\n                appFid: farcasterDeveloper.fid,\n                deadline: signed_key_deadline,\n                signature,\n            });\n            return signer_pending;\n        }\n        catch (err) {\n            if ((0, utils_1.isApiErrorResponse)(err)) {\n                console.log(err.response.data);\n            }\n            else\n                console.log(err);\n        }\n    }\n}\nexports.NeynarAPIClient = NeynarAPIClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NsaWVudHMvTmV5bmFyQVBJQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsbUJBQW1CLG1CQUFPLENBQUMsdUVBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLDZEQUFPO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLGdHQUFzQjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVU7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsb0dBQXdCO0FBQ3JELHFCQUFxQixtQkFBTyxDQUFDLG9HQUF3QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXFCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLGtHQUF1QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsc0dBQXlCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLGdHQUFzQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsc0dBQXlCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLGtHQUF1QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsc0dBQXlC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QUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtEQUFrRDtBQUNyRztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBLG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxSUFBcUk7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NsaWVudHMvTmV5bmFyQVBJQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5leW5hckFQSUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGFjY291bnRzXzEgPSByZXF1aXJlKFwidmllbS9hY2NvdW50c1wiKTtcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9sb2dnZXJcIik7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJheGlvc1wiKSk7XG5jb25zdCBjb25maWd1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vYXBpL2NvbmZpZ3VyYXRpb25cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGFjdGlvbl9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9hY3Rpb24tYXBpXCIpO1xuY29uc3QgYWdlbnRzX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL2FnZW50cy1hcGlcIik7XG5jb25zdCBhcHBfaG9zdF9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9hcHAtaG9zdC1hcGlcIik7XG5jb25zdCBiYW5fYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvYmFuLWFwaVwiKTtcbmNvbnN0IGJsb2NrX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL2Jsb2NrLWFwaVwiKTtcbmNvbnN0IGNhc3RfYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvY2FzdC1hcGlcIik7XG5jb25zdCBjaGFubmVsX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL2NoYW5uZWwtYXBpXCIpO1xuY29uc3QgZmVlZF9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9mZWVkLWFwaVwiKTtcbmNvbnN0IGZuYW1lX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL2ZuYW1lLWFwaVwiKTtcbmNvbnN0IGZvbGxvd3NfYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvZm9sbG93cy1hcGlcIik7XG5jb25zdCBmcmFtZV9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9mcmFtZS1hcGlcIik7XG5jb25zdCBsb2dpbl9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9sb2dpbi1hcGlcIik7XG5jb25zdCBtZXRyaWNzX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL21ldHJpY3MtYXBpXCIpO1xuY29uc3QgbXV0ZV9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy9tdXRlLWFwaVwiKTtcbmNvbnN0IG5vdGlmaWNhdGlvbnNfYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvbm90aWZpY2F0aW9ucy1hcGlcIik7XG5jb25zdCBvbmNoYWluX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL29uY2hhaW4tYXBpXCIpO1xuY29uc3QgcmVhY3Rpb25fYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvcmVhY3Rpb24tYXBpXCIpO1xuY29uc3Qgc2lnbmVyX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL3NpZ25lci1hcGlcIik7XG5jb25zdCBzdG9yYWdlX2FwaV8xID0gcmVxdWlyZShcIi4uL2FwaS9hcGlzL3N0b3JhZ2UtYXBpXCIpO1xuY29uc3Qgc3Vic2NyaWJlcnNfYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvc3Vic2NyaWJlcnMtYXBpXCIpO1xuY29uc3QgdXNlcl9hcGlfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXBpcy91c2VyLWFwaVwiKTtcbmNvbnN0IHdlYmhvb2tfYXBpXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaXMvd2ViaG9vay1hcGlcIik7XG5jb25zdCB7IHZlcnNpb246IHNka1ZlcnNpb24gfSA9IHJlcXVpcmUoXCIuLi8uLi9wYWNrYWdlLmpzb25cIik7XG4vKipcbiAqIENvbnZlcnRzIGEgY2FtZWxDYXNlIHN0cmluZyB0byBzbmFrZV9jYXNlLlxuICogSWYgdGhlIGlucHV0IHN0cmluZyBpcyBub3QgaW4gY2FtZWxDYXNlIGZvcm1hdCwgaXQgcmV0dXJucyB0aGUgb3JpZ2luYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udmVydGVkIHN0cmluZyBpbiBzbmFrZV9jYXNlLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nIGlmIG5vdCBjYW1lbENhc2UuXG4gKi9cbmZ1bmN0aW9uIGNhbWVsVG9TbmFrZUNhc2Uoc3RyKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHN0cmluZyBpcyBjYW1lbENhc2VcbiAgICBpZiAoL15bYS16XSsoW0EtWl1bYS16XSopKyQvLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7IC8vIFJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nIGlmIGl0J3Mgbm90IGNhbWVsQ2FzZVxufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdG9wLWxldmVsIGtleXMgb2YgYW4gb2JqZWN0IGZyb20gY2FtZWxDYXNlIHRvIHNuYWtlX2Nhc2UuXG4gKiBJZiBhIGtleSBpcyBub3QgaW4gY2FtZWxDYXNlLCBpdCByZXRhaW5zIGl0cyBvcmlnaW5hbCBmb3JtYXQuXG4gKiBOZXN0ZWQgb2JqZWN0cyBvciBhcnJheXMgYXJlIGxlZnQgdW5jaGFuZ2VkLlxuICogVGhpcyBpcyBkb25lIHRvIHJldmVydCB0aGUgY29udmVyc2lvbiBvZiB0b3AtbGV2ZWwga2V5cyBzaW5jZSB3ZSBhY2NlcHQgc25ha2VfY2FzZSBrZXlzIGluIHRoZSBBUEkgYnV0IGNvbnZlcnQgdGhlbSB0byBjYW1lbENhc2UgaW4gdGhlIHdyYXBwZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3Qgd2hvc2UgdG9wLWxldmVsIGtleXMgYXJlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHRvcC1sZXZlbCBrZXlzIGNvbnZlcnRlZCB0byBzbmFrZV9jYXNlLlxuICovXG5mdW5jdGlvbiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMob2JqKSB7XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIC8vIENvbnZlcnQgb25seSB0aGUgdG9wLWxldmVsIGtleXNcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBjYW1lbFRvU25ha2VDYXNlKGtleSksIC8vIENvbnZlcnQgb25seSBjYW1lbENhc2Uga2V5c1xuICAgICAgICAgICAgdmFsdWUsIC8vIExlYXZlIHRoZSB2YWx1ZSB1bnRvdWNoZWRcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqOyAvLyBJZiBub3QgYW4gb2JqZWN0LCByZXR1cm4gYXMgaXNcbn1cbmNsYXNzIE5leW5hckFQSUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogY29uZmlnIG11c3QgYmUgb2YgdHlwZSBDb25maWd1cmF0aW9uJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXG5TZWVtcywgbGlrZSB5b3UgYXJlIHVzaW5nIHNkayB2MiBidXQgdGhlIHN5bnRheCBvbiBjbGllbnQgaW5zdGFudGlhdGlvbiBpcyBmb3Igc2RrIHYxLlxuU0RLIHYxIC0+IHYyIG1pZ3JhdGlvbiBndWlkZTogaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL25leW5hci1ub2RlanMtc2RrLXYxLXRvLXYyLW1pZ3JhdGlvbi1ndWlkZVxuXG5Db3JyZWN0IHVzYWdlIHdheSB0byBpbnN0YW50aWF0ZSB0aGUgY2xpZW50OlxuXG5pbXBvcnQgeyBOZXluYXJBUElDbGllbnQsIENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiQG5leW5hci9ub2RlanMtc2RrXCI7XG5cbmNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHtcbiAgYXBpS2V5OiBcIkFQSV9LRVlcIixcbiAgYmFzZU9wdGlvbnM6IHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIngtbmV5bmFyLWV4cGVyaW1lbnRhbFwiOiB0cnVlLFxuICAgIH0sXG4gIH0sXG59KTtcblxuY29uc3QgY2xpZW50ID0gbmV3IE5leW5hckFQSUNsaWVudChjb25maWcpO1xcbmApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbmZpZ3VyYXRpb24gdHlwZS4gRXhwZWN0ZWQgQ29uZmlndXJhdGlvbiBvYmplY3QgYnV0IHJlY2VpdmVkIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvZ2dlciA9IGxvZ2dlcl8xLnNpbGVudExvZ2dlciwgYXhpb3NJbnN0YW5jZTogY3VzdG9tQXhpb3NJbnN0YW5jZSB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gbmV3IGNvbmZpZ3VyYXRpb25fMS5Db25maWd1cmF0aW9uKHtcbiAgICAgICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGJhc2VQYXRoOiBjb25maWcuYmFzZVBhdGgsXG4gICAgICAgICAgICBiYXNlT3B0aW9uczogY29uZmlnLmJhc2VPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXhpb3NJbnN0YW5jZSA9IGN1c3RvbUF4aW9zSW5zdGFuY2UgfHwgYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJ4LXNkay12ZXJzaW9uXCI6IHNka1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgXCJ4LXNka1wiOiBcIm5vZGVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF4aW9zSW5zdGFuY2UuZGVmYXVsdHMuZGVjb21wcmVzcyA9IHRydWU7XG4gICAgICAgIGF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZSgocmVzcG9uc2UpID0+IHJlc3BvbnNlLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZSAmJiBbMzAyXS5pbmNsdWRlcyhlcnJvci5yZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGVycm9yLnJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOZXluYXJBUElDbGllbnQuaXNBcGlFcnJvclJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaUVycm9ycyA9IGVycm9yLnJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgQVBJIGVycm9yczogJHtKU09OLnN0cmluZ2lmeShhcGlFcnJvcnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwaXMgPSB7XG4gICAgICAgICAgICBhY3Rpb25BcGk6IG5ldyBhY3Rpb25fYXBpXzEuQWN0aW9uQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgYWdlbnRzQXBpOiBuZXcgYWdlbnRzX2FwaV8xLkFnZW50c0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGFwcEhvc3RBcGk6IG5ldyBhcHBfaG9zdF9hcGlfMS5BcHBIb3N0QXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgYmFuQXBpOiBuZXcgYmFuX2FwaV8xLkJhbkFwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGJsb2NrQXBpOiBuZXcgYmxvY2tfYXBpXzEuQmxvY2tBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBjYXN0QXBpOiBuZXcgY2FzdF9hcGlfMS5DYXN0QXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgY2hhbm5lbEFwaTogbmV3IGNoYW5uZWxfYXBpXzEuQ2hhbm5lbEFwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGZlZWRBcGk6IG5ldyBmZWVkX2FwaV8xLkZlZWRBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBmbmFtZUFwaTogbmV3IGZuYW1lX2FwaV8xLkZuYW1lQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgZm9sbG93c0FwaTogbmV3IGZvbGxvd3NfYXBpXzEuRm9sbG93c0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGZyYW1lQXBpOiBuZXcgZnJhbWVfYXBpXzEuRnJhbWVBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBsb2dpbkFwaTogbmV3IGxvZ2luX2FwaV8xLkxvZ2luQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgbWV0cmljc0FwaTogbmV3IG1ldHJpY3NfYXBpXzEuTWV0cmljc0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIG11dGVBcGk6IG5ldyBtdXRlX2FwaV8xLk11dGVBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBub3RpZmljYXRpb25zQXBpOiBuZXcgbm90aWZpY2F0aW9uc19hcGlfMS5Ob3RpZmljYXRpb25zQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgb25jaGFpbkFwaTogbmV3IG9uY2hhaW5fYXBpXzEuT25jaGFpbkFwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIHJlYWN0aW9uQXBpOiBuZXcgcmVhY3Rpb25fYXBpXzEuUmVhY3Rpb25BcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBzaWduZXJBcGk6IG5ldyBzaWduZXJfYXBpXzEuU2lnbmVyQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgc3RvcmFnZUFwaTogbmV3IHN0b3JhZ2VfYXBpXzEuU3RvcmFnZUFwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIHN1YnNjcmliZXJzQXBpOiBuZXcgc3Vic2NyaWJlcnNfYXBpXzEuU3Vic2NyaWJlcnNBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICB1c2VyQXBpOiBuZXcgdXNlcl9hcGlfMS5Vc2VyQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgd2ViaG9va0FwaTogbmV3IHdlYmhvb2tfYXBpXzEuV2ViaG9va0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGlzQXBpRXJyb3JSZXNwb25zZShlcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgYXhpb3NfMS5BeGlvc0Vycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgoKF9hID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gdW5kZWZpbmVkICYmIFwibWVzc2FnZVwiIGluIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWN1cmVseSBjb21tdW5pY2F0ZSBhbmQgcGVyZm9ybSBhY3Rpb25zIG9uIGJlaGFsZiBvZiB1c2VycyBhY3Jvc3MgZGlmZmVyZW50IGFwcHMuIEl0IGVuYWJsZXMgYW4gYXBwIHRvIHNlbmQgZGF0YSBvciB0cmlnZ2VyIGFjdGlvbnMgaW4gYW5vdGhlciBhcHAgb24gYmVoYWxmIG9mIGEgbXV0dWFsIHVzZXIgYnkgc2lnbmluZyBtZXNzYWdlcyB1c2luZyB0aGUgdXNlclxcJ3MgRmFyY2FzdGVyIHNpZ25lci5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFVzZXIgYWN0aW9ucyBhY3Jvc3MgYXBwc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBUaGUgc2lnbmVyX3V1aWQgb2YgdGhlIHVzZXIgb24gYmVoYWxmIG9mIHdob20gdGhlIGFjdGlvbiBpcyBiZWluZyBwZXJmb3JtZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5iYXNlVXJsICAtIFRoZSBiYXNlIFVSTCBvZiB0aGUgYXBwIG9uIHdoaWNoIHRoZSBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7RmFyY2FzdGVyQWN0aW9uUmVxQm9keUFjdGlvbn0gcGFyYW1zLmFjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8eyBba2V5OiBzdHJpbmddOiBhbnk7IH0+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB7IFtrZXk6IHN0cmluZ106IGFueTsgfWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IGJhc2VVcmwgPVxuICAgICAqIGNvbnN0IGFjdGlvbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucHVibGlzaEZhcmNhc3RlckFjdGlvbih7c2lnbmVyVXVpZCwgYmFzZVVybCwgYWN0aW9ufSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmFyY2FzdGVyLWFjdGlvbnMtc3BlYylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHB1Ymxpc2hGYXJjYXN0ZXJBY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IGZhcmNhc3RlckFjdGlvblJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5hY3Rpb25BcGkucHVibGlzaEZhcmNhc3RlckFjdGlvbihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRyYW5zYWN0aW9uIHBheSBtaW5pIGFwcCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbGxlY3QgcGF5bWVudHMgdGhyb3VnaCBhIG1pbmkgYXBwXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtGcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHl9IHBhcmFtcy5mcmFtZVBheVRyYW5zYWN0aW9uUmVxdWVzdEJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZyYW1lUGF5VHJhbnNhY3Rpb25SZXF1ZXN0Qm9keSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuY3JlYXRlVHJhbnNhY3Rpb25QYXlGcmFtZSh7IGZyYW1lUGF5VHJhbnNhY3Rpb25SZXF1ZXN0Qm9keSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhbnNhY3Rpb25QYXlGcmFtZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYWdlbnRzQXBpLmNyZWF0ZVRyYW5zYWN0aW9uUGF5RnJhbWUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgaW50ZXJhY3Rpb25zIGJldHdlZW4gdHdvIHVzZXJzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVc2VyIGludGVyYWN0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBhcmFtcy5maWRzICAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHR3byBGSURzXG4gICAgICogQHBhcmFtIHtBcnJheTxOb3RpZmljYXRpb25UeXBlPn0gcGFyYW1zLnR5cGUgW29wdGlvbmFsXSAgLSBDb21tYSBzZXBlcmF0ZWQgbGlzdCBvZiBJbnRlcmFjdGlvbiB0eXBlIHRvIGZldGNoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJJbnRlcmFjdGlvbnMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckludGVyYWN0aW9uczIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkcyA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VySW50ZXJhY3Rpb25zKHsgZmlkcywgdHlwZSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VySW50ZXJhY3Rpb25zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5tYXAodmFsdWUgPT4gKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5hZ2VudHNBcGkuZmV0Y2hVc2VySW50ZXJhY3Rpb25zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN1bW1hcnkgb2YgYWxsIGNhc3RzIHJlbGF0ZWQgdG8gYSBjb252ZXJzYXRpb24gc3Vycm91bmRpbmcgYSBjYXN0IGJ5IHBhc3NpbmcgaW4gYSBjYXN0IGhhc2ggb3IgRmFyY2FzdGVyIFVSTC4gIFN1bW1hcnkgaXMgZ2VuZXJhdGVkIGJ5IGFuIExMTSBhbmQgaXMgaW50ZW5kZWQgdG8gYmUgcGFzc2VkIGFzIGEgY29udGV4dCB0byBBSSBhZ2VudHMuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDYXN0IGNvbnZlcnNhdGlvbiBzdW1tYXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZGVudGlmaWVyICAtIENhc3QgaWRlbnRpZmllciAoSXRzIGVpdGhlciBhIHVybCBvciBhIGhhc2gpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiBjYXN0cyB0byBjb25zaWRlciBpbiBhIHN1bW1hcnkgdXAgdG8gYSBwb2ludCBvZiB0YXJnZXQgY2FzdCAoRGVmYXVsdDogMjAsIE1heGltdW06IDUwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJvbXB0IFtvcHRpb25hbF0gIC0gQWRkaXRpb25hbCBwcm9tcHQgdXNlZCB0byBnZW5lcmF0ZSBhIHN1bW1hcnlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbnZlcnNhdGlvblN1bW1hcnk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDb252ZXJzYXRpb25TdW1tYXJ5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgaWRlbnRpZmllciA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqIGNvbnN0IHByb21wdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQubG9va3VwQ2FzdENvbnZlcnNhdGlvblN1bW1hcnkoeyBpZGVudGlmaWVyLCBsaW1pdCwgcHJvbXB0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtY29udmVyc2F0aW9uLXN1bW1hcnkpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBsb29rdXBDYXN0Q29udmVyc2F0aW9uU3VtbWFyeShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYWdlbnRzQXBpLmxvb2t1cENhc3RDb252ZXJzYXRpb25TdW1tYXJ5KGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZXZlbnQgb2JqZWN0IGZvciBhcHAgaG9zdCBldmVudHMuIFVzZWQgaWYgdGhlIGFwcCBob3N0IGludGVuZHMgdG8gc2lnbiB0aGUgZXZlbnQgbWVzc2FnZSBpbnN0ZWFkIG9mIHVzaW5nIE5leW5hci1ob3N0ZWQgc2lnbmVycy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhcHAgaG9zdCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXBwRG9tYWluICAtIFRoZSBkb21haW4gb2YgdGhlIG1pbmkgYXBwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCBvZiB0aGUgdXNlciB3aG8gaW5pdGlhdGVkIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7QXBwSG9zdEV2ZW50VHlwZX0gcGFyYW1zLmV2ZW50ICAtIFRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBIb3N0R2V0RXZlbnRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFwcEhvc3RHZXRFdmVudFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgYXBwRG9tYWluID1cbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IGV2ZW50ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5hcHBIb3N0R2V0RXZlbnQoeyBhcHBEb21haW4sIGZpZCwgZXZlbnQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jIGFwcEhvc3RHZXRFdmVudChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYXBwSG9zdEFwaS5hcHBIb3N0R2V0RXZlbnQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBub3RpZmljYXRpb24gc3RhdGUgZm9yIGEgc3BlY2lmaWMgdXNlciBhY3Jvc3MgYWxsIG1pbmkgYXBwIGRvbWFpbnMgaW4gdGhpcyBhcHAgaG9zdC4gU2hvd3Mgd2hpY2ggZG9tYWlucyBoYXZlIG5vdGlmaWNhdGlvbnMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdXNlclxcJ3Mgbm90aWZpY2F0aW9uIHN1YnNjcmlwdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIG9mIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBIb3N0VXNlclN0YXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBBcHBIb3N0VXNlclN0YXRlUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmFwcEhvc3RHZXRVc2VyU3RhdGUoeyBmaWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jIGFwcEhvc3RHZXRVc2VyU3RhdGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmFwcEhvc3RBcGkuYXBwSG9zdEdldFVzZXJTdGF0ZShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGFuIGFwcF9ob3N0IGV2ZW50IHRvIHRoZSBkb21haW5cXCdzIHdlYmhvb2suIEV2ZW50cyBzdWNoIGFzIGVuYWJsaW5nIG9yIGRpc2FibGluZyBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuIFByb3ZpZGUgZWl0aGVyIGEgc2lnbmVkIG1lc3NhZ2Ugb3IgdGhlIHNpZ25lciBVVUlEIG9mIGFuIGF1dGhvcml6ZWQgbmV5bmFyLWhvc3RlZCBzaWduZXJzLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUHJvY2VzcyBhcHAgaG9zdCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7QXBwSG9zdFBvc3RFdmVudEJvZHl9IHBhcmFtcy5hcHBIb3N0UG9zdEV2ZW50Qm9keVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXBwSG9zdFBvc3RFdmVudFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgYXBwSG9zdFBvc3RFdmVudEJvZHkgPVxuICAgICAqXG4gICAgICogY2xpZW50LmFwcEhvc3RQb3N0RXZlbnQoeyBhcHBIb3N0UG9zdEV2ZW50Qm9keSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgYXBwSG9zdFBvc3RFdmVudChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYXBwSG9zdEFwaS5hcHBIb3N0UG9zdEV2ZW50KGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBsaXN0IG9mIEZJRHMgZnJvbSB0aGUgYXBwIGFzc29jaWF0ZWQgd2l0aCB5b3VyIEFQSSBrZXkuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVbmJhbiBGSURzIGZyb20gYXBwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuZmlkc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QmFuUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCYW5SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZHMgPVxuICAgICAqXG4gICAgICogY2xpZW50LmRlbGV0ZUJhbnMoe2ZpZHN9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1iYW5zKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQmFucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgYmFuUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmJhbkFwaS5kZWxldGVCYW5zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCB5b3VyIGFwcCBoYXMgYmFubmVkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQmFubmVkIEZJRHMgb2YgYXBwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5MaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCYW5MaXN0UmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hCYW5MaXN0KHsgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1iYW4tbGlzdClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQmFuTGlzdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYmFuQXBpLmZldGNoQmFuTGlzdChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYW5zIGEgbGlzdCBvZiBGSURzIGZyb20gdGhlIGFwcCBhc3NvY2lhdGVkIHdpdGggeW91ciBBUEkga2V5LiBCYW5uZWQgdXNlcnMsIHRoZWlyIGNhc3RzIGFuZCByZWFjdGlvbnMgd2lsbCBub3QgYXBwZWFyIGluIGZlZWRzLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQmFuIEZJRHMgZnJvbSBhcHBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhcmFtcy5maWRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJhblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucHVibGlzaEJhbnMoe2ZpZHN9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtYmFucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHB1Ymxpc2hCYW5zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBiYW5SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYmFuQXBpLnB1Ymxpc2hCYW5zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBibG9jayBmb3IgYSBnaXZlbiBGSUQuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVbmJsb2NrIEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYmxvY2tlZEZpZCAgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBmYXJjYXN0ZXIgdXNlciBvciBhcHAgKHVuc2lnbmVkIGludGVnZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgYmxvY2tlZEZpZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZGVsZXRlQmxvY2soe3NpZ25lclV1aWQsIGJsb2NrZWRGaWR9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2RlbGV0ZS1ibG9jaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUJsb2NrKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBibG9ja1JlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5ibG9ja0FwaS5kZWxldGVCbG9jayhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFsbCBGSURzIHRoYXQgYSB1c2VyIGhhcyBibG9ja2VkIG9yIGhhcyBiZWVuIGJsb2NrZWQgYnlcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJsb2NrZWQgLyBCbG9ja2VkIGJ5IEZJRHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmJsb2NrZXJGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiB0aGUgdXNlcnMgdGhhdCB0aGlzIHVzZXIgaGFzIGJsb2NrZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmJsb2NrZWRGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiB0aGUgdXNlcnMgdGhhdCBoYXZlIGJsb2NrZWQgdGhpcyB1c2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCbG9ja0xpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEJsb2NrTGlzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgYmxvY2tlckZpZCA9XG4gICAgICogY29uc3QgYmxvY2tlZEZpZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQmxvY2tMaXN0KHsgYmxvY2tlckZpZCwgYmxvY2tlZEZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ibG9jay1saXN0KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hCbG9ja0xpc3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmJsb2NrQXBpLmZldGNoQmxvY2tMaXN0KGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBibG9jayBmb3IgYSBnaXZlbiBGSUQuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCbG9jayBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lclV1aWQgIC0gVVVJRCBvZiB0aGUgc2lnbmVyLiBgc2lnbmVyX3V1aWRgIGlzIHBhaXJlZCB3aXRoIEFQSSBrZXksIGNhbid0IHVzZSBhIGB1dWlkYCBtYWRlIHdpdGggYSBkaWZmZXJlbnQgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmJsb2NrZWRGaWQgIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIGEgZmFyY2FzdGVyIHVzZXIgb3IgYXBwICh1bnNpZ25lZCBpbnRlZ2VyKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IGJsb2NrZWRGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnB1Ymxpc2hCbG9jayh7c2lnbmVyVXVpZCwgYmxvY2tlZEZpZH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1ibG9jaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHB1Ymxpc2hCbG9jayhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgYmxvY2tSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuYmxvY2tBcGkucHVibGlzaEJsb2NrKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBjYXN0LiBcXFxcIChJbiBvcmRlciB0byBkZWxldGUgYSBjYXN0IGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIGNhc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lclV1aWQgIC0gVVVJRCBvZiB0aGUgc2lnbmVyLiBgc2lnbmVyX3V1aWRgIGlzIHBhaXJlZCB3aXRoIEFQSSBrZXksIGNhbid0IHVzZSBhIGB1dWlkYCBtYWRlIHdpdGggYSBkaWZmZXJlbnQgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRhcmdldEhhc2ggIC0gQ2FzdCBIYXNoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgdGFyZ2V0SGFzaCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZGVsZXRlQ2FzdCh7c2lnbmVyVXVpZCwgdGFyZ2V0SGFzaH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLWNhc3QpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVDYXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBkZWxldGVDYXN0UmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNhc3RBcGkuZGVsZXRlQ2FzdChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBtdWx0aXBsZSBjYXN0cyB1c2luZyB0aGVpciByZXNwZWN0aXZlIGhhc2hlcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ1bGsgZmV0Y2ggY2FzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuY2FzdHMgIC0gSGFzaGVzIG9mIHRoZSBjYXN0IHRvIGJlIHJldHJpdmVkIChDb21tYSBzZXBhcmF0ZWQsIG5vIHNwYWNlcylcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIGFkZHMgdmlld2VyX2NvbnRleHQgdG8gY2FzdCBvYmplY3QgdG8gc2hvdyB3aGV0aGVyIHZpZXdlciBoYXMgbGlrZWQgb3IgcmVjYXN0ZWQgdGhlIGNhc3QuXG4gICAgICogQHBhcmFtIHtGZXRjaEJ1bGtDYXN0c1NvcnRUeXBlRW51bX0gcGFyYW1zLnNvcnRUeXBlIFtvcHRpb25hbF0gIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHNvcnQgdGhlIGNhc3RzIGJhc2VkIG9uIGRpZmZlcmVudCBjcml0ZXJpYVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBjYXN0cyA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBzb3J0VHlwZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hCdWxrQ2FzdHMoeyBjYXN0cywgdmlld2VyRmlkLCBzb3J0VHlwZSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWJ1bGstY2FzdHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEJ1bGtDYXN0cyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgaWYgKGFkanVzdGVkUGFyYW1zLmNhc3RzICYmIEFycmF5LmlzQXJyYXkoYWRqdXN0ZWRQYXJhbXMuY2FzdHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5jYXN0cyA9IGFkanVzdGVkUGFyYW1zLmNhc3RzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNhc3RBcGkuZmV0Y2hCdWxrQ2FzdHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgY29tcG9zZXIgYWN0aW9ucyBvbiBXYXJwY2FzdC4gWW91IGNhbiBmaWx0ZXIgYnkgdG9wIG9yIGZlYXR1cmVkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggY29tcG9zZXIgYWN0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Q2FzdENvbXBvc2VyVHlwZX0gcGFyYW1zLmxpc3QgIC0gVHlwZSBvZiBsaXN0IHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDI1KVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0Q29tcG9zZXJBY3Rpb25zTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdENvbXBvc2VyQWN0aW9uc0xpc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGxpc3QgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaENvbXBvc2VyQWN0aW9ucyh7IGxpc3QsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY29tcG9zZXItYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQ29tcG9zZXJBY3Rpb25zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jYXN0QXBpLmZldGNoQ29tcG9zZXJBY3Rpb25zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyYXdscyB0aGUgZ2l2ZW4gVVJMIGFuZCByZXR1cm5zIG1ldGFkYXRhIHVzZWZ1bCB3aGVuIGVtYmVkZGluZyB0aGUgVVJMIGluIGEgY2FzdC5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEVtYmVkZGVkIFVSTCBtZXRhZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsICAtIFVSTCB0byBjcmF3bCBtZXRhZGF0YSBvZlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdEVtYmVkQ3Jhd2xSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RFbWJlZENyYXdsUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB1cmwgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoRW1iZWRkZWRVcmxNZXRhZGF0YSh7IHVybCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWVtYmVkZGVkLXVybC1tZXRhZGF0YSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoRW1iZWRkZWRVcmxNZXRhZGF0YShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2FzdEFwaS5mZXRjaEVtYmVkZGVkVXJsTWV0YWRhdGEoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBhbiBpbmRpdmlkdWFsIGNhc3QgYnkgcGFzc2luZyBpbiBhIEZhcmNhc3RlciB3ZWIgVVJMIG9yIGNhc3QgaGFzaFxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgaGFzaCBvciBVUkxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlkZW50aWZpZXIgIC0gQ2FzdCBpZGVudGlmaWVyIChJdHMgZWl0aGVyIGEgdXJsIG9yIGEgaGFzaClcbiAgICAgKiBAcGFyYW0ge0Nhc3RQYXJhbVR5cGV9IHBhcmFtcy50eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBhZGRzIHZpZXdlcl9jb250ZXh0IHRvIGNhc3Qgb2JqZWN0IHRvIHNob3cgd2hldGhlciB2aWV3ZXIgaGFzIGxpa2VkIG9yIHJlY2FzdGVkIHRoZSBjYXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgaWRlbnRpZmllciA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBDYXN0QnlIYXNoT3JXYXJwY2FzdFVybCh7IGlkZW50aWZpZXIsIHR5cGUsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWJ5LWhhc2gtb3Itd2FycGNhc3QtdXJsKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNhc3RBcGkubG9va3VwQ2FzdEJ5SGFzaE9yV2FycGNhc3RVcmwoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgY2FzdHMgcmVsYXRlZCB0byBhIGNvbnZlcnNhdGlvbiBzdXJyb3VuZGluZyBhIGNhc3QgYnkgcGFzc2luZyBpbiBhIGNhc3QgaGFzaCBvciBGYXJjYXN0ZXIgVVJMLiBJbmNsdWRlcyBhbGwgdGhlIGFuY2VzdG9ycyBvZiBhIGNhc3QgdXAgdG8gdGhlIHJvb3QgcGFyZW50IGluIGEgY2hyb25vbG9naWNhbCBvcmRlci4gSW5jbHVkZXMgYWxsIGRpcmVjdF9yZXBsaWVzIHRvIHRoZSBjYXN0IHVwIHRvIHRoZSByZXBseV9kZXB0aCBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENvbnZlcnNhdGlvbiBmb3IgYSBjYXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZGVudGlmaWVyICAtIENhc3QgaWRlbnRpZmllciAoSXRzIGVpdGhlciBhIHVybCBvciBhIGhhc2gpXG4gICAgICogQHBhcmFtIHtDYXN0UGFyYW1UeXBlfSBwYXJhbXMudHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucmVwbHlEZXB0aCBbb3B0aW9uYWxdICAtIFRoZSBkZXB0aCBvZiByZXBsaWVzIGluIHRoZSBjb252ZXJzYXRpb24gdGhhdCB3aWxsIGJlIHJldHVybmVkIChkZWZhdWx0IDIpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0cyBbb3B0aW9uYWxdICAtIEluY2x1ZGUgYWxsIHBhcmVudCBjYXN0cyBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGNvbnZlcnNhdGlvbiB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtDYXN0Q29udmVyc2F0aW9uU29ydFR5cGV9IHBhcmFtcy5zb3J0VHlwZSBbb3B0aW9uYWxdICAtIFNvcnQgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIG9mIGRlc2NlbmRhbnRzLiBEZWZhdWx0IGlzIGBjaHJvbmBcbiAgICAgKiBAcGFyYW0ge0xvb2t1cENhc3RDb252ZXJzYXRpb25Gb2xkRW51bX0gcGFyYW1zLmZvbGQgW29wdGlvbmFsXSAgLSBTaG93IGNvbnZlcnNhdGlvbiBhYm92ZSBvciBiZWxvdyB0aGUgZm9sZC4gTG93ZXIgcXVhbGl0eSByZXNwb25zZXMgYXJlIGhpZGRlbiBiZWxvdyB0aGUgZm9sZC4gTm90IHBhc3NpbmcgaW4gYSB2YWx1ZSBzaG93cyB0aGUgZnVsbCBjb252ZXJzYXRpb24gd2l0aG91dCBhbnkgZm9sZGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiA1MClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29udmVyc2F0aW9uPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ29udmVyc2F0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgaWRlbnRpZmllciA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICogY29uc3QgcmVwbHlEZXB0aCA9XG4gICAgICogY29uc3QgaW5jbHVkZUNocm9ub2xvZ2ljYWxQYXJlbnRDYXN0cyA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBzb3J0VHlwZSA9XG4gICAgICogY29uc3QgZm9sZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cENhc3RDb252ZXJzYXRpb24oeyBpZGVudGlmaWVyLCB0eXBlLCByZXBseURlcHRoLCBpbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCBmb2xkLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWNvbnZlcnNhdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cENhc3RDb252ZXJzYXRpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNhc3RBcGkubG9va3VwQ2FzdENvbnZlcnNhdGlvbihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0cyBhIGNhc3Qgb3IgY2FzdCByZXBseS4gV29ya3Mgd2l0aCBtZW50aW9ucyBhbmQgZW1iZWRzLiAgIChJbiBvcmRlciB0byBwb3N0IGEgY2FzdCBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBQb3N0IGEgY2FzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudGV4dCBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtBcnJheTxQb3N0Q2FzdFJlcUJvZHlFbWJlZHM+fSBwYXJhbXMuZW1iZWRzIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhcmVudCBbb3B0aW9uYWxdICAtIHBhcmVudF91cmwgb2YgdGhlIGNoYW5uZWwgdGhlIGNhc3QgaXMgaW4sIG9yIGhhc2ggb2YgdGhlIGNhc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYW5uZWxJZCBbb3B0aW9uYWxdICAtIENoYW5uZWwgSUQgb2YgdGhlIGNoYW5uZWwgd2hlcmUgdGhlIGNhc3QgaXMgdG8gYmUgcG9zdGVkLiBlLmcuIG5leW5hciwgZmFyY2FzdGVyLCB3YXJwY2FzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaWRlbSBbb3B0aW9uYWxdICAtIEFuIElkZW1wb3RlbmN5IGtleSBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcmVxdWVzdC4gKipOb3RlOioqICAxKSBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBkdXBsaWNhdGUgcmVxdWVzdHMuIFVzZSB0aGUgc2FtZSBpZGVtIGtleSBvbiByZXRyeSBhdHRlbXB0cy4gMikgVGhpcyBzaG91bGQgYmUgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCByZXF1ZXN0LiAzKSBSZWNvbW1lbmRlZCBmb3JtYXQgaXMgYSAxNi1jaGFyYWN0ZXIgc3RyaW5nIGdlbmVyYXRlZCBieSB0aGUgZGV2ZWxvcGVyIGF0IHRoZSB0aW1lIG9mIG1ha2luZyB0aGlzIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5wYXJlbnRBdXRob3JGaWQgW29wdGlvbmFsXSAgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBmYXJjYXN0ZXIgdXNlciBvciBhcHAgKHVuc2lnbmVkIGludGVnZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQb3N0Q2FzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUG9zdENhc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IHRleHQgPVxuICAgICAqIGNvbnN0IGVtYmVkcyA9XG4gICAgICogY29uc3QgcGFyZW50ID1cbiAgICAgKiBjb25zdCBjaGFubmVsSWQgPVxuICAgICAqIGNvbnN0IGlkZW0gPVxuICAgICAqIGNvbnN0IHBhcmVudEF1dGhvckZpZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucHVibGlzaENhc3Qoe3NpZ25lclV1aWQsIHRleHQsIGVtYmVkcywgcGFyZW50LCBjaGFubmVsSWQsIGlkZW0sIHBhcmVudEF1dGhvckZpZH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1jYXN0KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcHVibGlzaENhc3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IHBvc3RDYXN0UmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNhc3RBcGkucHVibGlzaENhc3QoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBjYXN0cyBiYXNlZCBvbiBhIHF1ZXJ5IHN0cmluZywgd2l0aCBvcHRpb25hbCBBTkQgZmlsdGVyc1xuICAgICAqXG4gICAgICogQHN1bW1hcnkgU2VhcmNoIGZvciBjYXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucSAgLSBRdWVyeSBzdHJpbmcgdG8gc2VhcmNoIGZvciBjYXN0cy4gU3VwcG9ydGVkIG9wZXJhdG9yczogIHwgT3BlcmF0b3IgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8IC0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgfCBgK2AgICAgICAgfCBBY3RzIGFzIHRoZSBBTkQgb3BlcmF0b3IuIFRoaXMgaXMgdGhlIGRlZmF1bHQgb3BlcmF0b3IgYmV0d2VlbiB0ZXJtcyBhbmQgY2FuIHVzdWFsbHkgYmUgb21pdHRlZC4gICAgICAgICB8IHwgYHxgICAgICAgfCBBY3RzIGFzIHRoZSBPUiBvcGVyYXRvci4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgYCpgICAgICAgIHwgV2hlbiB1c2VkIGF0IHRoZSBlbmQgb2YgYSB0ZXJtLCBzaWduaWZpZXMgYSBwcmVmaXggcXVlcnkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgYFwiYCAgICAgICB8IFdyYXBzIHNldmVyYWwgdGVybXMgaW50byBhIHBocmFzZSAoZm9yIGV4YW1wbGUsIGBcInN0YXIgd2Fyc1wiYCkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8IGAoYCwgYClgICB8IFdyYXAgYSBjbGF1c2UgZm9yIHByZWNlZGVuY2UgKGZvciBleGFtcGxlLCBgc3RhciArICh3YXJzIHwgdHJlaylgKS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8IGB+bmAgICAgICB8IFdoZW4gdXNlZCBhZnRlciBhIHRlcm0gKGZvciBleGFtcGxlLCBgc2F0cn4zYCksIHNldHMgYGZ1enppbmVzc2AuIFdoZW4gdXNlZCBhZnRlciBhIHBocmFzZSwgc2V0cyBgc2xvcGAuIHwgfCBgLWAgICAgICAgfCBOZWdhdGVzIHRoZSB0ZXJtLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgYGJlZm9yZTpgIHwgU2VhcmNoIGZvciBjYXN0cyBiZWZvcmUgYSBzcGVjaWZpYyBkYXRlLiAoZS5nLiBgYmVmb3JlOjIwMjUtMDQtMjBgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCBgYWZ0ZXI6YCAgfCBTZWFyY2ggZm9yIGNhc3RzIGFmdGVyIGEgc3BlY2lmaWMgZGF0ZS4gKGUuZy4gYGFmdGVyOjIwMjUtMDQtMjBgKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIEBwYXJhbSB7U2VhcmNoQ2FzdHNNb2RlRW51bX0gcGFyYW1zLm1vZGUgW29wdGlvbmFsXSAgLSBDaG9pY2VzIGFyZTogLSBgbGl0ZXJhbGAgLSBTZWFyY2hlcyBmb3IgdGhlIHdvcmRzIGluIHRoZSBxdWVyeSBzdHJpbmcgKGRlZmF1bHQpIC0gYHNlbWFudGljYCAtIFNlYXJjaGVzIGZvciB0aGUgbWVhbmluZyBvZiB0aGUgcXVlcnkgc3RyaW5nIC0gYGh5YnJpZGAgLSBDb21iaW5lcyBib3RoIGxpdGVyYWwgYW5kIHNlbWFudGljIHJlc3VsdHNcbiAgICAgKiBAcGFyYW0ge1NlYXJjaFNvcnRUeXBlfSBwYXJhbXMuc29ydFR5cGUgW29wdGlvbmFsXSAgLSBDaG9pY2VzIGFyZTogLSBgZGVzY19jaHJvbmAgLSBBbGwgY2FzdHMgc29ydGVkIGJ5IHRpbWUgKGRlZmF1bHQpIC0gYGFsZ29yaXRobWljYCAtIENhc3RzIHNvcnRlZCBieSBlbmdhZ2VtZW50IGFuZCB0aW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5hdXRob3JGaWQgW29wdGlvbmFsXSAgLSBGaWQgb2YgdGhlIHVzZXIgd2hvc2UgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBzZWFyY2ggcmVzdWx0cyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYXJlbnRVcmwgW29wdGlvbmFsXSAgLSBQYXJlbnQgVVJMIG9mIHRoZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYW5uZWxJZCBbb3B0aW9uYWxdICAtIENoYW5uZWwgSUQgb2YgdGhlIGNhc3RzIHlvdSB3YW50IHRvIHNlYXJjaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnByaW9yaXR5TW9kZSBbb3B0aW9uYWxdICAtIFdoZW4gdHJ1ZSwgb25seSByZXR1cm5zIHNlYXJjaCByZXN1bHRzIGZyb20gcG93ZXIgYmFkZ2UgdXNlcnMgYW5kIHVzZXJzIHRoYXQgdGhlIHZpZXdlciBmb2xsb3dzIChpZiB2aWV3ZXJfZmlkIGlzIHByb3ZpZGVkKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2FzdHNTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENhc3RzU2VhcmNoUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBxID1cbiAgICAgKiBjb25zdCBtb2RlID1cbiAgICAgKiBjb25zdCBzb3J0VHlwZSA9XG4gICAgICogY29uc3QgYXV0aG9yRmlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IHBhcmVudFVybCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCBwcmlvcml0eU1vZGUgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5zZWFyY2hDYXN0cyh7IHEsIG1vZGUsIHNvcnRUeXBlLCBhdXRob3JGaWQsIHZpZXdlckZpZCwgcGFyZW50VXJsLCBjaGFubmVsSWQsIHByaW9yaXR5TW9kZSwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2FzdHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hDYXN0cyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2FzdEFwaS5zZWFyY2hDYXN0cyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMjAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbExpc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaEFsbENoYW5uZWxzKHsgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1hbGwtY2hhbm5lbHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEFsbENoYW5uZWxzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLmZldGNoQWxsQ2hhbm5lbHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkZXRhaWxzIG9mIG11bHRpcGxlIGNoYW5uZWxzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCdWxrIGZldGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmlkcyAgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjaGFubmVsIElEcyBvciBwYXJlbnRfdXJscywgdXAgdG8gMTAwIGF0IGEgdGltZVxuICAgICAqIEBwYXJhbSB7Q2hhbm5lbFR5cGV9IHBhcmFtcy50eXBlIFtvcHRpb25hbF0gIC0gVHlwZSBvZiBpZGVudGlmaWVyIGJlaW5nIHVzZWQgdG8gcXVlcnkgdGhlIGNoYW5uZWxzLiBEZWZhdWx0cyB0byBJRC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIEZJRCBvZiB0aGUgdXNlciB2aWV3aW5nIHRoZSBjaGFubmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxSZXNwb25zZUJ1bGs+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsUmVzcG9uc2VCdWxrYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgaWRzID1cbiAgICAgKiBjb25zdCB0eXBlID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQnVsa0NoYW5uZWxzKHsgaWRzLCB0eXBlLCB2aWV3ZXJGaWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1idWxrLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hCdWxrQ2hhbm5lbHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGlmIChhZGp1c3RlZFBhcmFtcy5pZHMgJiYgQXJyYXkuaXNBcnJheShhZGp1c3RlZFBhcmFtcy5pZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5pZHMgPSBhZGp1c3RlZFBhcmFtcy5pZHMuam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2hhbm5lbEFwaS5mZXRjaEJ1bGtDaGFubmVscyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgaW52aXRlcywgZWl0aGVyIGluIGEgY2hhbm5lbCBvciBmb3IgYSB1c2VyLiBJZiBib3RoIGFyZSBwcm92aWRlZCwgb3BlbiBjaGFubmVsIGludml0ZSBmb3IgdGhhdCB1c2VyIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgT3BlbiBpbnZpdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFubmVsSWQgW29wdGlvbmFsXSAgLSBDaGFubmVsIElEIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5pbnZpdGVkRmlkIFtvcHRpb25hbF0gIC0gRklEIG9mIHRoZSB1c2VyIGJlaW5nIGludml0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxNZW1iZXJJbnZpdGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTWVtYmVySW52aXRlTGlzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCBpbnZpdGVkRmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hDaGFubmVsSW52aXRlcyh7IGNoYW5uZWxJZCwgaW52aXRlZEZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jaGFubmVsLWludml0ZXMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaENoYW5uZWxJbnZpdGVzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLmZldGNoQ2hhbm5lbEludml0ZXMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIG1lbWJlcnMgaW4gYSBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFubmVsSWQgIC0gQ2hhbm5lbCBJRCBmb3IgdGhlIGNoYW5uZWwgYmVpbmcgcXVlcmllZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkIFtvcHRpb25hbF0gIC0gRklEIG9mIHRoZSB1c2VyIGJlaW5nIHF1ZXJpZWQuIFNwZWNpZnkgdGhpcyB0byBjaGVjayBpZiBhIHVzZXIgaXMgYSBtZW1iZXIgb2YgdGhlIGNoYW5uZWwgd2l0aG91dCBwYWdpbmF0aW5nIHRocm91Z2ggYWxsIG1lbWJlcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGFubmVsTWVtYmVyTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbE1lbWJlckxpc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGNoYW5uZWxJZCA9XG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hDaGFubmVsTWVtYmVycyh7IGNoYW5uZWxJZCwgZmlkLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtbWVtYmVycylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQ2hhbm5lbE1lbWJlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNoYW5uZWxBcGkuZmV0Y2hDaGFubmVsTWVtYmVycyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgY2hhbm5lbC4gTWF4IGxpbWl0IGlzIDEwMDAuIFVzZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGb3IgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaWQgIC0gQ2hhbm5lbCBJRCBmb3IgdGhlIGNoYW5uZWwgYmVpbmcgcXVlcmllZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGZvbGxvd2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIGZvbGxvd2VycyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMDApXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaEZvbGxvd2Vyc0ZvckFDaGFubmVsKHsgaWQsIHZpZXdlckZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3dlcnMtZm9yLWEtY2hhbm5lbClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoRm9sbG93ZXJzRm9yQUNoYW5uZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNoYW5uZWxBcGkuZmV0Y2hGb2xsb3dlcnNGb3JBQ2hhbm5lbChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiByZWxldmFudCBjaGFubmVsIGZvbGxvd2VycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGNoYW5uZWwgYXMgXFxcIlgsIFksIFogZm9sbG93IHRoaXMgY2hhbm5lbFxcXCIuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBSZWxldmFudCBmb2xsb3dlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlkICAtIENoYW5uZWwgSUQgYmVpbmcgcXVlcmllZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkICAtIFRoZSBGSUQgb2YgdGhlIHVzZXIgdG8gY3VzdG9taXplIHRoaXMgcmVzcG9uc2UgZm9yLiBQcm92aWRpbmcgdGhpcyB3aWxsIGFsc28gcmV0dXJuIGEgbGlzdCBvZiBmb2xsb3dlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXIncyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyBgdmlld2VyX2NvbnRleHRgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBpZCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwoeyBpZCwgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZm9sbG93ZXJzLWZvci1hLWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFJlbGV2YW50Rm9sbG93ZXJzRm9yQUNoYW5uZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNoYW5uZWxBcGkuZmV0Y2hSZWxldmFudEZvbGxvd2Vyc0ZvckFDaGFubmVsKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRyZW5kaW5nIGNoYW5uZWxzIGJhc2VkIG9uIGFjdGl2aXR5XG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDaGFubmVscyBieSBhY3Rpdml0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7RmV0Y2hUcmVuZGluZ0NoYW5uZWxzVGltZVdpbmRvd0VudW19IHBhcmFtcy50aW1lV2luZG93IFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDEwLCBNYXhpbXVtOiAyNSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJlbmRpbmdDaGFubmVsUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmVuZGluZ0NoYW5uZWxSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHRpbWVXaW5kb3cgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFRyZW5kaW5nQ2hhbm5lbHMoeyB0aW1lV2luZG93LCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hUcmVuZGluZ0NoYW5uZWxzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLmZldGNoVHJlbmRpbmdDaGFubmVscyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY2hhbm5lbHMgd2l0aCB0aGVpciBkZXRhaWxzIHRoYXQgYW4gRklEIGlzIGEgbWVtYmVyIG9mLiBEYXRhIG1heSBoYXZlIGEgZGVsYXkgb2YgdXAgdG8gMSBob3VyLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgTWVtYmVyIG9mXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxNZW1iZXJMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDaGFubmVsTWVtYmVyTGlzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyQ2hhbm5lbE1lbWJlcnNoaXBzKHsgZmlkLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItY2hhbm5lbC1tZW1iZXJzaGlwcylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVXNlckNoYW5uZWxNZW1iZXJzaGlwcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2hhbm5lbEFwaS5mZXRjaFVzZXJDaGFubmVsTWVtYmVyc2hpcHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGNoYW5uZWxzIHdpdGggdGhlaXIgZGV0YWlscyB0aGF0IGEgRklEIGZvbGxvd3MuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbExpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxMaXN0UmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFVzZXJDaGFubmVscyh7IGZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWNoYW5uZWxzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyQ2hhbm5lbHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNoYW5uZWxBcGkuZmV0Y2hVc2VyQ2hhbm5lbHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgY2hhbm5lbHMgdGhhdCBhIHVzZXIgaGFzIGNhc3RlZCBpbiwgaW4gcmV2ZXJzZSBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggY2hhbm5lbHMgdGhhdCB1c2VyIGlzIGFjdGl2ZSBpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSB1c2VyJ3MgRklEIChpZGVudGlmaWVyKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNBY3RpdmVDaGFubmVsc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2Vyc0FjdGl2ZUNoYW5uZWxzKHsgZmlkLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWFjdGl2ZS1jaGFubmVscylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVXNlcnNBY3RpdmVDaGFubmVscyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2hhbm5lbEFwaS5mZXRjaFVzZXJzQWN0aXZlQ2hhbm5lbHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9sbG93IGEgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRm9sbG93IGEgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbm5lbElkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mb2xsb3dDaGFubmVsKHtzaWduZXJVdWlkLCBjaGFubmVsSWR9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZvbGxvdy1jaGFubmVsKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZm9sbG93Q2hhbm5lbChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgY2hhbm5lbEZvbGxvd1JlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLmZvbGxvd0NoYW5uZWwoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52aXRlIGEgdXNlciB0byBhIGNoYW5uZWxcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEludml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbm5lbElkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciBjaGFubmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIGEgZmFyY2FzdGVyIHVzZXIgb3IgYXBwICh1bnNpZ25lZCBpbnRlZ2VyKVxuICAgICAqIEBwYXJhbSB7Q2hhbm5lbE1lbWJlclJvbGV9IHBhcmFtcy5yb2xlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHJvbGUgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmludml0ZUNoYW5uZWxNZW1iZXIoe3NpZ25lclV1aWQsIGNoYW5uZWxJZCwgZmlkLCByb2xlfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9pbnZpdGUtY2hhbm5lbC1tZW1iZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBpbnZpdGVDaGFubmVsTWVtYmVyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBpbnZpdGVDaGFubmVsTWVtYmVyUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmNoYW5uZWxBcGkuaW52aXRlQ2hhbm5lbE1lbWJlcihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRldGFpbHMgb2YgYSBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCeSBJRCBvciBwYXJlbnRfdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZCAgLSBDaGFubmVsIElEIGZvciB0aGUgY2hhbm5lbCBiZWluZyBxdWVyaWVkXG4gICAgICogQHBhcmFtIHtDaGFubmVsVHlwZX0gcGFyYW1zLnR5cGUgW29wdGlvbmFsXSAgLSBUeXBlIG9mIGlkZW50aWZpZXIgYmVpbmcgdXNlZCB0byBxdWVyeSB0aGUgY2hhbm5lbC4gRGVmYXVsdHMgdG8gSUQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBGSUQgb2YgdGhlIHVzZXIgdmlld2luZyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENoYW5uZWxSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYENoYW5uZWxSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGlkID1cbiAgICAgKiBjb25zdCB0eXBlID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cENoYW5uZWwoeyBpZCwgdHlwZSwgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNoYW5uZWwpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBsb29rdXBDaGFubmVsKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLmxvb2t1cENoYW5uZWwoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdXNlciBmcm9tIGEgY2hhbm5lbCBvciBhIHVzZXJcXCdzIGludml0ZSB0byBhIGNoYW5uZWwgcm9sZVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHVzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lclV1aWQgIC0gVVVJRCBvZiB0aGUgc2lnbmVyLiBgc2lnbmVyX3V1aWRgIGlzIHBhaXJlZCB3aXRoIEFQSSBrZXksIGNhbid0IHVzZSBhIGB1dWlkYCBtYWRlIHdpdGggYSBkaWZmZXJlbnQgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYW5uZWxJZCAgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBmYXJjYXN0ZXIgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKiBAcGFyYW0ge0NoYW5uZWxNZW1iZXJSb2xlfSBwYXJhbXMucm9sZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IGNoYW5uZWxJZCA9XG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCByb2xlID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5yZW1vdmVDaGFubmVsTWVtYmVyKHtzaWduZXJVdWlkLCBjaGFubmVsSWQsIGZpZCwgcm9sZX0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVtb3ZlLWNoYW5uZWwtbWVtYmVyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hhbm5lbE1lbWJlcihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgcmVtb3ZlQ2hhbm5lbE1lbWJlclJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLnJlbW92ZUNoYW5uZWxNZW1iZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0IG9yIHJlamVjdCBhIGNoYW5uZWwgaW52aXRlXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBBY2NlcHQgb3IgcmVqZWN0IGFuIGludml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbm5lbElkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciBjaGFubmVsXG4gICAgICogQHBhcmFtIHtDaGFubmVsTWVtYmVyUm9sZX0gcGFyYW1zLnJvbGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hY2NlcHQgIC0gQWNjZXB0IG9yIHJlamVjdCB0aGUgaW52aXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCByb2xlID1cbiAgICAgKiBjb25zdCBhY2NlcHQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnJlc3BvbmRDaGFubmVsSW52aXRlKHtzaWduZXJVdWlkLCBjaGFubmVsSWQsIHJvbGUsIGFjY2VwdH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcmVzcG9uZC1jaGFubmVsLWludml0ZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3BvbmRDaGFubmVsSW52aXRlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyByZXNwb25kQ2hhbm5lbEludml0ZVJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLnJlc3BvbmRDaGFubmVsSW52aXRlKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNoYW5uZWxzIGJhc2VkIG9uIElEIG9yIG5hbWVcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBieSBJRCBvciBuYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5xICAtIENoYW5uZWwgSUQgb3IgbmFtZSBmb3IgdGhlIGNoYW5uZWwgYmVpbmcgcXVlcmllZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjAsIE1heGltdW06IDIwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hhbm5lbFNlYXJjaFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2hhbm5lbFNlYXJjaFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgcSA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnNlYXJjaENoYW5uZWxzKHsgcSwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZWFyY2gtY2hhbm5lbHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hDaGFubmVscyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2hhbm5lbEFwaS5zZWFyY2hDaGFubmVscyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZvbGxvdyBhIGNoYW5uZWxcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFVuZm9sbG93IGEgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbm5lbElkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC51bmZvbGxvd0NoYW5uZWwoe3NpZ25lclV1aWQsIGNoYW5uZWxJZH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdW5mb2xsb3ctY2hhbm5lbClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHVuZm9sbG93Q2hhbm5lbChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgY2hhbm5lbEZvbGxvd1JlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jaGFubmVsQXBpLnVuZm9sbG93Q2hhbm5lbChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBjYXN0cyBmb3IgYSBnaXZlbiB1c2VyIEZJRCBpbiByZXZlcnNlIGNocm9ub2xvZ2ljYWwgb3JkZXIuIEFsc28gYWxsb3dzIGZpbHRlcmluZyBieSBwYXJlbnRfdXJsIGFuZCBjaGFubmVsXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDaHJvbm9sb2dpY2FsbHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdXNlciB3aG9zZSByZWNlbnQgY2FzdHMgeW91IHdhbnQgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFwcEZpZCBbb3B0aW9uYWxdICAtIE9wdGlvbmFsbHkgZmlsdGVyIHRvIGNhc3RzIGNyZWF0ZWQgdmlhIGEgc3BlY2lmaWMgYXBwIEZJRCwgZS5nLiA5MTUyIGZvciBXYXJwY2FzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gRklEIG9mIHRoZSB1c2VyIHZpZXdpbmcgdGhlIGZlZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxNTApXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmluY2x1ZGVSZXBsaWVzIFtvcHRpb25hbF0gIC0gSW5jbHVkZSByZXBseSBjYXN0cyBieSB0aGUgYXV0aG9yIGluIHRoZSByZXNwb25zZSwgdHJ1ZSBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYXJlbnRVcmwgW29wdGlvbmFsXSAgLSBQYXJlbnQgVVJMIHRvIGZpbHRlciB0aGUgZmVlZDsgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggY2hhbm5lbF9pZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbm5lbElkIFtvcHRpb25hbF0gIC0gQ2hhbm5lbCBJRCB0byBmaWx0ZXIgdGhlIGZlZWQ7IG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHBhcmVudF91cmxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgYXBwRmlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKiBjb25zdCBpbmNsdWRlUmVwbGllcyA9XG4gICAgICogY29uc3QgcGFyZW50VXJsID1cbiAgICAgKiBjb25zdCBjaGFubmVsSWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQ2FzdHNGb3JVc2VyKHsgZmlkLCBhcHBGaWQsIHZpZXdlckZpZCwgbGltaXQsIGluY2x1ZGVSZXBsaWVzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3RzLWZvci11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hDYXN0c0ZvclVzZXIocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZlZWRBcGkuZmV0Y2hDYXN0c0ZvclVzZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY2FzdHMgYmFzZWQgb24gZmlsdGVycy4gRW5zdXJlIHNldHRpbmcgdGhlIGNvcnJlY3QgcGFyYW1ldGVycyBiYXNlZCBvbiB0aGUgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ5IGZpbHRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0ZlZWRUeXBlfSBwYXJhbXMuZmVlZFR5cGUgIC0gRGVmYXVsdHMgdG8gZm9sbG93aW5nIChyZXF1aXJlcyBGSUQgb3IgYWRkcmVzcykuIElmIHNldCB0byBmaWx0ZXIgKHJlcXVpcmVzIGZpbHRlcl90eXBlKVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHlwZX0gcGFyYW1zLmZpbHRlclR5cGUgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmVlZF90eXBlPWZpbHRlci4gQ2FuIGJlIHNldCB0byBGSURzIChyZXF1aXJlcyBGSURzKSBvciBwYXJlbnRfdXJsIChyZXF1aXJlcyBwYXJlbnRfdXJsKSBvciBjaGFubmVsX2lkIChyZXF1aXJlcyBjaGFubmVsX2lkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkIFtvcHRpb25hbF0gIC0gKE9wdGlvbmFsKSBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZS4gQnkgZGVmYXVsdCwgdGhlIEFQSSBleHBlY3RzIHRoaXMgZmllbGQsIGV4Y2VwdCBpZiB5b3UgcGFzcyBhIGZpbHRlcl90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5maWRzIFtvcHRpb25hbF0gIC0gVXNlZCB3aGVuIGZpbHRlcl90eXBlPUZJRHMgLiBDcmVhdGUgYSBmZWVkIGJhc2VkIG9uIGEgbGlzdCBvZiBGSURzLiBNYXggYXJyYXkgc2l6ZSBpcyAxMDAuIFJlcXVpcmVzIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYXJlbnRVcmwgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmlsdGVyX3R5cGU9cGFyZW50X3VybCBjYW4gYmUgdXNlZCB0byBmZXRjaCBjb250ZW50IHVuZGVyIGFueSBwYXJlbnQgdXJsIGUuZy4gRklQLTIgY2hhbm5lbHMgb24gV2FycGNhc3QuIFJlcXVpcmVzIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFubmVsSWQgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmlsdGVyX3R5cGU9Y2hhbm5lbF9pZCBjYW4gYmUgdXNlZCB0byBmZXRjaCBjYXN0cyB1bmRlciBhIGNoYW5uZWwuIFJlcXVpcmVzIGZlZWRfdHlwZSBhbmQgZmlsdGVyX3R5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubWVtYmVyc09ubHkgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmlsdGVyX3R5cGU9Y2hhbm5lbF9pZC4gT25seSBpbmNsdWRlIGNhc3RzIGZyb20gbWVtYmVycyBvZiB0aGUgY2hhbm5lbC4gVHJ1ZSBieSBkZWZhdWx0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZW1iZWRVcmwgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmlsdGVyX3R5cGU9ZW1iZWRfdXJsLiBDYXN0cyB3aXRoIGVtYmVkZGVkIFVSTHMgcHJlZml4ZWQgYnkgdGhpcyBlbWJlZF91cmwgcGFyYW0gd2lsbCBiZSByZXR1cm5lZC4gV2Ugbm9ybWFsaXplIHlvdXIgZ2l2ZW4gVVJMIHByZWZpeCBhbmQgcHJlcGVuZCAnaHR0cHM6Ly8nIGlmIG5vIHByb3RvY29sIGlzIGluY2x1ZGVkLiBSZXF1aXJlcyBmZWVkX3R5cGUgYW5kIGZpbHRlcl90eXBlLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8RW1iZWRUeXBlPn0gcGFyYW1zLmVtYmVkVHlwZXMgW29wdGlvbmFsXSAgLSBVc2VkIHdoZW4gZmlsdGVyX3R5cGU9ZW1iZWRfdHlwZXMgY2FuIGJlIHVzZWQgdG8gZmV0Y2ggYWxsIGNhc3RzIHdpdGggbWF0Y2hpbmcgY29udGVudCB0eXBlcy4gUmVxdWlyZXMgZmVlZF90eXBlIGFuZCBmaWx0ZXJfdHlwZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy53aXRoUmVjYXN0cyBbb3B0aW9uYWxdICAtIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgYHZpZXdlcl9jb250ZXh0YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZlZWRUeXBlID1cbiAgICAgKiBjb25zdCBmaWx0ZXJUeXBlID1cbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IGZpZHMgPVxuICAgICAqIGNvbnN0IHBhcmVudFVybCA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCBtZW1iZXJzT25seSA9XG4gICAgICogY29uc3QgZW1iZWRVcmwgPVxuICAgICAqIGNvbnN0IGVtYmVkVHlwZXMgPVxuICAgICAqIGNvbnN0IHdpdGhSZWNhc3RzID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaEZlZWQoeyBmZWVkVHlwZSwgZmlsdGVyVHlwZSwgZmlkLCBmaWRzLCBwYXJlbnRVcmwsIGNoYW5uZWxJZCwgbWVtYmVyc09ubHksIGVtYmVkVXJsLCBlbWJlZFR5cGVzLCB3aXRoUmVjYXN0cywgbGltaXQsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZlZWQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZlZWRBcGkuZmV0Y2hGZWVkKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGZlZWQgYmFzZWQgb24gY2hhbm5lbCBJRHNcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ5IGNoYW5uZWwgSURzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmNoYW5uZWxJZHMgIC0gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgdXAgdG8gMTAgY2hhbm5lbCBJRHMgZS5nLiBuZXluYXIsZmFyY2FzdGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMud2l0aFJlY2FzdHMgW29wdGlvbmFsXSAgLSBJbmNsdWRlIHJlY2FzdHMgaW4gdGhlIHJlc3BvbnNlLCB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMud2l0aFJlcGxpZXMgW29wdGlvbmFsXSAgLSBJbmNsdWRlIHJlcGxpZXMgaW4gdGhlIHJlc3BvbnNlLCBmYWxzZSBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubWVtYmVyc09ubHkgW29wdGlvbmFsXSAgLSBPbmx5IGluY2x1ZGUgY2FzdHMgZnJvbSBtZW1iZXJzIG9mIHRoZSBjaGFubmVsLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGFyYW1zLmZpZHMgW29wdGlvbmFsXSAgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBGSURzIHRvIGZpbHRlciB0aGUgZmVlZCBieSwgdXAgdG8gMTAgYXQgYSB0aW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuc2hvdWxkTW9kZXJhdGUgW29wdGlvbmFsXSAgLSBJZiB0cnVlLCBvbmx5IGNhc3RzIHRoYXQgaGF2ZSBiZWVuIGxpa2VkIGJ5IHRoZSBtb2RlcmF0b3IgKGlmIG9uZSBleGlzdHMpIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBjaGFubmVsSWRzID1cbiAgICAgKiBjb25zdCB3aXRoUmVjYXN0cyA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCB3aXRoUmVwbGllcyA9XG4gICAgICogY29uc3QgbWVtYmVyc09ubHkgPVxuICAgICAqIGNvbnN0IGZpZHMgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKiBjb25zdCBzaG91bGRNb2RlcmF0ZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hGZWVkQnlDaGFubmVsSWRzKHsgY2hhbm5lbElkcywgd2l0aFJlY2FzdHMsIHZpZXdlckZpZCwgd2l0aFJlcGxpZXMsIG1lbWJlcnNPbmx5LCBmaWRzLCBsaW1pdCwgc2hvdWxkTW9kZXJhdGUgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mZWVkLWJ5LWNoYW5uZWwtaWRzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hGZWVkQnlDaGFubmVsSWRzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuY2hhbm5lbElkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmNoYW5uZWxJZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5jaGFubmVsSWRzID0gYWRqdXN0ZWRQYXJhbXMuY2hhbm5lbElkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5tYXAodmFsdWUgPT4gKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mZWVkQXBpLmZldGNoRmVlZEJ5Q2hhbm5lbElkcyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBmZWVkIGJhc2VkIG9uIHBhcmVudCBVUkxzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgVVJMc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5wYXJlbnRVcmxzICAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHBhcmVudF91cmxzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMud2l0aFJlY2FzdHMgW29wdGlvbmFsXSAgLSBJbmNsdWRlIHJlY2FzdHMgaW4gdGhlIHJlc3BvbnNlLCB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMud2l0aFJlcGxpZXMgW29wdGlvbmFsXSAgLSBJbmNsdWRlIHJlcGxpZXMgaW4gdGhlIHJlc3BvbnNlLCBmYWxzZSBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBwYXJlbnRVcmxzID1cbiAgICAgKiBjb25zdCB3aXRoUmVjYXN0cyA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCB3aXRoUmVwbGllcyA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoRmVlZEJ5UGFyZW50VXJscyh7IHBhcmVudFVybHMsIHdpdGhSZWNhc3RzLCB2aWV3ZXJGaWQsIHdpdGhSZXBsaWVzLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZlZWQtYnktcGFyZW50LXVybHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZlZWRCeVBhcmVudFVybHMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGlmIChhZGp1c3RlZFBhcmFtcy5wYXJlbnRVcmxzICYmIEFycmF5LmlzQXJyYXkoYWRqdXN0ZWRQYXJhbXMucGFyZW50VXJscykpIHtcbiAgICAgICAgICAgIGFkanVzdGVkUGFyYW1zLnBhcmVudFVybHMgPSBhZGp1c3RlZFBhcmFtcy5wYXJlbnRVcmxzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZlZWRBcGkuZmV0Y2hGZWVkQnlQYXJlbnRVcmxzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgcGVyc29uYWxpemVkIEZvciBZb3UgZmVlZCBmb3IgYSB1c2VyXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGb3IgeW91XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gRklEIG9mIHVzZXIgd2hvc2UgZmVlZCB5b3Ugd2FudCB0byBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtGb3JZb3VQcm92aWRlcn0gcGFyYW1zLnByb3ZpZGVyIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiA1MClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJvdmlkZXJNZXRhZGF0YSBbb3B0aW9uYWxdICAtIHByb3ZpZGVyX21ldGFkYXRhIGlzIGEgVVJJLWVuY29kZWQgc3RyaW5naWZpZWQgSlNPTiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBwYXNzIGFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gdGhlIHByb3ZpZGVyLiBPbmx5IGF2YWlsYWJsZSBmb3IgbWJkIHByb3ZpZGVyIHJpZ2h0IG5vdy4gU2VlIFtoZXJlXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9kb2NzL2ZlZWQtZm9yLXlvdS13LWV4dGVybmFsLXByb3ZpZGVycykgb24gaG93IHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBwcm92aWRlciA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoRmVlZEZvcllvdSh7IGZpZCwgdmlld2VyRmlkLCBwcm92aWRlciwgbGltaXQsIHByb3ZpZGVyTWV0YWRhdGEgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mZWVkLWZvci15b3UpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZlZWRGb3JZb3UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZlZWRBcGkuZmV0Y2hGZWVkRm9yWW91KGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGZlZWQgb2YgY2FzdHMgd2l0aCBtaW5pIGFwcHMsIHJldmVyc2UgY2hyb25vbG9naWNhbCBvcmRlclxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQ2FzdHMgd2l0aCBtaW5pIGFwcHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiAxMDApXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGZlZWQgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXIncyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyBgdmlld2VyX2NvbnRleHRgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZWVkUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZWVkUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaEZyYW1lc09ubHlGZWVkKHsgbGltaXQsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZyYW1lcy1vbmx5LWZlZWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZyYW1lc09ubHlGZWVkKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mZWVkQXBpLmZldGNoRnJhbWVzT25seUZlZWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggMTAgbW9zdCBwb3B1bGFyIGNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBwb3B1bGFyaXR5IGJhc2VkIG9uIHJlcGxpZXMsIGxpa2VzIGFuZCByZWNhc3RzOyBzb3J0ZWQgYnkgbW9zdCBwb3B1bGFyIGZpcnN0XG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSAxMCBtb3N0IHBvcHVsYXIgY2FzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtDYXN0c1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0Nhc3RzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hQb3B1bGFyQ2FzdHNCeVVzZXIoeyBmaWQsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvcHVsYXItY2FzdHMtYnktdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUG9wdWxhckNhc3RzQnlVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mZWVkQXBpLmZldGNoUG9wdWxhckNhc3RzQnlVc2VyKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHJlY2VudCByZXBsaWVzIGFuZCByZWNhc3RzIGZvciBhIGdpdmVuIHVzZXIgRklEOyBzb3J0ZWQgYnkgbW9zdCByZWNlbnQgZmlyc3RcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJlcGxpZXMgYW5kIHJlY2FzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdXNlciB3aG9zZSByZXBsaWVzIGFuZCByZWNhc3RzIHlvdSB3YW50IHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtGZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlckZpbHRlckVudW19IHBhcmFtcy5maWx0ZXIgW29wdGlvbmFsXSAgLSBmaWx0ZXIgdG8gZmV0Y2ggb25seSByZXBsaWVzIG9yIHJlY2FzdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDI1LCBNYXhpbXVtOiA1MClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgYHZpZXdlcl9jb250ZXh0YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZlZWRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZlZWRSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgZmlsdGVyID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFJlcGxpZXNBbmRSZWNhc3RzRm9yVXNlcih7IGZpZCwgZmlsdGVyLCBsaW1pdCwgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVwbGllcy1hbmQtcmVjYXN0cy1mb3ItdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mZWVkQXBpLmZldGNoUmVwbGllc0FuZFJlY2FzdHNGb3JVc2VyKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRyZW5kaW5nIGNhc3RzIG9yIG9uIHRoZSBnbG9iYWwgZmVlZCBvciBjaGFubmVscyBmZWVkcy4gN2QgdGltZSB3aW5kb3cgYXZhaWxhYmxlIGZvciBjaGFubmVsIGZlZWRzIG9ubHkuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBUcmVuZGluZyBmZWVkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMTAsIE1heGltdW06IDEwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgZmVlZCB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtGZXRjaFRyZW5kaW5nRmVlZFRpbWVXaW5kb3dFbnVtfSBwYXJhbXMudGltZVdpbmRvdyBbb3B0aW9uYWxdICAtIFRpbWUgd2luZG93IGZvciB0cmVuZGluZyBjYXN0cyAoN2Qgd2luZG93IGZvciBjaGFubmVsIGZlZWRzIG9ubHkpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFubmVsSWQgW29wdGlvbmFsXSAgLSBDaGFubmVsIElEIHRvIGZpbHRlciB0cmVuZGluZyBjYXN0cy4gTGVzcyBhY3RpdmUgY2hhbm5lbHMgbWlnaHQgaGF2ZSBubyBjYXN0cyBpbiB0aGUgdGltZSB3aW5kb3cgc2VsZWN0ZWQuIFByb3ZpZGUgZWl0aGVyIGBjaGFubmVsX2lkYCBvciBgcGFyZW50X3VybGAsIG5vdCBib3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucGFyZW50VXJsIFtvcHRpb25hbF0gIC0gUGFyZW50IFVSTCB0byBmaWx0ZXIgdHJlbmRpbmcgY2FzdHMuIExlc3MgYWN0aXZlIGNoYW5uZWxzIG1pZ2h0IGhhdmUgbm8gY2FzdHMgaW4gdGhlIHRpbWUgd2luZG93IHNlbGVjdGVkLiBQcm92aWRlIGVpdGhlciBgY2hhbm5lbF9pZGAgb3IgYHBhcmVudF91cmxgLCBub3QgYm90aC5cbiAgICAgKiBAcGFyYW0ge0ZlZWRUcmVuZGluZ1Byb3ZpZGVyfSBwYXJhbXMucHJvdmlkZXIgW29wdGlvbmFsXSAgLSBUaGUgcHJvdmlkZXIgb2YgdGhlIHRyZW5kaW5nIGNhc3RzIGZlZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcm92aWRlck1ldGFkYXRhIFtvcHRpb25hbF0gIC0gcHJvdmlkZXJfbWV0YWRhdGEgaXMgYSBVUkktZW5jb2RlZCBzdHJpbmdpZmllZCBKU09OIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhc3MgYWRkaXRpb25hbCBtZXRhZGF0YSB0byB0aGUgcHJvdmlkZXIuIE9ubHkgYXZhaWxhYmxlIGZvciBtYmQgcHJvdmlkZXIgcmlnaHQgbm93LiBTZWUgW2hlcmVdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmVlZC1mb3IteW91LXctZXh0ZXJuYWwtcHJvdmlkZXJzKSBvbiBob3cgdG8gdXNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICogY29uc3QgdGltZVdpbmRvdyA9XG4gICAgICogY29uc3QgY2hhbm5lbElkID1cbiAgICAgKiBjb25zdCBwYXJlbnRVcmwgPVxuICAgICAqIGNvbnN0IHByb3ZpZGVyID1cbiAgICAgKiBjb25zdCBwcm92aWRlck1ldGFkYXRhID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFRyZW5kaW5nRmVlZCh7IGxpbWl0LCB2aWV3ZXJGaWQsIHRpbWVXaW5kb3csIGNoYW5uZWxJZCwgcGFyZW50VXJsLCBwcm92aWRlciwgcHJvdmlkZXJNZXRhZGF0YSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXRyZW5kaW5nLWZlZWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFRyZW5kaW5nRmVlZChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZmVlZEFwaS5mZXRjaFRyZW5kaW5nRmVlZChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBmZWVkIGJhc2VkIG9uIHdobyBhIHVzZXIgaXMgZm9sbG93aW5nXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdXNlciB3aG9zZSBmZWVkIHlvdSB3YW50IHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBmZWVkIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgYHZpZXdlcl9jb250ZXh0YC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy53aXRoUmVjYXN0cyBbb3B0aW9uYWxdICAtIEluY2x1ZGUgcmVjYXN0cyBpbiB0aGUgcmVzcG9uc2UsIHRydWUgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmVlZFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmVlZFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IHdpdGhSZWNhc3RzID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyRm9sbG93aW5nRmVlZCh7IGZpZCwgdmlld2VyRmlkLCB3aXRoUmVjYXN0cywgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZy1mZWVkKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93aW5nRmVlZChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZmVlZEFwaS5mZXRjaFVzZXJGb2xsb3dpbmdGZWVkKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgZ2l2ZW4gZm5hbWUgaXMgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDaGVjayBmbmFtZSBhdmFpbGFiaWxpdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGbmFtZUF2YWlsYWJpbGl0eVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRm5hbWVBdmFpbGFiaWxpdHlSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZuYW1lID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5pc0ZuYW1lQXZhaWxhYmxlKHsgZm5hbWUgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9pcy1mbmFtZS1hdmFpbGFibGUpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBpc0ZuYW1lQXZhaWxhYmxlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mbmFtZUFwaS5pc0ZuYW1lQXZhaWxhYmxlKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBzdWdnZXN0ZWQgdXNlcnMgdG8gZm9sbG93LiBVc2VkIHRvIGhlbHAgdXNlcnMgZGlzY292ZXIgbmV3IHVzZXJzIHRvIGZvbGxvd1xuICAgICAqXG4gICAgICogQHN1bW1hcnkgU3VnZ2VzdCBGb2xsb3dzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gRklEIG9mIHRoZSB1c2VyIHdob3NlIGZvbGxvd2luZyB5b3Ugd2FudCB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiB1c2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoRm9sbG93U3VnZ2VzdGlvbnMoeyBmaWQsIHZpZXdlckZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1mb2xsb3ctc3VnZ2VzdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZvbGxvd1N1Z2dlc3Rpb25zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mb2xsb3dzQXBpLmZldGNoRm9sbG93U3VnZ2VzdGlvbnMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcmVsZXZhbnQgZm9sbG93ZXJzIGZvciBhIHNwZWNpZmljIEZJRC4gVGhpcyB1c3VhbGx5IHNob3dzIG9uIGEgcHJvZmlsZSBhcyBcXFwiWCwgWSBhbmQgWiBmb2xsb3cgdGhpcyB1c2VyXFxcIi5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJlbGV2YW50IGZvbGxvd2Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudGFyZ2V0RmlkICAtIFVzZXIgd2hvJ3MgcHJvZmlsZSB5b3UgYXJlIGxvb2tpbmcgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCAgLSBUaGUgRklEIG9mIHRoZSB1c2VyIHRvIGN1c3RvbWl6ZSB0aGlzIHJlc3BvbnNlIGZvci4gUHJvdmlkaW5nIHRoaXMgd2lsbCBhbHNvIHJldHVybiBhIGxpc3Qgb2YgZm9sbG93ZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgYHZpZXdlcl9jb250ZXh0YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbGV2YW50Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWxldmFudEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgdGFyZ2V0RmlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoUmVsZXZhbnRGb2xsb3dlcnMoeyB0YXJnZXRGaWQsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlbGV2YW50LWZvbGxvd2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUmVsZXZhbnRGb2xsb3dlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZvbGxvd3NBcGkuZmV0Y2hSZWxldmFudEZvbGxvd2VycyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb2xsb3dlcnMgZm9yIGEgc3BlY2lmaWMgRklELlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRm9sbG93ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVXNlciB3aG8ncyBwcm9maWxlIHlvdSBhcmUgbG9va2luZyBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIGZvbGxvd2VycyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtGb2xsb3dTb3J0VHlwZX0gcGFyYW1zLnNvcnRUeXBlIFtvcHRpb25hbF0gIC0gU29ydCB0eXBlIGZvciBmZXRjaCBmb2xsb3dlcnMuIERlZmF1bHQgaXMgYGRlc2NfY2hyb25gXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGb2xsb3dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZvbGxvd2Vyc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IHNvcnRUeXBlID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyRm9sbG93ZXJzKHsgZmlkLCB2aWV3ZXJGaWQsIHNvcnRUeXBlLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93ZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93ZXJzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mb2xsb3dzQXBpLmZldGNoVXNlckZvbGxvd2VycyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgd2hvIGEgZ2l2ZW4gdXNlciBpcyBmb2xsb3dpbmcuIENhbiBvcHRpb25hbGx5IGluY2x1ZGUgYSB2aWV3ZXJfZmlkIGFuZCBzb3J0X3R5cGUuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGb2xsb3dpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdGhlIHVzZXIgd2hvc2UgZm9sbG93aW5nIHlvdSB3YW50IHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIHVzZXJzIHRoYXQgcmVzcGVjdHMgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2NrcyBhbmQgaW5jbHVkZXMgYHZpZXdlcl9jb250ZXh0YC5cbiAgICAgKiBAcGFyYW0ge0ZvbGxvd1NvcnRUeXBlfSBwYXJhbXMuc29ydFR5cGUgW29wdGlvbmFsXSAgLSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc29ydCB0aGUgdXNlcnMgYmFzZWQgb24gZGlmZmVyZW50IGNyaXRlcmlhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Rm9sbG93ZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGb2xsb3dlcnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBzb3J0VHlwZSA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlckZvbGxvd2luZyh7IGZpZCwgdmlld2VyRmlkLCBzb3J0VHlwZSwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVXNlckZvbGxvd2luZyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZm9sbG93c0FwaS5mZXRjaFVzZXJGb2xsb3dpbmcoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIG1pbmkgYXBwLCBpZiBpdCB3YXMgbWFkZSBieSB0aGUgZGV2ZWxvcGVyIChpZGVudGlmaWVkIGJ5IEFQSSBrZXkpXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgbWluaSBhcHBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnV1aWQgW29wdGlvbmFsXVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERlbGV0ZUZyYW1lUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB1dWlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5kZWxldGVOZXluYXJGcmFtZSh7dXVpZH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVsZXRlLW5leW5hci1mcmFtZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZU5leW5hckZyYW1lKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBkZWxldGVGcmFtZVJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5kZWxldGVOZXluYXJGcmFtZShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGN1cmF0ZWQgbGlzdCBvZiBmZWF0dXJlZCBtaW5pIGFwcHNcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IE1pbmkgYXBwcyBjYXRhbG9nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAxMDAsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICogQHBhcmFtIHtNaW5pQXBwVGltZVdpbmRvd30gcGFyYW1zLnRpbWVXaW5kb3cgW29wdGlvbmFsXSAgLSBUaW1lIHdpbmRvdyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgY2hhbmdlIGluIHRyZW5kaW5nIHNjb3JlIGZvciBlYWNoIG1pbmkgYXBwLCB1c2VkIHRvIHNvcnQgbWluaSBhcHAgcmVzdWx0c1xuICAgICAqIEBwYXJhbSB7QXJyYXk8RmV0Y2hGcmFtZUNhdGFsb2dDYXRlZ29yaWVzRW51bT59IHBhcmFtcy5jYXRlZ29yaWVzIFtvcHRpb25hbF0gIC0gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY2F0ZWdvcmllcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRzLiAgSW5jbHVkZXMgYWxsIGlmIGxlZnQgYmxhbmsuICBFeGFtcGxlOiBgY2F0ZWdvcmllcz1nYW1lcyxzb2NpYWxgIE9SOiBgY2F0ZWdvcmllcz1nYW1lcyZjYXRlZ29yaWVzPXNvY2lhbGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lQ2F0YWxvZ1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRnJhbWVDYXRhbG9nUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICogY29uc3QgdGltZVdpbmRvdyA9XG4gICAgICogY29uc3QgY2F0ZWdvcmllcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hGcmFtZUNhdGFsb2coeyBsaW1pdCwgdGltZVdpbmRvdywgY2F0ZWdvcmllcyB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hGcmFtZUNhdGFsb2cocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZyYW1lQXBpLmZldGNoRnJhbWVDYXRhbG9nKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG1pbmkgYXBwIG1ldGEgdGFncyBmcm9tIHRoZSBVUkxcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IE1ldGEgdGFncyBmcm9tIFVSTFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsICAtIFRoZSBtaW5pIGFwcCBVUkwgdG8gY3Jhd2xcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHVybCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hGcmFtZU1ldGFUYWdzRnJvbVVybCh7IHVybCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZyYW1lLW1ldGEtdGFncy1mcm9tLXVybClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZyYW1lQXBpLmZldGNoRnJhbWVNZXRhVGFnc0Zyb21VcmwoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIG1pbmkgYXBwcyBtYWRlIGJ5IHRoZSBkZXZlbG9wZXIgKGlkZW50aWZpZWQgYnkgQVBJIGtleSlcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3Qgb2YgbWluaSBhcHBzXG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE5leW5hckZyYW1lPj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEFycmF5PE5leW5hckZyYW1lPmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaE5leW5hckZyYW1lcygpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbmV5bmFyLWZyYW1lcylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTmV5bmFyRnJhbWVzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5mZXRjaE5leW5hckZyYW1lcygpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyB0b2tlbnMgcmVsYXRlZCB0byBhIG1pbmkgYXBwXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IG9mIG1pbmkgYXBwIG5vdGlmaWNhdGlvbiB0b2tlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDIwLCBNYXhpbXVtOiAxMDApXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGFyYW1zLmZpZHMgW29wdGlvbmFsXSAgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBGSURzLCB1cCB0byAxMDAgYXQgYSB0aW1lLiBJZiB5b3UgcGFzcyBpbiBGSURzLCB5b3Ugd2lsbCBnZXQgYmFjayB0aGUgbm90aWZpY2F0aW9uIHRva2VucyBmb3IgdGhvc2UgRklEcy4gSWYgeW91IGRvbid0IHBhc3MgaW4gRklEcywgeW91IHdpbGwgZ2V0IGJhY2sgYWxsIHRoZSBub3RpZmljYXRpb24gdG9rZW5zIGZvciB0aGUgbWluaSBhcHAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvclxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnJhbWVOb3RpZmljYXRpb25Ub2tlbnM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZU5vdGlmaWNhdGlvblRva2Vuc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKiBjb25zdCBmaWRzID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaE5vdGlmaWNhdGlvblRva2Vucyh7IGxpbWl0LCBmaWRzIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbm90aWZpY2F0aW9uLXRva2VucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTm90aWZpY2F0aW9uVG9rZW5zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5tYXAodmFsdWUgPT4gKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5mZXRjaE5vdGlmaWNhdGlvblRva2VucyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgbWluaSBhcHBzIHJlbGV2YW50IHRvIHRoZSB1c2VyIGJhc2VkIG9uIGNhc3RzIGJ5IHVzZXJzIHdpdGggc3Ryb25nIGFmZmluaXR5IHNjb3JlIGZvciB0aGUgdXNlclxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVsZXZhbnQgbWluaSBhcHBzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgIC0gRklEIG9mIHRoZSB1c2VyIHRvIGZldGNoIHJlbGV2YW50IG1pbmkgYXBwcyBmb3JcbiAgICAgKiBAcGFyYW0ge01pbmlBcHBUaW1lV2luZG93fSBwYXJhbXMudGltZVdpbmRvdyBbb3B0aW9uYWxdICAtIFRpbWUgd2luZG93IHVzZWQgdG8gbGltaXQgc3RhdGlzdGljcyB1c2VkIHRvIGNhbGN1bGF0ZSBtaW5pIGFwcCByZWxldmFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoUmVsZXZhbnRGcmFtZXMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoUmVsZXZhbnRGcmFtZXMyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICogY29uc3QgdGltZVdpbmRvdyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hSZWxldmFudEZyYW1lcyh7IHZpZXdlckZpZCwgdGltZVdpbmRvdyB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZyYW1lLXJlbGV2YW50KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hSZWxldmFudEZyYW1lcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZnJhbWVBcGkuZmV0Y2hSZWxldmFudEZyYW1lcyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmFseXRpY3MgZm9yIHRvdGFsLWludGVyYWN0b3JzLCBpbnRlcmFjdG9ycywgbnRlcmFjdGlvbnMtcGVyLWNhc3QgYW5kIGlucHV0LXRleHQuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBBbmFseXRpY3MgZm9yIHRoZSBtaW5pIGFwcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZnJhbWVVcmxcbiAgICAgKiBAcGFyYW0ge1ZhbGlkYXRlRnJhbWVBbmFseXRpY3NUeXBlfSBwYXJhbXMuYW5hbHl0aWNzVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc3RhcnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnN0b3BcbiAgICAgKiBAcGFyYW0ge1ZhbGlkYXRlRnJhbWVBZ2dyZWdhdGVXaW5kb3d9IHBhcmFtcy5hZ2dyZWdhdGVXaW5kb3cgW29wdGlvbmFsXSAgLSBSZXF1aXJlZCBmb3IgYGFuYWx5dGljc190eXBlPWludGVyYWN0aW9ucy1wZXItY2FzdGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lVmFsaWRhdGVBbmFseXRpY3NSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZyYW1lVXJsID1cbiAgICAgKiBjb25zdCBhbmFseXRpY3NUeXBlID1cbiAgICAgKiBjb25zdCBzdGFydCA9XG4gICAgICogY29uc3Qgc3RvcCA9XG4gICAgICogY29uc3QgYWdncmVnYXRlV2luZG93ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFZhbGlkYXRlRnJhbWVBbmFseXRpY3MoeyBmcmFtZVVybCwgYW5hbHl0aWNzVHlwZSwgc3RhcnQsIHN0b3AsIGFnZ3JlZ2F0ZVdpbmRvdyB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXZhbGlkYXRlLWZyYW1lLWFuYWx5dGljcylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVmFsaWRhdGVGcmFtZUFuYWx5dGljcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZnJhbWVBcGkuZmV0Y2hWYWxpZGF0ZUZyYW1lQW5hbHl0aWNzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIG1pbmkgYXBwcyB2YWxpZGF0ZWQgYnkgYSB1c2VyXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBBbGwgbWluaSBhcHBzIHZhbGlkYXRlZCBieSB1c2VyXG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZyYW1lVmFsaWRhdGVMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGcmFtZVZhbGlkYXRlTGlzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVmFsaWRhdGVGcmFtZUxpc3QoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXZhbGlkYXRlLWZyYW1lLWxpc3QpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFZhbGlkYXRlRnJhbWVMaXN0KCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5mZXRjaFZhbGlkYXRlRnJhbWVMaXN0KCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBub3RpZmljYXRpb24gZGVsaXZlcnkgYW5kIG9wZW5lZCBzdGF0cyBmb3Igbm90aWZpY2F0aW9uIGNhbXBhaWduc1xuICAgICAqXG4gICAgICogQHN1bW1hcnkgR2V0IG5vdGlmaWNhdGlvbiBjYW1wYWlnbiBzdGF0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2FtcGFpZ25JZCBbb3B0aW9uYWxdICAtIEFuIElEIG9mIGEgc3BlY2lmaWMgbm90aWZpY2F0aW9uIGNhbXBhaWduIHRvIHF1ZXJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIFRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4gKERlZmF1bHQ6IDEwMCxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBHZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzMjAwUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBjYW1wYWlnbklkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZ2V0Tm90aWZpY2F0aW9uQ2FtcGFpZ25TdGF0cyh7IGNhbXBhaWduSWQsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhc3luYyBnZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5nZXROb3RpZmljYXRpb25DYW1wYWlnblN0YXRzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IGEgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwIGJ5IElEXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgdHJhbnNhY3Rpb24gcGF5IG1pbmkgYXBwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZCAgLSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gbWluaSBhcHAgdG8gcmV0cmlldmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFRyYW5zYWN0aW9uRnJhbWVSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5nZXRUcmFuc2FjdGlvblBheUZyYW1lKHsgaWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUGF5RnJhbWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZyYW1lQXBpLmdldFRyYW5zYWN0aW9uUGF5RnJhbWUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBtaW5pIGFwcCBlaXRoZXIgYnkgVVVJRCBvciBOZXluYXIgVVJMXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBNaW5pIGFwcCBieSBVVUlEIG9yIFVSTFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7RnJhbWVUeXBlfSBwYXJhbXMudHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXVpZCBbb3B0aW9uYWxdICAtIFVVSUQgb2YgdGhlIG1pbmkgYXBwIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51cmwgW29wdGlvbmFsXSAgLSBVUkwgb2YgdGhlIE5leW5hciBtaW5pIGFwcCB0byBmZXRjaFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmV5bmFyRnJhbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBOZXluYXJGcmFtZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHR5cGUgPVxuICAgICAqIGNvbnN0IHV1aWQgPVxuICAgICAqIGNvbnN0IHVybCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQubG9va3VwTmV5bmFyRnJhbWUoeyB0eXBlLCB1dWlkLCB1cmwgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtbmV5bmFyLWZyYW1lKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwTmV5bmFyRnJhbWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZyYW1lQXBpLmxvb2t1cE5leW5hckZyYW1lKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgbWluaSBhcHAgYWN0aW9ucywgY2FzdCBhY3Rpb25zIG9yIGNhc3QgY29tcG9zZXIgYWN0aW9ucyB0byB0aGUgc2VydmVyICBcXFxcIChJbiBvcmRlciB0byBwb3N0IGFueSBvZiB0aGVzZSBhY3Rpb25zLCB5b3UgbmVlZCB0byBoYXZlIGFuIGFwcHJvdmVkIGBzaWduZXJfdXVpZGApICBUaGUgUE9TVCByZXF1ZXN0IHRvIHRoZSBwb3N0X3VybCBoYXMgYSB0aW1lb3V0IG9mIDUgc2Vjb25kcyBmb3IgbWluaSBhcHBzLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUG9zdCBhIG1pbmkgYXBwIGFjdGlvbiwgY2FzdCBhY3Rpb24gb3IgYSBjYXN0IGNvbXBvc2VyIGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2FzdEhhc2ggW29wdGlvbmFsXSAgLSBDYXN0IEhhc2hcbiAgICAgKiBAcGFyYW0ge0ZyYW1lQWN0aW9ufSBwYXJhbXMuYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgY2FzdEhhc2ggPVxuICAgICAqIGNvbnN0IGFjdGlvbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucG9zdEZyYW1lQWN0aW9uKHtzaWduZXJVdWlkLCBjYXN0SGFzaCwgYWN0aW9ufSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wb3N0LWZyYW1lLWFjdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHBvc3RGcmFtZUFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgZnJhbWVBY3Rpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZnJhbWVBcGkucG9zdEZyYW1lQWN0aW9uKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgYSBtaW5pIGFwcCBhY3Rpb24gdGhhdCBoYXMgYmVlbiBzaWduZWQgd2l0aCBhIGRldmVsb3BlciBtYW5hZ2VkIHNpZ25lciAgVGhlIFBPU1QgcmVxdWVzdCB0byB0aGUgcG9zdF91cmwgaGFzIGEgdGltZW91dCBvZiA1IHNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTaWduYXR1cmUgcGFja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jYXN0SGFzaCBbb3B0aW9uYWxdICAtIENhc3QgSGFzaFxuICAgICAqIEBwYXJhbSB7RnJhbWVBY3Rpb259IHBhcmFtcy5hY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ZyYW1lU2lnbmF0dXJlUGFja2V0fSBwYXJhbXMuc2lnbmF0dXJlUGFja2V0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgY2FzdEhhc2ggPVxuICAgICAqIGNvbnN0IGFjdGlvbiA9XG4gICAgICogY29uc3Qgc2lnbmF0dXJlUGFja2V0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5wb3N0RnJhbWVBY3Rpb25EZXZlbG9wZXJNYW5hZ2VkKHtjYXN0SGFzaCwgYWN0aW9uLCBzaWduYXR1cmVQYWNrZXR9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3Bvc3QtZnJhbWUtYWN0aW9uLWRldmVsb3Blci1tYW5hZ2VkKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcG9zdEZyYW1lQWN0aW9uRGV2ZWxvcGVyTWFuYWdlZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgZnJhbWVEZXZlbG9wZXJNYW5hZ2VkQWN0aW9uUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZyYW1lQXBpLnBvc3RGcmFtZUFjdGlvbkRldmVsb3Blck1hbmFnZWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBub3RpZmljYXRpb25zIHRvIGludGVyYWN0b3JzIG9mIGEgbWluaSBhcHBcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFNlbmQgbm90aWZpY2F0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcGFyYW1zLnRhcmdldEZpZHMgIC0gQW4gYXJyYXkgb2YgdGFyZ2V0IEZJRHMgdG8gd2hvbSB0aGUgbm90aWZpY2F0aW9ucyBzaG91bGQgYmUgc2VudC4gRWFjaCBGSUQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIFBhc3MgYW4gZW1wdHkgYXJyYXkgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvIGFsbCBGSURzIHdpdGggbm90aWZpY2F0aW9ucyBlbmFibGVkIGZvciB0aGUgbWluaSBhcHAuXG4gICAgICogQHBhcmFtIHtTZW5kRnJhbWVOb3RpZmljYXRpb25zUmVxQm9keU5vdGlmaWNhdGlvbn0gcGFyYW1zLm5vdGlmaWNhdGlvblxuICAgICAqIEBwYXJhbSB7U2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHlGaWx0ZXJzfSBwYXJhbXMuZmlsdGVycyBbb3B0aW9uYWxdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZW5kRnJhbWVOb3RpZmljYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTZW5kRnJhbWVOb3RpZmljYXRpb25zUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB0YXJnZXRGaWRzID1cbiAgICAgKiBjb25zdCBub3RpZmljYXRpb24gPVxuICAgICAqIGNvbnN0IGZpbHRlcnMgPVxuICAgICAqXG4gICAgICogY2xpZW50LnB1Ymxpc2hGcmFtZU5vdGlmaWNhdGlvbnMoe3RhcmdldEZpZHMsIG5vdGlmaWNhdGlvbiwgZmlsdGVyc30pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1mcmFtZS1ub3RpZmljYXRpb25zKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcHVibGlzaEZyYW1lTm90aWZpY2F0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgc2VuZEZyYW1lTm90aWZpY2F0aW9uc1JlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS5wdWJsaXNoRnJhbWVOb3RpZmljYXRpb25zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBtaW5pIGFwcCB3aXRoIGEgbGlzdCBvZiBwYWdlcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBtaW5pIGFwcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAgLSBUaGUgbmFtZSBvZiB0aGUgbWluaSBhcHAuXG4gICAgICogQHBhcmFtIHtBcnJheTxOZXluYXJGcmFtZVBhZ2U+fSBwYXJhbXMucGFnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5leW5hckZyYW1lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTmV5bmFyRnJhbWVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBuYW1lID1cbiAgICAgKiBjb25zdCBwYWdlcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucHVibGlzaE5leW5hckZyYW1lKHtuYW1lLCBwYWdlc30pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1uZXluYXItZnJhbWUpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoTmV5bmFyRnJhbWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IG5leW5hckZyYW1lQ3JlYXRpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZnJhbWVBcGkucHVibGlzaE5leW5hckZyYW1lKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgbWluaSBhcHBzIGJhc2VkIG9uIGEgcXVlcnkgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTZWFyY2ggbWluaSBhcHBzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5xICAtIFF1ZXJ5IHN0cmluZyB0byBzZWFyY2ggZm9yIG1pbmkgYXBwc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjAsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGcmFtZUNhdGFsb2dSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZyYW1lQ2F0YWxvZ1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgcSA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnNlYXJjaEZyYW1lcyh7IHEsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLWZyYW1lcylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaEZyYW1lcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuZnJhbWVBcGkuc2VhcmNoRnJhbWVzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBleGlzdGluZyBtaW5pIGFwcCB3aXRoIGEgbGlzdCBvZiBwYWdlcywgaWYgaXQgd2FzIG1hZGUgYnkgdGhlIGRldmVsb3BlciAoaWRlbnRpZmllZCBieSBBUEkga2V5KVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgVXBkYXRlIG1pbmkgYXBwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51dWlkICAtIFRoZSBVVUlEIG9mIHRoZSBtaW5pIGFwcCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIFtvcHRpb25hbF0gIC0gVGhlIG5hbWUgb2YgdGhlIG1pbmkgYXBwLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8TmV5bmFyRnJhbWVQYWdlPn0gcGFyYW1zLnBhZ2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZXluYXJGcmFtZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5leW5hckZyYW1lYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgdXVpZCA9XG4gICAgICogY29uc3QgbmFtZSA9XG4gICAgICogY29uc3QgcGFnZXMgPVxuICAgICAqXG4gICAgICogY2xpZW50LnVwZGF0ZU5leW5hckZyYW1lKHt1dWlkLCBuYW1lLCBwYWdlc30pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLW5leW5hci1mcmFtZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZU5leW5hckZyYW1lKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBuZXluYXJGcmFtZVVwZGF0ZVJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS51cGRhdGVOZXluYXJGcmFtZShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYSBtaW5pIGFwcCBhZ2FpbnN0IGJ5IGFuIGludGVyYWN0aW5nIHVzZXIgYWdhaW5zdCBhIEZhcmNhc3RlciBIdWIgXFxcXCAoSW4gb3JkZXIgdG8gdmFsaWRhdGUgYSBtaW5pIGFwcCwgbWVzc2FnZSBieXRlcyBmcm9tIEZyYW1lIEFjdGlvbiBtdXN0IGJlIHByb3ZpZGVkIGluIGhleClcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFZhbGlkYXRlIG1pbmkgYXBwIGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZUJ5dGVzSW5IZXggIC0gSGV4YWRlY2ltYWwgc3RyaW5nIG9mIG1lc3NhZ2UgYnl0ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuY2FzdFJlYWN0aW9uQ29udGV4dCBbb3B0aW9uYWxdICAtIEFkZHMgdmlld2VyX2NvbnRleHQgaW5zaWRlIHRoZSBjYXN0IG9iamVjdCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBpbnRlcmFjdG9yIHJlYWN0ZWQgdG8gdGhlIGNhc3QgaG91c2luZyB0aGUgbWluaSBhcHAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZm9sbG93Q29udGV4dCBbb3B0aW9uYWxdICAtIEFkZHMgdmlld2VyX2NvbnRleHQgaW5zaWRlIHRoZSB1c2VyIChpbnRlcmFjdG9yKSBvYmplY3QgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgaW50ZXJhY3RvciBmb2xsb3dzIG9yIGlzIGZvbGxvd2VkIGJ5IHRoZSBjYXN0IGF1dGhvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5zaWduZXJDb250ZXh0IFtvcHRpb25hbF0gIC0gQWRkcyBjb250ZXh0IGFib3V0IHRoZSBhcHAgdXNlZCBieSB0aGUgdXNlciBpbnNpZGUgYGZyYW1lLmFjdGlvbmAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuY2hhbm5lbEZvbGxvd0NvbnRleHQgW29wdGlvbmFsXSAgLSBBZGRzIGNvbnRleHQgYWJvdXQgdGhlIGNoYW5uZWwgdGhhdCB0aGUgY2FzdCBiZWxvbmdzIHRvIGluc2lkZSBvZiB0aGUgY2FzdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWYWxpZGF0ZUZyYW1lQWN0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBWYWxpZGF0ZUZyYW1lQWN0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBtZXNzYWdlQnl0ZXNJbkhleCA9XG4gICAgICogY29uc3QgY2FzdFJlYWN0aW9uQ29udGV4dCA9XG4gICAgICogY29uc3QgZm9sbG93Q29udGV4dCA9XG4gICAgICogY29uc3Qgc2lnbmVyQ29udGV4dCA9XG4gICAgICogY29uc3QgY2hhbm5lbEZvbGxvd0NvbnRleHQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnZhbGlkYXRlRnJhbWVBY3Rpb24oe21lc3NhZ2VCeXRlc0luSGV4LCBjYXN0UmVhY3Rpb25Db250ZXh0LCBmb2xsb3dDb250ZXh0LCBzaWduZXJDb250ZXh0LCBjaGFubmVsRm9sbG93Q29udGV4dH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdmFsaWRhdGUtZnJhbWUtYWN0aW9uKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGVGcmFtZUFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgdmFsaWRhdGVGcmFtZUFjdGlvblJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5mcmFtZUFwaS52YWxpZGF0ZUZyYW1lQWN0aW9uKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vbmNlIHRvIHNpZ24gYSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBub25jZVxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb25jZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm9uY2VSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaE5vbmNlKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ub25jZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTm9uY2UoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmxvZ2luQXBpLmZldGNoTm9uY2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgbWV0cmljcyBjYXN0cyBtYXRjaGluZyBhIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBNZXRyaWNzIGZvciBjYXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucSAgLSBRdWVyeSBzdHJpbmcgdG8gc2VhcmNoIGZvciBjYXN0c1xuICAgICAqIEBwYXJhbSB7RmV0Y2hDYXN0TWV0cmljc0ludGVydmFsRW51bX0gcGFyYW1zLmludGVydmFsIFtvcHRpb25hbF0gIC0gSW50ZXJ2YWwgb2YgdGltZSBmb3Igd2hpY2ggdG8gZmV0Y2ggbWV0cmljcy4gRGVmYXVsdCBpcyAzMGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5hdXRob3JGaWQgW29wdGlvbmFsXSAgLSBGaWQgb2YgdGhlIHVzZXIgd2hvc2UgY2FzdHMgeW91IHdhbnQgdG8gc2VhcmNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFubmVsSWQgW29wdGlvbmFsXSAgLSBDaGFubmVsIElEIG9mIHRoZSBjYXN0cyB5b3Ugd2FudCB0byBzZWFyY2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RzTWV0cmljc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdHNNZXRyaWNzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBxID1cbiAgICAgKiBjb25zdCBpbnRlcnZhbCA9XG4gICAgICogY29uc3QgYXV0aG9yRmlkID1cbiAgICAgKiBjb25zdCBjaGFubmVsSWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQ2FzdE1ldHJpY3MoeyBxLCBpbnRlcnZhbCwgYXV0aG9yRmlkLCBjaGFubmVsSWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LW1ldHJpY3MpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaENhc3RNZXRyaWNzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5tZXRyaWNzQXBpLmZldGNoQ2FzdE1ldHJpY3MoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIG11dGUgZm9yIGEgZ2l2ZW4gRklELiBUaGlzIGlzIGFuIGFsbG93bGlzdGVkIEFQSSwgcmVhY2ggb3V0IGlmIHlvdSB3YW50IGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFVubXV0ZSBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBmYXJjYXN0ZXIgdXNlciBvciBhcHAgKHVuc2lnbmVkIGludGVnZXIpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tdXRlZEZpZCAgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBmYXJjYXN0ZXIgdXNlciBvciBhcHAgKHVuc2lnbmVkIGludGVnZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNdXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBNdXRlUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IG11dGVkRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5kZWxldGVNdXRlKHtmaWQsIG11dGVkRmlkfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtbXV0ZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZU11dGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IG11dGVSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMubXV0ZUFwaS5kZWxldGVNdXRlKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIEZJRHMgdGhhdCBhIHVzZXIgaGFzIG11dGVkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgTXV0ZWQgRklEcyBvZiB1c2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIHVzZXIncyBGSUQgKGlkZW50aWZpZXIpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyMCwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNdXRlTGlzdFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTXV0ZUxpc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoTXV0ZUxpc3QoeyBmaWQsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbXV0ZS1saXN0KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hNdXRlTGlzdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMubXV0ZUFwaS5mZXRjaE11dGVMaXN0KGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtdXRlIGZvciBhIGdpdmVuIEZJRC4gVGhpcyBpcyBhbiBhbGxvd2xpc3RlZCBBUEksIHJlYWNoIG91dCBpZiB5b3Ugd2FudCBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBNdXRlIEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm11dGVkRmlkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE11dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE11dGVSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgbXV0ZWRGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnB1Ymxpc2hNdXRlKHtmaWQsIG11dGVkRmlkfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9wdWJsaXNoLW11dGUpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoTXV0ZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgbXV0ZVJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5tdXRlQXBpLnB1Ymxpc2hNdXRlKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgZm9yIGEgc3BlY2lmaWMgRklELlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRm9yIHVzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdGhlIHVzZXIgeW91IHlvdSB3YW50IHRvIGZldGNoIG5vdGlmaWNhdGlvbnMgZm9yLiBUaGUgcmVzcG9uc2Ugd2lsbCByZXNwZWN0IHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MuXG4gICAgICogQHBhcmFtIHtBcnJheTxOb3RpZmljYXRpb25UeXBlPn0gcGFyYW1zLnR5cGUgW29wdGlvbmFsXSAgLSBOb3RpZmljYXRpb24gdHlwZSB0byBmZXRjaC4gQ29tbWEgc2VwYXJhdGVkIHZhbHVlcyBvZiBmb2xsb3dzLCByZWNhc3RzLCBsaWtlcywgbWVudGlvbnMsIHJlcGxpZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucHJpb3JpdHlNb2RlIFtvcHRpb25hbF0gIC0gV2hlbiB0cnVlLCBvbmx5IHJldHVybnMgbm90aWZpY2F0aW9ucyBmcm9tIHBvd2VyIGJhZGdlIHVzZXJzIGFuZCB1c2VycyB0aGF0IHRoZSB1c2VyIGZvbGxvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAxNSwgTWF4aW11bTogMjUpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICogY29uc3QgcHJpb3JpdHlNb2RlID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hBbGxOb3RpZmljYXRpb25zKHsgZmlkLCB0eXBlLCBwcmlvcml0eU1vZGUsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYWxsLW5vdGlmaWNhdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEFsbE5vdGlmaWNhdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm5vdGlmaWNhdGlvbnNBcGkuZmV0Y2hBbGxOb3RpZmljYXRpb25zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlciBpbiBzcGVjaWZpYyBjaGFubmVsc1xuICAgICAqXG4gICAgICogQHN1bW1hcnkgRm9yIHVzZXIgYnkgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIEZJRCBvZiB0aGUgdXNlciB5b3UgeW91IHdhbnQgdG8gZmV0Y2ggbm90aWZpY2F0aW9ucyBmb3IuIFRoZSByZXNwb25zZSB3aWxsIHJlc3BlY3QgdGhpcyB1c2VyJ3MgbXV0ZXMgYW5kIGJsb2Nrcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuY2hhbm5lbElkcyAgLSBDb21tYSBzZXBhcmF0ZWQgY2hhbm5lbF9pZHMgKGZpbmQgbGlzdCBvZiBhbGwgY2hhbm5lbHMgaGVyZSAtIGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9saXN0LWFsbC1jaGFubmVscylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5wcmlvcml0eU1vZGUgW29wdGlvbmFsXSAgLSBXaGVuIHRydWUsIG9ubHkgcmV0dXJucyBub3RpZmljYXRpb25zIGZyb20gcG93ZXIgYmFkZ2UgdXNlcnMgYW5kIHVzZXJzIHRoYXQgdGhlIHVzZXIgZm9sbG93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxpbWl0IFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHJlc3VsdHMgdG8gZmV0Y2ggKERlZmF1bHQ6IDE1LCBNYXhpbXVtOiAyNSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Tm90aWZpY2F0aW9uc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTm90aWZpY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBjaGFubmVsSWRzID1cbiAgICAgKiBjb25zdCBwcmlvcml0eU1vZGUgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaENoYW5uZWxOb3RpZmljYXRpb25zRm9yVXNlcih7IGZpZCwgY2hhbm5lbElkcywgcHJpb3JpdHlNb2RlLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNoYW5uZWwtbm90aWZpY2F0aW9ucy1mb3ItdXNlcilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQ2hhbm5lbE5vdGlmaWNhdGlvbnNGb3JVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuY2hhbm5lbElkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmNoYW5uZWxJZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5jaGFubmVsSWRzID0gYWRqdXN0ZWRQYXJhbXMuY2hhbm5lbElkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5ub3RpZmljYXRpb25zQXBpLmZldGNoQ2hhbm5lbE5vdGlmaWNhdGlvbnNGb3JVc2VyKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlciBpbiBzcGVjaWZpYyBwYXJlbnRfdXJsc1xuICAgICAqXG4gICAgICogQHN1bW1hcnkgRm9yIHVzZXIgYnkgcGFyZW50X3VybHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBGSUQgb2YgdGhlIHVzZXIgeW91IHlvdSB3YW50IHRvIGZldGNoIG5vdGlmaWNhdGlvbnMgZm9yLiBUaGUgcmVzcG9uc2Ugd2lsbCByZXNwZWN0IHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnBhcmVudFVybHMgIC0gQ29tbWEgc2VwYXJhdGVkIHBhcmVudF91cmxzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucHJpb3JpdHlNb2RlIFtvcHRpb25hbF0gIC0gV2hlbiB0cnVlLCBvbmx5IHJldHVybnMgbm90aWZpY2F0aW9ucyBmcm9tIHBvd2VyIGJhZGdlIHVzZXJzIGFuZCB1c2VycyB0aGF0IHRoZSB1c2VyIGZvbGxvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAxNSwgTWF4aW11bTogMjUpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5vdGlmaWNhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE5vdGlmaWNhdGlvbnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgcGFyZW50VXJscyA9XG4gICAgICogY29uc3QgcHJpb3JpdHlNb2RlID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hOb3RpZmljYXRpb25zQnlQYXJlbnRVcmxGb3JVc2VyKHsgZmlkLCBwYXJlbnRVcmxzLCBwcmlvcml0eU1vZGUsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtbm90aWZpY2F0aW9ucy1ieS1wYXJlbnQtdXJsLWZvci11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hOb3RpZmljYXRpb25zQnlQYXJlbnRVcmxGb3JVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMucGFyZW50VXJscyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLnBhcmVudFVybHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5wYXJlbnRVcmxzID0gYWRqdXN0ZWRQYXJhbXMucGFyZW50VXJscy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5ub3RpZmljYXRpb25zQXBpLmZldGNoTm90aWZpY2F0aW9uc0J5UGFyZW50VXJsRm9yVXNlcihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIG5vdGlmaWNhdGlvbnMgYXMgc2Vlbi4gWW91IGNhbiBjaG9vc2Ugb25lIG9mIHR3byBhdXRob3JpemF0aW9uIG1ldGhvZHMsIGVpdGhlcjogICAxLiBQcm92aWRlIGEgdmFsaWQgc2lnbmVyX3V1aWQgaW4gdGhlIHJlcXVlc3QgYm9keSAoTW9zdCBjb21tb24pICAgMi4gUHJvdmlkZSBhIHZhbGlkLCBzaWduZWQgXFxcIkJlYXJlclxcXCIgdG9rZW4gaW4gdGhlIHJlcXVlc3RcXCdzIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgc2ltaWxhciB0byB0aGUgICAgICBhcHByb2FjaCBkZXNjcmliZWQgW2hlcmVdKGh0dHBzOi8vZG9jcy5mYXJjYXN0ZXIueHl6L3JlZmVyZW5jZS93YXJwY2FzdC9hcGkjYXV0aGVudGljYXRpb24pXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBNYXJrIGFzIHNlZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lclV1aWQgW29wdGlvbmFsXSAgLSBUaGUgVVVJRCBvZiBhIHNpZ25lciB3aXRoIGF0IGxlYXN0IG9uZSB3cml0ZSBwZXJtaXNzaW9uLiAgUmVxdWlyZWQgdW5sZXNzIGEgdmFsaWQgQXV0aG9yaXphdGlvbiBCZWFyZXIgdG9rZW4gaXMgcHJvdmlkZWQgaW4gdGhlIGhlYWRlci5cbiAgICAgKiBAcGFyYW0ge05vdGlmaWNhdGlvblR5cGV9IHBhcmFtcy50eXBlIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmF1dGhvcml6YXRpb24gW29wdGlvbmFsXSAgLSBPcHRpb25hbCBCZWFyZXIgdG9rZW4gZm9yIGNlcnRhaW4gZW5kcG9pbnRzLiBUaGUgdG9rZW4gZm9ybWF0IGlzIGRlc2NyaWJlZCBbaGVyZV0oaHR0cHM6Ly9kb2NzLmZhcmNhc3Rlci54eXovcmVmZXJlbmNlL3dhcnBjYXN0L2FwaSNhdXRoZW50aWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICogY29uc3QgYXV0aG9yaXphdGlvbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQubWFya05vdGlmaWNhdGlvbnNBc1NlZW4oe3NpZ25lclV1aWQsIHR5cGUsIGF1dGhvcml6YXRpb259KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL21hcmstbm90aWZpY2F0aW9ucy1hcy1zZWVuKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbWFya05vdGlmaWNhdGlvbnNBc1NlZW4ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IG1hcmtOb3RpZmljYXRpb25zQXNTZWVuUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm5vdGlmaWNhdGlvbnNBcGkubWFya05vdGlmaWNhdGlvbnNBc1NlZW4oYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IERlcGxveSBmdW5naWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMub3duZXIgIC0gRXRoZXJldW0gYWRkcmVzcyBvZiB0aGUgb25lIHdobyBpcyBjcmVhdGluZyB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnN5bWJvbCAgLSBTeW1ib2wvVGlja2VyIGZvciB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgIC0gTmFtZSBvZiB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge0ZpbGV9IHBhcmFtcy5tZXRhZGF0YU1lZGlhIFtvcHRpb25hbF0gIC0gTWVkaWEgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHRva2VuLiAgU3VwcG9ydGVkIGZvcm1hdHMgYXJlIGltYWdlL2pwZWcsIGltYWdlL2dpZiBhbmQgaW1hZ2UvcG5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXRhZGF0YURlc2NyaXB0aW9uIFtvcHRpb25hbF0gIC0gRGVzY3JpcHRpb24gb2YgdGhlIHRva2VuXG4gICAgICogQHBhcmFtIHtEZXBsb3lGdW5naWJsZU1ldGFkYXRhTnNmd0VudW19IHBhcmFtcy5tZXRhZGF0YU5zZncgW29wdGlvbmFsXSAgLSBJbmRpY2F0ZXMgaWYgdGhlIHRva2VuIGlzIE5TRlcgKE5vdCBTYWZlIEZvciBXb3JrKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1ldGFkYXRhV2Vic2l0ZUxpbmsgW29wdGlvbmFsXSAgLSBXZWJzaXRlIGxpbmsgcmVsYXRlZCB0byB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1ldGFkYXRhVHdpdHRlciBbb3B0aW9uYWxdICAtIFR3aXR0ZXIgcHJvZmlsZSBsaW5rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXRhZGF0YURpc2NvcmQgW29wdGlvbmFsXSAgLSBEaXNjb3JkIHNlcnZlciBsaW5rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXRhZGF0YVRlbGVncmFtIFtvcHRpb25hbF0gIC0gVGVsZWdyYW0gbGlua1xuICAgICAqIEBwYXJhbSB7RGVwbG95RnVuZ2libGVOZXR3b3JrRW51bX0gcGFyYW1zLm5ldHdvcmsgW29wdGlvbmFsXSAgLSBOZXR3b3JrL0NoYWluIG5hbWVcbiAgICAgKiBAcGFyYW0ge0RlcGxveUZ1bmdpYmxlRmFjdG9yeUVudW19IHBhcmFtcy5mYWN0b3J5IFtvcHRpb25hbF0gIC0gRmFjdG9yeSBuYW1lIC0gd293IC0+IFt3b3cueHl6XShodHRwczovL3dvdy54eXopIC0gY2xhbmtlciAtPiBbY2xhbmtlci53b3JsZF0oaHR0cHM6Ly93d3cuY2xhbmtlci53b3JsZClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPERlcGxveUZ1bmdpYmxlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBEZXBsb3lGdW5naWJsZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgb3duZXIgPVxuICAgICAqIGNvbnN0IHN5bWJvbCA9XG4gICAgICogY29uc3QgbmFtZSA9XG4gICAgICogY29uc3QgbWV0YWRhdGFNZWRpYSA9XG4gICAgICogY29uc3QgbWV0YWRhdGFEZXNjcmlwdGlvbiA9XG4gICAgICogY29uc3QgbWV0YWRhdGFOc2Z3ID1cbiAgICAgKiBjb25zdCBtZXRhZGF0YVdlYnNpdGVMaW5rID1cbiAgICAgKiBjb25zdCBtZXRhZGF0YVR3aXR0ZXIgPVxuICAgICAqIGNvbnN0IG1ldGFkYXRhRGlzY29yZCA9XG4gICAgICogY29uc3QgbWV0YWRhdGFUZWxlZ3JhbSA9XG4gICAgICogY29uc3QgbmV0d29yayA9XG4gICAgICogY29uc3QgZmFjdG9yeSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZGVwbG95RnVuZ2libGUoeyBvd25lciwgc3ltYm9sLCBuYW1lLCBtZXRhZGF0YU1lZGlhLCBtZXRhZGF0YURlc2NyaXB0aW9uLCBtZXRhZGF0YU5zZncsIG1ldGFkYXRhV2Vic2l0ZUxpbmssIG1ldGFkYXRhVHdpdHRlciwgbWV0YWRhdGFEaXNjb3JkLCBtZXRhZGF0YVRlbGVncmFtLCBuZXR3b3JrLCBmYWN0b3J5IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZGVwbG95LWZ1bmdpYmxlKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95RnVuZ2libGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm9uY2hhaW5BcGkuZGVwbG95RnVuZ2libGUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIHJlbGV2YW50IG93bmVycyBmb3IgYSBzcGVjaWZpYyBGSUQuIFRoaXMgdXN1YWxseSBzaG93cyBvbiBhIGZ1bmdpYmxlIGFzc2V0IHBhZ2UgYXMgXFxcIlgsIFksIFogYW5kIE4gb3RoZXJzIHlvdSBrbm93IG93biB0aGlzIGFzc2V0XFxcIi5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJlbGV2YW50IG93bmVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY29udHJhY3RBZGRyZXNzICAtIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGZ1bmdpYmxlIGFzc2V0XG4gICAgICogQHBhcmFtIHtGdW5naWJsZU93bmVyUmVsZXZhbnROZXR3b3JrfSBwYXJhbXMubmV0d29yayAgLSBOZXR3b3JrIG9mIHRoZSBmdW5naWJsZSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIElmIHlvdSBwcm92aWRlIGEgdmlld2VyX2ZpZCwgdGhlIHJlc3BvbnNlIHdpbGwgaW5jbHVkZSB0b2tlbiBob2xkZXJzIGZyb20gdGhlIHVzZXIncyBuZXR3b3JrLCByZXNwZWN0aW5nIHRoZWlyIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGluZyB2aWV3ZXJfY29udGV4dDsgaWYgbm90IHByb3ZpZGVkLCB0aGUgcmVzcG9uc2Ugd2lsbCBzaG93IHRvcCB0b2tlbiBob2xkZXJzIGFjcm9zcyB0aGUgbmV0d29ya+KAlGJvdGggc2V0cyBjYW4gYmUgY29tYmluZWQgdG8gZ2VuZXJhdGUgYSBsb25nZXIgbGlzdCBpZiBkZXNpcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgUmVsZXZhbnRGdW5naWJsZU93bmVyc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID1cbiAgICAgKiBjb25zdCBuZXR3b3JrID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVycyh7IGNvbnRyYWN0QWRkcmVzcywgbmV0d29yaywgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVsZXZhbnQtZnVuZ2libGUtb3duZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hSZWxldmFudEZ1bmdpYmxlT3duZXJzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5vbmNoYWluQXBpLmZldGNoUmVsZXZhbnRGdW5naWJsZU93bmVycyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSB0b2tlbiBiYWxhbmNlcyBvZiBhIHVzZXIgZ2l2ZW4gdGhlaXIgRklEXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBUb2tlbiBiYWxhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gRklEIG9mIHRoZSB1c2VyIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtBcnJheTxOZXR3b3JrPn0gcGFyYW1zLm5ldHdvcmtzICAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG5ldHdvcmtzIHRvIGZldGNoIGJhbGFuY2VzIGZvclxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QmFsYW5jZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQmFsYW5jZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBuZXR3b3JrcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyQmFsYW5jZSh7IGZpZCwgbmV0d29ya3MgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWJhbGFuY2UpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFVzZXJCYWxhbmNlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5vbmNoYWluQXBpLmZldGNoVXNlckJhbGFuY2UoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgZmFyY2FzdGVyIGFjY291bnQgb25jaGFpbi4gT3B0aW9uYWxseSB5b3UgY2FuIHBhc3MgaW4gc2lnbmVycyBhbG9uZyB0byByZWdpc3RlciBhIG5ldyBhY2NvdW50IGFuZCBjcmVhdGUgbXVsdGlwbGUgc2lnbmVycyBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgRmFyY2FzdGVyIGFjY291bnQgb25jaGFpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7UmVnaXN0ZXJVc2VyT25DaGFpblJlcUJvZHlSZWdpc3RyYXRpb259IHBhcmFtcy5yZWdpc3RyYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0b3JhZ2VVbml0cyBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtBcnJheTxSZWdpc3RlclVzZXJPbkNoYWluUmVxQm9keVNpZ25lcnNJbm5lcj59IHBhcmFtcy5zaWduZXJzIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge0FycmF5PFJlZ2lzdGVyVXNlck9uQ2hhaW5SZXFCb2R5UHJlUmVnaXN0cmF0aW9uQ2FsbHNJbm5lcj59IHBhcmFtcy5wcmVSZWdpc3RyYXRpb25DYWxscyBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5pZGVtIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlZ2lzdGVyVXNlck9uQ2hhaW5SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlZ2lzdGVyVXNlck9uQ2hhaW5SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHJlZ2lzdHJhdGlvbiA9XG4gICAgICogY29uc3Qgc3RvcmFnZVVuaXRzID1cbiAgICAgKiBjb25zdCBzaWduZXJzID1cbiAgICAgKiBjb25zdCBwcmVSZWdpc3RyYXRpb25DYWxscyA9XG4gICAgICogY29uc3QgaWRlbSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucmVnaXN0ZXJBY2NvdW50T25jaGFpbih7cmVnaXN0cmF0aW9uLCBzdG9yYWdlVW5pdHMsIHNpZ25lcnMsIHByZVJlZ2lzdHJhdGlvbkNhbGxzLCBpZGVtfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50LW9uY2hhaW4pXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyByZWdpc3RlckFjY291bnRPbmNoYWluKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyByZWdpc3RlclVzZXJPbkNoYWluUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm9uY2hhaW5BcGkucmVnaXN0ZXJBY2NvdW50T25jaGFpbihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGZ1bmdpYmxlcyBpbiBidWxrIHRvIHNldmVyYWwgZmFyY2FzdGVyIHVzZXJzLiBBIGZ1bmRlZCB3YWxsZXQgaXMgdG8gcmVxdWlyZWQgdXNlIHRoaXMgQVBJLiBSZWFjdCBvdXQgdG8gdXMgb24gdGhlIE5leW5hciBjaGFubmVsIG9uIGZhcmNhc3RlciB0byBnZXQgeW91ciB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFNlbmQgZnVuZ2libGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy54V2FsbGV0SWQgIC0gV2FsbGV0IElEIHRvIHVzZSBmb3IgdHJhbnNhY3Rpb25zXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXF1ZXN0fSBwYXJhbXMudHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBUcmFuc2FjdGlvblNlbmRGdW5naWJsZXNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHhXYWxsZXRJZCA9XG4gICAgICogY29uc3QgdHJhbnNhY3Rpb25TZW5kRnVuZ2libGVzUmVxdWVzdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuc2VuZEZ1bmdpYmxlc1RvVXNlcnMoeyB4V2FsbGV0SWQsIHRyYW5zYWN0aW9uU2VuZEZ1bmdpYmxlc1JlcXVlc3QgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9zZW5kLWZ1bmdpYmxlcy10by11c2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRGdW5naWJsZXNUb1VzZXJzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5vbmNoYWluQXBpLnNlbmRGdW5naWJsZXNUb1VzZXJzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJlYWN0aW9uIChsaWtlIG9yIHJlY2FzdCkgdG8gYSBjYXN0IFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSBhIHJlYWN0aW9uIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IERlbGV0ZSByZWFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSBwYXJhbXMucmVhY3Rpb25UeXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy50YXJnZXQgIC0gVGFyZ2V0IGNhc3QgaGFzaCAoaGV4IHN0cmluZyBzdGFydGluZyB3aXRoIDB4KSBPUiBhIHZhbGlkIFVSTC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRhcmdldEF1dGhvckZpZCBbb3B0aW9uYWxdICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlkZW0gW29wdGlvbmFsXSAgLSBBbiBJZGVtcG90ZW5jeSBrZXkgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJlcXVlc3QuICoqTm90ZToqKiAgMSkgVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgZHVwbGljYXRlIHJlcXVlc3RzLiBVc2UgdGhlIHNhbWUgaWRlbSBrZXkgb24gcmV0cnkgYXR0ZW1wdHMuIDIpIFRoaXMgc2hvdWxkIGJlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggcmVxdWVzdC4gMykgUmVjb21tZW5kZWQgZm9ybWF0IGlzIGEgMTYtY2hhcmFjdGVyIHN0cmluZyBnZW5lcmF0ZWQgYnkgdGhlIGRldmVsb3BlciBhdCB0aGUgdGltZSBvZiBtYWtpbmcgdGhpcyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IHJlYWN0aW9uVHlwZSA9XG4gICAgICogY29uc3QgdGFyZ2V0ID1cbiAgICAgKiBjb25zdCB0YXJnZXRBdXRob3JGaWQgPVxuICAgICAqIGNvbnN0IGlkZW0gPVxuICAgICAqXG4gICAgICogY2xpZW50LmRlbGV0ZVJlYWN0aW9uKHtzaWduZXJVdWlkLCByZWFjdGlvblR5cGUsIHRhcmdldCwgdGFyZ2V0QXV0aG9yRmlkLCBpZGVtfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtcmVhY3Rpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVSZWFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgcmVhY3Rpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMucmVhY3Rpb25BcGkuZGVsZXRlUmVhY3Rpb24oYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyByZWFjdGlvbnMgZm9yIGEgZ2l2ZW4gY2FzdFxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVhY3Rpb25zIGZvciBjYXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5oYXNoXG4gICAgICogQHBhcmFtIHtBcnJheTxSZWFjdGlvbnNUeXBlPn0gcGFyYW1zLnR5cGVzICAtIEN1c3RvbWl6ZSB3aGljaCByZWFjdGlvbiB0eXBlcyB0aGUgcmVxdWVzdCBzaG91bGQgc2VhcmNoIGZvci4gVGhpcyBpcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgdGhhdCBjYW4gaW5jbHVkZSB0aGUgZm9sbG93aW5nIHZhbHVlczogJ2xpa2VzJyBhbmQgJ3JlY2FzdHMnLiBCeSBkZWZhdWx0IGFwaSByZXR1cm5zIGJvdGguIFRvIHNlbGVjdCBtdWx0aXBsZSB0eXBlcywgdXNlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGhlc2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF0gIC0gUHJvdmlkaW5nIHRoaXMgd2lsbCByZXR1cm4gYSBsaXN0IG9mIHJlYWN0aW9ucyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiByZXN1bHRzIHRvIGZldGNoIChEZWZhdWx0OiAyNSwgTWF4aW11bTogMTAwKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3Vyc29yIFtvcHRpb25hbF0gIC0gUGFnaW5hdGlvbiBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbnNDYXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbnNDYXN0UmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBoYXNoID1cbiAgICAgKiBjb25zdCB0eXBlcyA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hDYXN0UmVhY3Rpb25zKHsgaGFzaCwgdHlwZXMsIHZpZXdlckZpZCwgbGltaXQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQ2FzdFJlYWN0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMucmVhY3Rpb25BcGkuZmV0Y2hDYXN0UmVhY3Rpb25zKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcmVhY3Rpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJlYWN0aW9ucyBmb3IgdXNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICogQHBhcmFtIHtSZWFjdGlvbnNUeXBlfSBwYXJhbXMudHlwZSAgLSBUeXBlIG9mIHJlYWN0aW9uIHRvIGZldGNoIChsaWtlcyBvciByZWNhc3RzIG9yIGFsbClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIFByb3ZpZGluZyB0aGlzIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiByZWFjdGlvbnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXIncyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyBgdmlld2VyX2NvbnRleHRgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgdHlwZSA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKiBjb25zdCBsaW1pdCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyUmVhY3Rpb25zKHsgZmlkLCB0eXBlLCB2aWV3ZXJGaWQsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1yZWFjdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFVzZXJSZWFjdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnJlYWN0aW9uQXBpLmZldGNoVXNlclJlYWN0aW9ucyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGEgcmVhY3Rpb24gKGxpa2Ugb3IgcmVjYXN0KSB0byBhIGdpdmVuIGNhc3QgXFxcXCAoSW4gb3JkZXIgdG8gcG9zdCBhIHJlYWN0aW9uIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFBvc3QgYSByZWFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSBwYXJhbXMucmVhY3Rpb25UeXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy50YXJnZXQgIC0gVGFyZ2V0IGNhc3QgaGFzaCAoaGV4IHN0cmluZyBzdGFydGluZyB3aXRoIDB4KSBPUiBhIHZhbGlkIFVSTC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRhcmdldEF1dGhvckZpZCBbb3B0aW9uYWxdICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlkZW0gW29wdGlvbmFsXSAgLSBBbiBJZGVtcG90ZW5jeSBrZXkgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJlcXVlc3QuICoqTm90ZToqKiAgMSkgVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgZHVwbGljYXRlIHJlcXVlc3RzLiBVc2UgdGhlIHNhbWUgaWRlbSBrZXkgb24gcmV0cnkgYXR0ZW1wdHMuIDIpIFRoaXMgc2hvdWxkIGJlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggcmVxdWVzdC4gMykgUmVjb21tZW5kZWQgZm9ybWF0IGlzIGEgMTYtY2hhcmFjdGVyIHN0cmluZyBnZW5lcmF0ZWQgYnkgdGhlIGRldmVsb3BlciBhdCB0aGUgdGltZSBvZiBtYWtpbmcgdGhpcyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IHJlYWN0aW9uVHlwZSA9XG4gICAgICogY29uc3QgdGFyZ2V0ID1cbiAgICAgKiBjb25zdCB0YXJnZXRBdXRob3JGaWQgPVxuICAgICAqIGNvbnN0IGlkZW0gPVxuICAgICAqXG4gICAgICogY2xpZW50LnB1Ymxpc2hSZWFjdGlvbih7c2lnbmVyVXVpZCwgcmVhY3Rpb25UeXBlLCB0YXJnZXQsIHRhcmdldEF1dGhvckZpZCwgaWRlbX0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC1yZWFjdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHB1Ymxpc2hSZWFjdGlvbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgcmVhY3Rpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMucmVhY3Rpb25BcGkucHVibGlzaFJlYWN0aW9uKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZXIgYW5kIHJldHVybnMgdGhlIHNpZ25lciBzdGF0dXMuIFxcXFwgKipOb3RlKio6IFdoaWxlIHRlc2luZyBwbGVhc2UgcmV1c2UgdGhlIHNpZ25lciwgaXQgY29zdHMgbW9uZXkgdG8gYXBwcm92ZSBhIHNpZ25lci5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBzaWduZXJcbiAgICAgKlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY2xpZW50LmNyZWF0ZVNpZ25lcigpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvY3JlYXRlLXNpZ25lcilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNpZ25lcigpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuc2lnbmVyQXBpLmNyZWF0ZVNpZ25lcigpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYXV0aG9yaXphdGlvbiB1cmwgKEZldGNoZWQgYXV0aG9yaXplZCB1cmwgdXNlZnVsIGZvciBTSVdOIGxvZ2luIG9wZXJhdGlvbilcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGF1dGhvcml6YXRpb24gdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jbGllbnRJZFxuICAgICAqIEBwYXJhbSB7QXV0aG9yaXphdGlvblVybFJlc3BvbnNlVHlwZX0gcGFyYW1zLnJlc3BvbnNlVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aG9yaXphdGlvblVybFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQXV0aG9yaXphdGlvblVybFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgY2xpZW50SWQgPVxuICAgICAqIGNvbnN0IHJlc3BvbnNlVHlwZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hBdXRob3JpemF0aW9uVXJsKHsgY2xpZW50SWQsIHJlc3BvbnNlVHlwZSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWF1dGhvcml6YXRpb24tdXJsKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hBdXRob3JpemF0aW9uVXJsKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5zaWduZXJBcGkuZmV0Y2hBdXRob3JpemF0aW9uVXJsKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBsaXN0IG9mIHNpZ25lcnMgZm9yIGEgY3VzdG9keSBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IHNpZ25lcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgIC0gQSBTaWduLUluIHdpdGggRXRoZXJldW0gKFNJV0UpIG1lc3NhZ2UgdGhhdCB0aGUgdXNlcidzIEV0aGVyZXVtIHdhbGxldCBzaWducy4gVGhpcyBtZXNzYWdlIGluY2x1ZGVzIGRldGFpbHMgc3VjaCBhcyB0aGUgZG9tYWluLCBhZGRyZXNzLCBzdGF0ZW1lbnQsIFVSSSwgbm9uY2UsIGFuZCBvdGhlciByZWxldmFudCBpbmZvcm1hdGlvbiBmb2xsb3dpbmcgdGhlIEVJUC00MzYxIHN0YW5kYXJkLiBJdCBzaG91bGQgYmUgc3RydWN0dXJlZCBhbmQgVVJMLWVuY29kZWQuICBleGFtcGxlOiAgZXhhbXBsZS5jb20gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6bjB4MjNBLi4uRjIzMm5uU2lnbiBpbiB0byBjb250aW51ZS5ublVSSTogZXhhbXBsZS5jb21uVmVyc2lvbjogMW5DaGFpbiBJRDogMW5Ob25jZTogeHl6MTIzbklzc3VlZCBBdDogMjAyMS0wOS0wMVQxNDo1MjowN1ogIE5vdGU6IFRoaXMgaXMganVzdCBhbiBleGFtcGxlIG1lc3NhZ2UgKFNvLCBtZXNzYWdlIGlzIGludmFsaWQsIHNpbmNlIHdlIGRvbid0IHdhbnQgYW55IHNpZ25lcnMgcmVsYXRlZCB0byBORVlOQVJfQVBJX0RPQ1MgdG8gYmUgZXhwb3NlZCkuICAgW0NoZWNrb3V0IGZldGNoLXNpZ25lcnMgQVBJIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL2RvY3MvZmV0Y2gtc2lnbmVycy0xKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmF0dXJlICAtIFRoZSBkaWdpdGFsIHNpZ25hdHVyZSBwcm9kdWNlZCBieSBzaWduaW5nIHRoZSBwcm92aWRlZCBTSVdFIG1lc3NhZ2Ugd2l0aCB0aGUgdXNlcidzIEV0aGVyZXVtIHByaXZhdGUga2V5LiBUaGlzIHNpZ25hdHVyZSBpcyB1c2VkIHRvIHZlcmlmeSB0aGUgYXV0aGVudGljaXR5IG9mIHRoZSBtZXNzYWdlIGFuZCB0aGUgaWRlbnRpdHkgb2YgdGhlIHNpZ25lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lckxpc3RSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lckxpc3RSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAqIGNvbnN0IHNpZ25hdHVyZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hTaWduZXJzKHsgbWVzc2FnZSwgc2lnbmF0dXJlIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc2lnbmVycylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoU2lnbmVycyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuc2lnbmVyQXBpLmZldGNoU2lnbmVycyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBzdGF0dXMgb2YgYSBkZXZlbG9wZXIgbWFuYWdlZCBzaWduZXIgYnkgcHVibGljIGtleVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgU3RhdHVzIGJ5IHB1YmxpYyBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnB1YmxpY0tleVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGV2ZWxvcGVyTWFuYWdlZFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYERldmVsb3Blck1hbmFnZWRTaWduZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBwdWJsaWNLZXkgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXIoeyBwdWJsaWNLZXkgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtZGV2ZWxvcGVyLW1hbmFnZWQtc2lnbmVyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuc2lnbmVyQXBpLmxvb2t1cERldmVsb3Blck1hbmFnZWRTaWduZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBzdGF0dXMgb2YgYSBzaWduZXIgYnkgcGFzc2luZyBpbiBhIHNpZ25lcl91dWlkIChVc2UgcG9zdCBBUEkgdG8gZ2VuZXJhdGUgYSBzaWduZXIpXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTdGF0dXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lclV1aWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFNpZ25lcih7IHNpZ25lclV1aWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtc2lnbmVyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwU2lnbmVyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5zaWduZXJBcGkubG9va3VwU2lnbmVyKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYSBtZXNzYWdlIHRvIGZhcmNhc3Rlci4gVGhlIG1lc3NhZ2UgbXVzdCBiZSBzaWduZWQgYnkgYSBzaWduZXIgbWFuYWdlZCBieSB0aGUgZGV2ZWxvcGVyLiBVc2UgdGhlIEBmYXJjYXN0ZXIvY29yZSBsaWJyYXJ5IHRvIGNvbnN0cnVjdCBhbmQgc2lnbiB0aGUgbWVzc2FnZS4gVXNlIHRoZSBNZXNzYWdlLnRvSlNPTiBtZXRob2Qgb24gdGhlIHNpZ25lZCBtZXNzYWdlIGFuZCBwYXNzIHRoZSBKU09OIGluIHRoZSBib2R5IG9mIHRoaXMgUE9TVCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUHVibGlzaCBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5ib2R5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBvYmplY3RgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBib2R5ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5wdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyKHsgYm9keSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtbWVzc2FnZS10by1mYXJjYXN0ZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoTWVzc2FnZVRvRmFyY2FzdGVyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5zaWduZXJBcGkucHVibGlzaE1lc3NhZ2VUb0ZhcmNhc3RlcihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gYXBwIEZJRCwgZGVhZGxpbmUgYW5kIGEgc2lnbmF0dXJlLiBSZXR1cm5zIHRoZSBzaWduZXIgc3RhdHVzIHdpdGggYW4gYXBwcm92YWwgdXJsLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgU2lnbmVkIEtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmF0dXJlICAtIFNpZ25hdHVyZSBnZW5lcmF0ZWQgYnkgdGhlIGN1c3RvZHkgYWRkcmVzcyBvZiB0aGUgYXBwLiBTaWduZWQgZGF0YSBpbmNsdWRlcyBhcHBfZmlkLCBkZWFkbGluZSwgc2lnbmVy4oCZcyBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5hcHBGaWQgIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIGEgZmFyY2FzdGVyIHVzZXIgb3IgYXBwICh1bnNpZ25lZCBpbnRlZ2VyKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZGVhZGxpbmUgIC0gdW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kcyB0aGF0IGNvbnRyb2xzIGhvdyBsb25nIHRoZSBzaWduZWQga2V5IHJlcXVlc3QgaXMgdmFsaWQgZm9yLiAoMjQgaG91cnMgZnJvbSBub3cgaXMgcmVjb21tZW5kZWQpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5yZWRpcmVjdFVybCBbb3B0aW9uYWxdICAtIFVybCB0byByZWRpcmVjdCB0byBhZnRlciB0aGUgc2lnbmVyIGlzIGFwcHJvdmVkLiAgKipOb3RlKiogOiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiByZXF1ZXN0aW5nIGEgc2lnbmVyIGZyb20gYSBuYXRpdmUgbW9iaWxlIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7U2lnbmVkS2V5UmVxdWVzdFNwb25zb3J9IHBhcmFtcy5zcG9uc29yIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFNpZ25lcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IHNpZ25hdHVyZSA9XG4gICAgICogY29uc3QgYXBwRmlkID1cbiAgICAgKiBjb25zdCBkZWFkbGluZSA9XG4gICAgICogY29uc3QgcmVkaXJlY3RVcmwgPVxuICAgICAqIGNvbnN0IHNwb25zb3IgPVxuICAgICAqXG4gICAgICogY2xpZW50LnJlZ2lzdGVyU2lnbmVkS2V5KHtzaWduZXJVdWlkLCBzaWduYXR1cmUsIGFwcEZpZCwgZGVhZGxpbmUsIHJlZGlyZWN0VXJsLCBzcG9uc29yfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1zaWduZWQta2V5KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJTaWduZWRLZXkocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IHJlZ2lzdGVyU2lnbmVyS2V5UmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnNpZ25lckFwaS5yZWdpc3RlclNpZ25lZEtleShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gc2lnbmVkIGtleSBhbmQgcmV0dXJucyB0aGUgZGV2ZWxvcGVyIG1hbmFnZWQgc2lnbmVyIHN0YXR1cyB3aXRoIGFuIGFwcHJvdmFsIHVybC5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIFNpZ25lZCBLZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnB1YmxpY0tleSAgLSBFZDI1NTE5IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25hdHVyZSAgLSBTaWduYXR1cmUgZ2VuZXJhdGVkIGJ5IHRoZSBjdXN0b2R5IGFkZHJlc3Mgb2YgdGhlIGFwcC4gU2lnbmVkIGRhdGEgaW5jbHVkZXMgYXBwX2ZpZCwgZGVhZGxpbmUsIHNpZ25lcuKAmXMgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYXBwRmlkICAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBhIGZhcmNhc3RlciB1c2VyIG9yIGFwcCAodW5zaWduZWQgaW50ZWdlcilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmRlYWRsaW5lICAtIHVuaXggdGltZXN0YW1wIGluIHNlY29uZHMgdGhhdCBjb250cm9scyBob3cgbG9uZyB0aGUgc2lnbmVkIGtleSByZXF1ZXN0IGlzIHZhbGlkIGZvci4gKDI0IGhvdXJzIGZyb20gbm93IGlzIHJlY29tbWVuZGVkKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucmVkaXJlY3RVcmwgW29wdGlvbmFsXSAgLSBVcmwgdG8gcmVkaXJlY3QgdG8gYWZ0ZXIgdGhlIHNpZ25lciBpcyBhcHByb3ZlZC4gICoqTm90ZSoqIDogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyBhIHNpZ25lciBmcm9tIGEgbmF0aXZlIG1vYmlsZSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1NpZ25lZEtleVJlcXVlc3RTcG9uc29yfSBwYXJhbXMuc3BvbnNvciBbb3B0aW9uYWxdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHB1YmxpY0tleSA9XG4gICAgICogY29uc3Qgc2lnbmF0dXJlID1cbiAgICAgKiBjb25zdCBhcHBGaWQgPVxuICAgICAqIGNvbnN0IGRlYWRsaW5lID1cbiAgICAgKiBjb25zdCByZWRpcmVjdFVybCA9XG4gICAgICogY29uc3Qgc3BvbnNvciA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucmVnaXN0ZXJTaWduZWRLZXlGb3JEZXZlbG9wZXJNYW5hZ2VkU2lnbmVyKHtwdWJsaWNLZXksIHNpZ25hdHVyZSwgYXBwRmlkLCBkZWFkbGluZSwgcmVkaXJlY3RVcmwsIHNwb25zb3J9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3JlZ2lzdGVyLXNpZ25lZC1rZXktZm9yLWRldmVsb3Blci1tYW5hZ2VkLXNpZ25lcilcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyU2lnbmVkS2V5Rm9yRGV2ZWxvcGVyTWFuYWdlZFNpZ25lcihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgcmVnaXN0ZXJEZXZlbG9wZXJNYW5hZ2VkU2lnbmVkS2V5UmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnNpZ25lckFwaS5yZWdpc3RlclNpZ25lZEtleUZvckRldmVsb3Blck1hbmFnZWRTaWduZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBhcGkgd2lsbCBoZWxwIHlvdSByZW50IHVuaXRzIG9mIHN0b3JhZ2UgZm9yIGFuIHllYXIgZm9yIGEgc3BlY2lmaWMgRklELiBBIHN0b3JhZ2UgdW5pdCBsZXRzIHlvdSBzdG9yZSA1MDAwIGNhc3RzLCAyNTAwIHJlYWN0aW9ucyBhbmQgMjUwMCBsaW5rcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ1eSBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVuaXRzIFtvcHRpb25hbF0gIC0gTnVtYmVyIG9mIHN0b3JhZ2UgdW5pdHMgdG8gYnV5LiBBIHN0b3JhZ2UgdW5pdCBsZXRzIHlvdSBzdG9yZSA1MDAwIGNhc3RzLCAyNTAwIHJlYWN0aW9ucyBhbmQgMjUwMCBsaW5rcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmlkZW0gW29wdGlvbmFsXSAgLSBBbiBJZGVtcG90ZW5jeSBrZXkgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHJlcXVlc3QuICoqTm90ZToqKiAgMSkgVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgZHVwbGljYXRlIHJlcXVlc3RzLiBVc2UgdGhlIHNhbWUgaWRlbSBrZXkgb24gcmV0cnkgYXR0ZW1wdHMuIDIpIFRoaXMgc2hvdWxkIGJlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggcmVxdWVzdC4gMykgUmVjb21tZW5kZWQgZm9ybWF0IGlzIGEgMTYtY2hhcmFjdGVyIHN0cmluZyBnZW5lcmF0ZWQgYnkgdGhlIGRldmVsb3BlciBhdCB0aGUgdGltZSBvZiBtYWtpbmcgdGhpcyByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZUFsbG9jYXRpb25zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgdW5pdHMgPVxuICAgICAqIGNvbnN0IGlkZW0gPVxuICAgICAqXG4gICAgICogY2xpZW50LmJ1eVN0b3JhZ2Uoe2ZpZCwgdW5pdHMsIGlkZW19KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2J1eS1zdG9yYWdlKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgYnV5U3RvcmFnZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgYnV5U3RvcmFnZVJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5zdG9yYWdlQXBpLmJ1eVN0b3JhZ2UoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBzdG9yYWdlIGFsbG9jYXRpb25zIGZvciBhIGdpdmVuIHVzZXJcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEFsbG9jYXRpb24gb2YgdXNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlQWxsb2NhdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VBbGxvY2F0aW9uc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBVc2VyU3RvcmFnZUFsbG9jYXRpb25zKHsgZmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS1hbGxvY2F0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cFVzZXJTdG9yYWdlQWxsb2NhdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnN0b3JhZ2VBcGkubG9va3VwVXNlclN0b3JhZ2VBbGxvY2F0aW9ucyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHN0b3JhZ2UgdXNhZ2UgZm9yIGEgZ2l2ZW4gdXNlclxuICAgICAqXG4gICAgICogQHN1bW1hcnkgVXNhZ2Ugb2YgdXNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlVXNhZ2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VVc2FnZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBVc2VyU3RvcmFnZVVzYWdlKHsgZmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS11c2FnZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cFVzZXJTdG9yYWdlVXNhZ2UocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnN0b3JhZ2VBcGkubG9va3VwVXNlclN0b3JhZ2VVc2FnZShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCB3aGF0IEZJRHMgYW5kIGNvbnRyYWN0cyBhIEZJRCBpcyBzdWJzY3JpYmVkIHRvLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgU3Vic2NyaWJlZCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb25Qcm92aWRlcn0gcGFyYW1zLnN1YnNjcmlwdGlvblByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3Vic2NyaWJlZFRvUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpYmVkVG9SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3Qgc3Vic2NyaXB0aW9uUHJvdmlkZXIgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQoeyBmaWQsIHN1YnNjcmlwdGlvblByb3ZpZGVyLCB2aWV3ZXJGaWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpYmVkLXRvLWZvci1maWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFN1YnNjcmliZWRUb0ZvckZpZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuc3Vic2NyaWJlcnNBcGkuZmV0Y2hTdWJzY3JpYmVkVG9Gb3JGaWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggc3Vic2NyaWJlcnMgZm9yIGEgZ2l2ZW4gRklEXFwncyBjb250cmFjdHMuIERvZXNuXFwndCByZXR1cm4gYWRkcmVzc2VzIHRoYXQgZG9uXFwndCBoYXZlIGFuIEZJRC5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFN1YnNjcmliZXJzIG9mIGEgdXNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb25Qcm92aWRlcnN9IHBhcmFtcy5zdWJzY3JpcHRpb25Qcm92aWRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmliZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdWJzY3JpYmVyc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBzdWJzY3JpcHRpb25Qcm92aWRlciA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFN1YnNjcmliZXJzRm9yRmlkKHsgZmlkLCBzdWJzY3JpcHRpb25Qcm92aWRlciwgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtc3Vic2NyaWJlcnMtZm9yLWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoU3Vic2NyaWJlcnNGb3JGaWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnN1YnNjcmliZXJzQXBpLmZldGNoU3Vic2NyaWJlcnNGb3JGaWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB3YWxsZXQgYWRkcmVzcyBpcyBzdWJzY3JpYmVkIHRvIGEgZ2l2ZW4gU1RQIChIeXBlcnN1YikgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBIeXBlcnN1YiBzdWJzY3JpcHRpb24gY2hlY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuYWRkcmVzc2VzICAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIEV0aGVyZXVtIGFkZHJlc3NlcywgdXAgdG8gMzUwIGF0IGEgdGltZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY29udHJhY3RBZGRyZXNzICAtIEV0aGVyZXVtIGFkZHJlc3Mgb2YgdGhlIFNUUCBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhaW5JZCAgLSBDaGFpbiBJRCBvZiB0aGUgU1RQIGNvbnRyYWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdWJzY3JpcHRpb25DaGVja1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3Vic2NyaXB0aW9uQ2hlY2tSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGFkZHJlc3NlcyA9XG4gICAgICogY29uc3QgY29udHJhY3RBZGRyZXNzID1cbiAgICAgKiBjb25zdCBjaGFpbklkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFN1YnNjcmlwdGlvbkNoZWNrKHsgYWRkcmVzc2VzLCBjb250cmFjdEFkZHJlc3MsIGNoYWluSWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpcHRpb24tY2hlY2spXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFN1YnNjcmlwdGlvbkNoZWNrKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzICYmIEFycmF5LmlzQXJyYXkoYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzKSkge1xuICAgICAgICAgICAgYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzID0gYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnN1YnNjcmliZXJzQXBpLmZldGNoU3Vic2NyaXB0aW9uQ2hlY2soYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY3JlYXRlZCBzdWJzY3JpcHRpb25zIGZvciBhIGdpdmVuIEZJRFxcJ3MuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTdWJzY3JpcHRpb25zIGNyZWF0ZWQgYnkgRklEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWRcbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvblByb3ZpZGVyfSBwYXJhbXMuc3Vic2NyaXB0aW9uUHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN1YnNjcmlwdGlvbnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN1YnNjcmlwdGlvbnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3Qgc3Vic2NyaXB0aW9uUHJvdmlkZXIgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZCh7IGZpZCwgc3Vic2NyaXB0aW9uUHJvdmlkZXIgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1zdWJzY3JpcHRpb25zLWZvci1maWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFN1YnNjcmlwdGlvbnNGb3JGaWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnN1YnNjcmliZXJzQXBpLmZldGNoU3Vic2NyaXB0aW9uc0ZvckZpZChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3MgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGRlbGV0ZSB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRGVsZXRlIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyAgLSBFdGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ibG9ja0hhc2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9wZXJhdGlvblJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgT3BlcmF0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBzaWduZXJVdWlkID1cbiAgICAgKiBjb25zdCBhZGRyZXNzID1cbiAgICAgKiBjb25zdCBibG9ja0hhc2ggPVxuICAgICAqXG4gICAgICogY2xpZW50LmRlbGV0ZVZlcmlmaWNhdGlvbih7c2lnbmVyVXVpZCwgYWRkcmVzcywgYmxvY2tIYXNofSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtdmVyaWZpY2F0aW9uKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVmVyaWZpY2F0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyByZW1vdmVWZXJpZmljYXRpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5kZWxldGVWZXJpZmljYXRpb24oYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBtdWx0aXBsZSB1c2VycyBiYXNlZCBvbiBGSURzXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCeSBGSURzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcGFyYW1zLmZpZHMgIC0gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgRklEcywgdXAgdG8gMTAwIGF0IGEgdGltZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1bGtVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa1VzZXJzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWRzID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQnVsa1VzZXJzKHsgZmlkcywgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2VycylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQnVsa1VzZXJzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5tYXAodmFsdWUgPT4gKFN0cmluZyh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuZmlkcyAmJiBBcnJheS5pc0FycmF5KGFkanVzdGVkUGFyYW1zLmZpZHMpKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFBhcmFtcy5maWRzID0gYWRqdXN0ZWRQYXJhbXMuZmlkcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy51c2VyQXBpLmZldGNoQnVsa1VzZXJzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYWxsIHVzZXJzIGJhc2VkIG9uIG11bHRpcGxlIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuICBFYWNoIGZhcmNhc3RlciB1c2VyIGhhcyBhIGN1c3RvZHkgRXRoZXJldW0gYWRkcmVzcyBhbmQgb3B0aW9uYWxseSB2ZXJpZmllZCBFdGhlcmV1bSBvciBTb2xhbmEgYWRkcmVzc2VzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgYWxsIHVzZXJzIHRoYXQgaGF2ZSBhbnkgb2YgdGhlIGdpdmVuIGFkZHJlc3NlcyBhcyB0aGVpciBjdXN0b2R5IG9yIHZlcmlmaWVkIEV0aGVyZXVtIG9yIFNvbGFuYSBhZGRyZXNzZXMuICBBIGN1c3RvZHkgYWRkcmVzcyBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIG9ubHkgMSBmYXJjYXN0ZXIgdXNlciBhdCBhIHRpbWUgYnV0IGEgdmVyaWZpZWQgYWRkcmVzcyBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIG11bHRpcGxlIHVzZXJzLiBZb3UgY2FuIHBhc3MgaW4gRXRoZXJldW0gYW5kIFNvbGFuYSBhZGRyZXNzZXMsIGNvbW1hIHNlcGFyYXRlZCwgaW4gdGhlIHNhbWUgcmVxdWVzdC4gVGhlIHJlc3BvbnNlIHdpbGwgY29udGFpbiB1c2VycyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFkZHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ5IEV0aCBvciBTb2wgYWRkcmVzc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmFkZHJlc3NlcyAgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBFdGhlcmV1bSBhZGRyZXNzZXMsIHVwIHRvIDM1MCBhdCBhIHRpbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEJ1bGtVc2VyQWRkcmVzc1R5cGU+fSBwYXJhbXMuYWRkcmVzc1R5cGVzIFtvcHRpb25hbF0gIC0gQ3VzdG9taXplIHdoaWNoIGFkZHJlc3MgdHlwZXMgdGhlIHJlcXVlc3Qgc2hvdWxkIHNlYXJjaCBmb3IuIFRoaXMgaXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIHRoYXQgY2FuIGluY2x1ZGUgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICdjdXN0b2R5X2FkZHJlc3MnIGFuZCAndmVyaWZpZWRfYWRkcmVzcycuIEJ5IGRlZmF1bHQgYXBpIHJldHVybnMgYm90aC4gVG8gc2VsZWN0IG11bHRpcGxlIHR5cGVzLCB1c2UgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGVzZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzQnlBZGRyZXNzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNCeUFkZHJlc3NSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGFkZHJlc3NlcyA9XG4gICAgICogY29uc3QgYWRkcmVzc1R5cGVzID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQnVsa1VzZXJzQnlFdGhPclNvbEFkZHJlc3MoeyBhZGRyZXNzZXMsIGFkZHJlc3NUeXBlcywgdmlld2VyRmlkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtYnVsay11c2Vycy1ieS1ldGgtb3Itc29sLWFkZHJlc3MpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEJ1bGtVc2Vyc0J5RXRoT3JTb2xBZGRyZXNzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBpZiAoYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzICYmIEFycmF5LmlzQXJyYXkoYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzKSkge1xuICAgICAgICAgICAgYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzID0gYWRqdXN0ZWRQYXJhbXMuYWRkcmVzc2VzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkuZmV0Y2hCdWxrVXNlcnNCeUV0aE9yU29sQWRkcmVzcyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHBvd2VyIHVzZXJzIGJhc2VkIG9uIFdhcnBjYXN0IHBvd2VyIGJhZGdlcy4gSW5mb3JtYXRpb24gaXMgdXBkYXRlZCBvbmNlIGEgZGF5LlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUG93ZXIgdXNlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiBwb3dlciB1c2VycyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqIGNvbnN0IGxpbWl0ID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFBvd2VyVXNlcnMoeyB2aWV3ZXJGaWQsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcG93ZXItdXNlcnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFBvd2VyVXNlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkuZmV0Y2hQb3dlclVzZXJzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgcG93ZXIgdXNlcnMgYW5kIHJlc3BvbmQgaW4gYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmb3JtYXQgdG8gV2FycGNhc3RcXCdzIGRlcHJlY2F0ZWQgcG93ZXIgYmFkZ2UgZW5kcG9pbnQuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBQb3dlciB1c2VyIEZJRHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJQb3dlckxpdGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJQb3dlckxpdGVSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoUG93ZXJVc2Vyc0xpdGUoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXBvd2VyLXVzZXJzLWxpdGUpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFBvd2VyVXNlcnNMaXRlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy51c2VyQXBpLmZldGNoUG93ZXJVc2Vyc0xpdGUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGxpc3Qgb2YgdXNlcnMgZ2l2ZW4gYSBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhdGl0dWRlICAtIExhdGl0dWRlIG9mIHRoZSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubG9uZ2l0dWRlICAtIExvbmdpdHVkZSBvZiB0aGUgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZpZXdlckZpZCBbb3B0aW9uYWxdICAtIEZJRCBvZiB0aGUgdXNlciB2aWV3aW5nIHRoZSBmZWVkLiBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBhIGxpc3Qgb2YgdXNlcnMgdGhhdCByZXNwZWN0cyB0aGlzIHVzZXIncyBtdXRlcyBhbmQgYmxvY2tzIGFuZCBpbmNsdWRlcyBgdmlld2VyX2NvbnRleHRgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGltaXQgW29wdGlvbmFsXSAgLSBOdW1iZXIgb2YgcmVzdWx0cyB0byBmZXRjaCAoRGVmYXVsdDogMjUsIE1heGltdW06IDEwMClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmN1cnNvciBbb3B0aW9uYWxdICAtIFBhZ2luYXRpb24gY3Vyc29yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGxhdGl0dWRlID1cbiAgICAgKiBjb25zdCBsb25naXR1ZGUgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlcnNCeUxvY2F0aW9uKHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdmlld2VyRmlkLCBsaW1pdCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWJ5LWxvY2F0aW9uKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2Vyc0J5TG9jYXRpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkuZmV0Y2hVc2Vyc0J5TG9jYXRpb24oYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9sbG93IGEgdXNlciBcXFxcIChJbiBvcmRlciB0byBmb2xsb3cgYSB1c2VyIGBzaWduZXJfdXVpZGAgbXVzdCBiZSBhcHByb3ZlZClcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZvbGxvdyB1c2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaWduZXJVdWlkICAtIFVVSUQgb2YgdGhlIHNpZ25lci4gYHNpZ25lcl91dWlkYCBpcyBwYWlyZWQgd2l0aCBBUEkga2V5LCBjYW4ndCB1c2UgYSBgdXVpZGAgbWFkZSB3aXRoIGEgZGlmZmVyZW50IEFQSSBrZXkuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMudGFyZ2V0Rmlkc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa0ZvbGxvd1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0ZvbGxvd1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgdGFyZ2V0RmlkcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZm9sbG93VXNlcih7c2lnbmVyVXVpZCwgdGFyZ2V0Rmlkc30pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZm9sbG93LXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmb2xsb3dVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBmb2xsb3dSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5mb2xsb3dVc2VyKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgRklEIHRvIFthc3NpZ24gaXQgdG8gbmV3IHVzZXJdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50KVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggZnJlc2ggRklEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyRklEUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyRklEUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIGNsaWVudC5nZXRGcmVzaEFjY291bnRGSUQoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2dldC1mcmVzaC1hY2NvdW50LWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZyZXNoQWNjb3VudEZJRCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgYWRqdXN0ZWRQYXJhbXNbJ3hOZXluYXJFeHBlcmltZW50YWwnXSA9IChfYiA9IChfYSA9IHRoaXMuY29uZmlnLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWyd4LW5leW5hci1leHBlcmltZW50YWwnXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5nZXRGcmVzaEFjY291bnRGSUQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgdXNlciBieSBjdXN0b2R5LWFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ5IGN1c3RvZHktYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY3VzdG9keUFkZHJlc3MgIC0gQ3VzdG9keSBBZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBtbmVtb25pY1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlclJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgY3VzdG9keUFkZHJlc3MgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFVzZXJCeUN1c3RvZHlBZGRyZXNzKHsgY3VzdG9keUFkZHJlc3MgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1ieS1jdXN0b2R5LWFkZHJlc3MpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBsb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5sb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgc2luZ2xlIGh5ZHJhdGVkIHVzZXIgb2JqZWN0IGdpdmVuIGEgdXNlcm5hbWVcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEJ5IHVzZXJuYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51c2VybmFtZSAgLSBVc2VybmFtZSBvZiB0aGUgdXNlciB0byBmZXRjaFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmlld2VyRmlkIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHVzZXJuYW1lID1cbiAgICAgKiBjb25zdCB2aWV3ZXJGaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFVzZXJCeVVzZXJuYW1lKHsgdXNlcm5hbWUsIHZpZXdlckZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLWJ5LXVzZXJuYW1lKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwVXNlckJ5VXNlcm5hbWUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkubG9va3VwVXNlckJ5VXNlcm5hbWUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgdXNlcnMgd2hvIGhhdmUgdmVyaWZpZWQgdGhlIHNwZWNpZmllZCBYIChUd2l0dGVyKSB1c2VybmFtZVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgWCB1c2VybmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMueFVzZXJuYW1lICAtIFggKFR3aXR0ZXIpIHVzZXJuYW1lIHRvIHNlYXJjaCBmb3IsIHdpdGhvdXQgdGhlIEAgc3ltYm9sXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBGSUQgb2YgdGhlIHZpZXdlciBmb3IgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBsaWtlIGZvbGxvd3MgYW5kIGJsb2Nrc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa1VzZXJzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBCdWxrVXNlcnNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHhVc2VybmFtZSA9XG4gICAgICogY29uc3Qgdmlld2VyRmlkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBVc2Vyc0J5WFVzZXJuYW1lKHsgeFVzZXJuYW1lLCB2aWV3ZXJGaWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlcnMtYnkteC11c2VybmFtZSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cFVzZXJzQnlYVXNlcm5hbWUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGFkanVzdGVkUGFyYW1zWyd4TmV5bmFyRXhwZXJpbWVudGFsJ10gPSAoX2IgPSAoX2EgPSB0aGlzLmNvbmZpZy5iYXNlT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsneC1uZXluYXItZXhwZXJpbWVudGFsJ107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkubG9va3VwVXNlcnNCeVhVc2VybmFtZShhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHZlcmlmaWNhdGlvbiBmb3IgYW4gZXRoIGFkZHJlc3Mgb3IgY29udHJhY3QgZm9yIHRoZSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIGFkZCB2ZXJpZmljYXRpb24gYHNpZ25lcl91dWlkYCBtdXN0IGJlIGFwcHJvdmVkKVxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQWRkIHZlcmlmaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2lnbmVyVXVpZCAgLSBVVUlEIG9mIHRoZSBzaWduZXIuIGBzaWduZXJfdXVpZGAgaXMgcGFpcmVkIHdpdGggQVBJIGtleSwgY2FuJ3QgdXNlIGEgYHV1aWRgIG1hZGUgd2l0aCBhIGRpZmZlcmVudCBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyAgLSBFdGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ibG9ja0hhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmV0aFNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7VmVyaWZpY2F0aW9uVHlwZX0gcGFyYW1zLnZlcmlmaWNhdGlvblR5cGUgW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7VmVyaWZpY2F0aW9uQ2hhaW5JZH0gcGFyYW1zLmNoYWluSWQgW29wdGlvbmFsXVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T3BlcmF0aW9uUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPcGVyYXRpb25SZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHNpZ25lclV1aWQgPVxuICAgICAqIGNvbnN0IGFkZHJlc3MgPVxuICAgICAqIGNvbnN0IGJsb2NrSGFzaCA9XG4gICAgICogY29uc3QgZXRoU2lnbmF0dXJlID1cbiAgICAgKiBjb25zdCB2ZXJpZmljYXRpb25UeXBlID1cbiAgICAgKiBjb25zdCBjaGFpbklkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5wdWJsaXNoVmVyaWZpY2F0aW9uKHtzaWduZXJVdWlkLCBhZGRyZXNzLCBibG9ja0hhc2gsIGV0aFNpZ25hdHVyZSwgdmVyaWZpY2F0aW9uVHlwZSwgY2hhaW5JZH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvcHVibGlzaC12ZXJpZmljYXRpb24pXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBwdWJsaXNoVmVyaWZpY2F0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBhZGRWZXJpZmljYXRpb25SZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5wdWJsaXNoVmVyaWZpY2F0aW9uKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFjY291bnQgb24gZmFyY2FzdGVyLiAgKipOb3RlOioqIFRoaXMgQVBJIG11c3QgYmUgY2FsbGVkIHdpdGhpbiAxMCBtaW51dGVzIG9mIHRoZSBmZXRjaCBGSUQgQVBJIGNhbGwgKGkuZS4sIC92Mi9mYXJjYXN0ZXIvdXNlci9maWQpLiBPdGhlcndpc2UsIE5leW5hciB3aWxsIGFzc2lnbiB0aGlzIEZJRCB0byBhbm90aGVyIGF2YWlsYWJsZSB1c2VyLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgbmV3IGFjY291bnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5yZXF1ZXN0ZWRVc2VyQ3VzdG9keUFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmRlYWRsaW5lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mbmFtZSBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtSZWdpc3RlclVzZXJSZXFCb2R5TWV0YWRhdGF9IHBhcmFtcy5tZXRhZGF0YSBbb3B0aW9uYWxdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWdpc3RlclVzZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlZ2lzdGVyVXNlclJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmF0dXJlID1cbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHJlcXVlc3RlZFVzZXJDdXN0b2R5QWRkcmVzcyA9XG4gICAgICogY29uc3QgZGVhZGxpbmUgPVxuICAgICAqIGNvbnN0IGZuYW1lID1cbiAgICAgKiBjb25zdCBtZXRhZGF0YSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucmVnaXN0ZXJBY2NvdW50KHtzaWduYXR1cmUsIGZpZCwgcmVxdWVzdGVkVXNlckN1c3RvZHlBZGRyZXNzLCBkZWFkbGluZSwgZm5hbWUsIG1ldGFkYXRhfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9yZWdpc3Rlci1hY2NvdW50KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJBY2NvdW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyByZWdpc3RlclVzZXJSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS5yZWdpc3RlckFjY291bnQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBVc2VybmFtZXNcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFNlYXJjaCBmb3IgVXNlcm5hbWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5xXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52aWV3ZXJGaWQgW29wdGlvbmFsXSAgLSBQcm92aWRpbmcgdGhpcyB3aWxsIHJldHVybiBzZWFyY2ggcmVzdWx0cyB0aGF0IHJlc3BlY3RzIHRoaXMgdXNlcidzIG11dGVzIGFuZCBibG9ja3MgYW5kIGluY2x1ZGVzIGB2aWV3ZXJfY29udGV4dGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5saW1pdCBbb3B0aW9uYWxdICAtIE51bWJlciBvZiB1c2VycyB0byBmZXRjaCAoRGVmYXVsdDogNSwgTWF4aW11bTogMTApXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jdXJzb3IgW29wdGlvbmFsXSAgLSBQYWdpbmF0aW9uIGN1cnNvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJTZWFyY2hSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJTZWFyY2hSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHEgPVxuICAgICAqIGNvbnN0IHZpZXdlckZpZCA9XG4gICAgICogY29uc3QgbGltaXQgPVxuICAgICAqXG4gICAgICogY2xpZW50LnNlYXJjaFVzZXIoeyBxLCB2aWV3ZXJGaWQsIGxpbWl0IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc2VhcmNoLXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hVc2VyKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBhZGp1c3RlZFBhcmFtc1sneE5leW5hckV4cGVyaW1lbnRhbCddID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuYmFzZU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbJ3gtbmV5bmFyLWV4cGVyaW1lbnRhbCddO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy51c2VyQXBpLnNlYXJjaFVzZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5mb2xsb3cgYSB1c2VyIFxcXFwgKEluIG9yZGVyIHRvIHVuZm9sbG93IGEgdXNlciBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVbmZvbGxvdyB1c2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaWduZXJVdWlkICAtIFVVSUQgb2YgdGhlIHNpZ25lci4gYHNpZ25lcl91dWlkYCBpcyBwYWlyZWQgd2l0aCBBUEkga2V5LCBjYW4ndCB1c2UgYSBgdXVpZGAgbWFkZSB3aXRoIGEgZGlmZmVyZW50IEFQSSBrZXkuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMudGFyZ2V0Rmlkc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QnVsa0ZvbGxvd1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQnVsa0ZvbGxvd1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgdGFyZ2V0RmlkcyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQudW5mb2xsb3dVc2VyKHtzaWduZXJVdWlkLCB0YXJnZXRGaWRzfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91bmZvbGxvdy11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgdW5mb2xsb3dVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyBmb2xsb3dSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMudXNlckFwaS51bmZvbGxvd1VzZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHVzZXIgcHJvZmlsZSBcXFxcIChJbiBvcmRlciB0byB1cGRhdGUgdXNlclxcJ3MgcHJvZmlsZSBgc2lnbmVyX3V1aWRgIG11c3QgYmUgYXBwcm92ZWQpXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGUgdXNlciBwcm9maWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaWduZXJVdWlkICAtIFVVSUQgb2YgdGhlIHNpZ25lci4gYHNpZ25lcl91dWlkYCBpcyBwYWlyZWQgd2l0aCBBUEkga2V5LCBjYW4ndCB1c2UgYSBgdXVpZGAgbWFkZSB3aXRoIGEgZGlmZmVyZW50IEFQSSBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5iaW8gW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucGZwVXJsIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVybCBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51c2VybmFtZSBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kaXNwbGF5TmFtZSBbb3B0aW9uYWxdXG4gICAgICogQHBhcmFtIHtVcGRhdGVVc2VyUmVxQm9keUxvY2F0aW9ufSBwYXJhbXMubG9jYXRpb24gW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7VXBkYXRlVXNlclJlcUJvZHlWZXJpZmllZEFjY291bnRzfSBwYXJhbXMudmVyaWZpZWRBY2NvdW50cyBbb3B0aW9uYWxdXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVyYXRpb25SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9wZXJhdGlvblJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2lnbmVyVXVpZCA9XG4gICAgICogY29uc3QgYmlvID1cbiAgICAgKiBjb25zdCBwZnBVcmwgPVxuICAgICAqIGNvbnN0IHVybCA9XG4gICAgICogY29uc3QgdXNlcm5hbWUgPVxuICAgICAqIGNvbnN0IGRpc3BsYXlOYW1lID1cbiAgICAgKiBjb25zdCBsb2NhdGlvbiA9XG4gICAgICogY29uc3QgdmVyaWZpZWRBY2NvdW50cyA9XG4gICAgICpcbiAgICAgKiBjbGllbnQudXBkYXRlVXNlcih7c2lnbmVyVXVpZCwgYmlvLCBwZnBVcmwsIHVybCwgdXNlcm5hbWUsIGRpc3BsYXlOYW1lLCBsb2NhdGlvbiwgdmVyaWZpZWRBY2NvdW50c30pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdXBkYXRlLXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyB1cGRhdGVVc2VyUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJBcGkudXBkYXRlVXNlcihhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy53ZWJob29rSWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IHdlYmhvb2tJZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZGVsZXRlV2ViaG9vayh7d2ViaG9va0lkfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9kZWxldGUtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVdlYmhvb2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IHdlYmhvb2tEZWxldGVSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMud2ViaG9va0FwaS5kZWxldGVXZWJob29rKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiB3ZWJob29rcyBhc3NvY2lhdGVkIHRvIGEgdXNlclxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQXNzb2NpYXRlZCB3ZWJob29rcyBvZiB1c2VyXG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tMaXN0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rTGlzdFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoV2ViaG9va3MoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXdlYmhvb2tzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hXZWJob29rcygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMud2ViaG9va0FwaS5mZXRjaFdlYmhvb2tzKCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIHdlYmhvb2tcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgd2ViaG9va1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViaG9va0lkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB3ZWJob29rSWQgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFdlYmhvb2soeyB3ZWJob29rSWQgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cFdlYmhvb2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLndlYmhvb2tBcGkubG9va3VwV2ViaG9vayhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3ZWJob29rXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSB3ZWJob29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51cmxcbiAgICAgKiBAcGFyYW0ge1dlYmhvb2tTdWJzY3JpcHRpb25GaWx0ZXJzfSBwYXJhbXMuc3Vic2NyaXB0aW9uIFtvcHRpb25hbF1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFdlYmhvb2tSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFdlYmhvb2tSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IG5hbWUgPVxuICAgICAqIGNvbnN0IHVybCA9XG4gICAgICogY29uc3Qgc3Vic2NyaXB0aW9uID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5wdWJsaXNoV2ViaG9vayh7bmFtZSwgdXJsLCBzdWJzY3JpcHRpb259KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3B1Ymxpc2gtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHB1Ymxpc2hXZWJob29rKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBjb25zdCBfcGFyYW1zID0geyB3ZWJob29rUG9zdFJlcUJvZHk6IGNhbWVsQ2FzZVRvU25ha2VDYXNlS2V5cyhwYXJhbXMpIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIF9wYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy53ZWJob29rQXBpLnB1Ymxpc2hXZWJob29rKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVybFxuICAgICAqIEBwYXJhbSB7V2ViaG9va1N1YnNjcmlwdGlvbkZpbHRlcnN9IHBhcmFtcy5zdWJzY3JpcHRpb24gW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViaG9va0lkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWJob29rUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBXZWJob29rUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBuYW1lID1cbiAgICAgKiBjb25zdCB1cmwgPVxuICAgICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9XG4gICAgICogY29uc3Qgd2ViaG9va0lkID1cbiAgICAgKlxuICAgICAqIGNsaWVudC51cGRhdGVXZWJob29rKHtuYW1lLCB1cmwsIHN1YnNjcmlwdGlvbiwgd2ViaG9va0lkfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vaylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVdlYmhvb2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IF9wYXJhbXMgPSB7IHdlYmhvb2tQdXRSZXFCb2R5OiBjYW1lbENhc2VUb1NuYWtlQ2FzZUtleXMocGFyYW1zKSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBfcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMud2ViaG9va0FwaS51cGRhdGVXZWJob29rKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3ZWJob29rIGFjdGl2ZSBzdGF0dXNcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSB3ZWJob29rIHN0YXR1c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViaG9va0lkXG4gICAgICogQHBhcmFtIHtXZWJob29rUGF0Y2hSZXFCb2R5QWN0aXZlRW51bX0gcGFyYW1zLmFjdGl2ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8V2ViaG9va1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgV2ViaG9va1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgd2ViaG9va0lkID1cbiAgICAgKiBjb25zdCBhY3RpdmUgPVxuICAgICAqXG4gICAgICogY2xpZW50LnVwZGF0ZVdlYmhvb2tBY3RpdmVTdGF0dXMoe3dlYmhvb2tJZCwgYWN0aXZlfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS91cGRhdGUtd2ViaG9vay1hY3RpdmUtc3RhdHVzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHsgd2ViaG9va1BhdGNoUmVxQm9keTogY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKHBhcmFtcykgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgX3BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLndlYmhvb2tBcGkudXBkYXRlV2ViaG9va0FjdGl2ZVN0YXR1cyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzaWduZXIgYW5kIHJlZ2lzdGVycyBhIHNpZ25lZCBrZXkgZm9yIHRoZSBzaWduZXIuXG4gICAgICAgKiBJdCByZXR1cm5zIGEgU2lnbmVyIHdoaWNoIGluY2x1ZGVzIGBzaWduZXJfYXBwcm92YWxfdXJsYCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIFFSIENvZGUgZm9yIHRoZSB1c2VyIHRvIHNjYW4gYW5kIGFwcHJvdmUgdGhlIHNpZ25lci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmFyY2FzdGVyRGV2ZWxvcGVyTW5lbW9uaWNdIC0gbW5lbW9uaWMgb2YgdGhlIGZhcmNhc3RlciBkZXZlbG9wZXIgYWNjb3VudFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlYWRsaW5lXSAtIChPcHRpb25hbCkgVW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kcyB0aGF0IGNvbnRyb2xzIGhvdyBsb25nIHRoZSBzaWduZWQga2V5XG4gICAgICAgKiAgIHJlcXVlc3QgaXMgdmFsaWQgZm9yLiBBIDI0LWhvdXIgZHVyYXRpb24gZnJvbSBub3cgaXMgcmVjb21tZW5kZWQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU2lnbmVyYCBvYmplY3QsXG4gICAgICAgKiAgIHRoYXQgaW5jbHVkZXMgc2lnbmVyX2FwcHJvdmFsX3VybC5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IGZhcmNhc3RlckRldmVsb3Blck1uZW1vbmljID1cbiAgICAgICAqIGNvbnN0IGRlYWRsaW5lID1cbiAgICAgICAqXG4gICAgICAgKiBjbGllbnQuY3JlYXRlU2lnbmVyQW5kUmVnaXN0ZXJTaWduZWRLZXkoeyBmYXJjYXN0ZXJEZXZlbG9wZXJNbmVtb25pYywgZGVhZGxpbmU6IDE2OTM5Mjc2NjUgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgKiAgIGNvbnNvbGUubG9nKCdTaWduZXInLCByZXNwb25zZSk7XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNpZ25lckFuZFJlZ2lzdGVyU2lnbmVkS2V5KHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGZhcmNhc3RlckRldmVsb3Blck1uZW1vbmljLCBkZWFkbGluZSB9ID0gcGFyYW1zO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBwdWJsaWNfa2V5OiBzaWduZXJQdWJsaWNLZXksIHNpZ25lcl91dWlkIH0gPSBhd2FpdCB0aGlzLmNyZWF0ZVNpZ25lcigpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9ICgwLCBhY2NvdW50c18xLm1uZW1vbmljVG9BY2NvdW50KShmYXJjYXN0ZXJEZXZlbG9wZXJNbmVtb25pYyk7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXI6IGZhcmNhc3RlckRldmVsb3BlciB9ID0gYXdhaXQgdGhpcy5sb29rdXBVc2VyQnlDdXN0b2R5QWRkcmVzcyh7XG4gICAgICAgICAgICAgICAgY3VzdG9keUFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGVzIGFuIGV4cGlyYXRpb24gZGF0ZSBmb3IgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgICAgLy8gZS5nLiAxNjkzOTI3NjY1XG4gICAgICAgICAgICBjb25zdCBzaWduZWRfa2V5X2RlYWRsaW5lID0gZGVhZGxpbmUgIT09IG51bGwgJiYgZGVhZGxpbmUgIT09IHZvaWQgMCA/IGRlYWRsaW5lIDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyA4NjQwMDsgLy8gc2lnbmF0dXJlIGlzIHZhbGlkIGZvciAxIGRheSBmcm9tIG5vd1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGF3YWl0IGFjY291bnQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBjb25zdGFudHNfMS5TSUdORURfS0VZX1JFUVVFU1RfVkFMSURBVE9SX0VJUF83MTJfRE9NQUlOLFxuICAgICAgICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFNpZ25lZEtleVJlcXVlc3Q6IGNvbnN0YW50c18xLlNJR05FRF9LRVlfUkVRVUVTVF9UWVBFLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpbWFyeVR5cGU6IFwiU2lnbmVkS2V5UmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEZpZDogQmlnSW50KGZhcmNhc3RlckRldmVsb3Blci5maWQpLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IHNpZ25lclB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgZGVhZGxpbmU6IEJpZ0ludChzaWduZWRfa2V5X2RlYWRsaW5lKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgc2lnbmVyX3BlbmRpbmcgPSBhd2FpdCB0aGlzLnJlZ2lzdGVyU2lnbmVkS2V5KHtcbiAgICAgICAgICAgICAgICBzaWduZXJVdWlkOiBzaWduZXJfdXVpZCxcbiAgICAgICAgICAgICAgICBhcHBGaWQ6IGZhcmNhc3RlckRldmVsb3Blci5maWQsXG4gICAgICAgICAgICAgICAgZGVhZGxpbmU6IHNpZ25lZF9rZXlfZGVhZGxpbmUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmVyX3BlbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzQXBpRXJyb3JSZXNwb25zZSkoZXJyKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVyci5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5OZXluYXJBUElDbGllbnQgPSBOZXluYXJBUElDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarAPIClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarHubClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/clients/NeynarHubClient.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NeynarHubClient = void 0;\nconst logger_1 = __webpack_require__(/*! ../common/logger */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/logger.js\");\nconst axios_1 = __importStar(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nconst configuration_1 = __webpack_require__(/*! ../hub-api/configuration */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/configuration.js\");\nconst casts_api_1 = __webpack_require__(/*! ../hub-api/apis/casts-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/casts-api.js\");\nconst fids_api_1 = __webpack_require__(/*! ../hub-api/apis/fids-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/fids-api.js\");\nconst hub_events_api_1 = __webpack_require__(/*! ../hub-api/apis/hub-events-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/hub-events-api.js\");\nconst info_api_1 = __webpack_require__(/*! ../hub-api/apis/info-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/info-api.js\");\nconst links_api_1 = __webpack_require__(/*! ../hub-api/apis/links-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/links-api.js\");\nconst message_api_1 = __webpack_require__(/*! ../hub-api/apis/message-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/message-api.js\");\nconst on_chain_events_api_1 = __webpack_require__(/*! ../hub-api/apis/on-chain-events-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/on-chain-events-api.js\");\nconst reactions_api_1 = __webpack_require__(/*! ../hub-api/apis/reactions-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/reactions-api.js\");\nconst storage_api_1 = __webpack_require__(/*! ../hub-api/apis/storage-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/storage-api.js\");\nconst user_data_api_1 = __webpack_require__(/*! ../hub-api/apis/user-data-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/user-data-api.js\");\nconst usernames_api_1 = __webpack_require__(/*! ../hub-api/apis/usernames-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/usernames-api.js\");\nconst verifications_api_1 = __webpack_require__(/*! ../hub-api/apis/verifications-api */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/verifications-api.js\");\nconst { version: sdkVersion } = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/package.json\");\n/**\n * Converts a camelCase string to snake_case.\n * If the input string is not in camelCase format, it returns the original string.\n *\n * @param {string} str - The string to convert.\n * @returns {string} The converted string in snake_case, or the original string if not camelCase.\n */\nfunction camelToSnakeCase(str) {\n    // Check if the string is camelCase\n    if (/^[a-z]+([A-Z][a-z]*)+$/.test(str)) {\n        return str.replace(/([A-Z])/g, '_$1').toLowerCase();\n    }\n    return str; // Return the original string if it's not camelCase\n}\n/**\n * Converts the top-level keys of an object from camelCase to snake_case.\n * If a key is not in camelCase, it retains its original format.\n * Nested objects or arrays are left unchanged.\n * This is done to revert the conversion of top-level keys since we accept snake_case keys in the API but convert them to camelCase in the wrapper.\n *\n * @param {object} obj - The object whose top-level keys are to be converted.\n * @returns {object} A new object with top-level keys converted to snake_case.\n */\nfunction camelCaseToSnakeCaseKeys(obj) {\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {\n        // Convert only the top-level keys\n        return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n            camelToSnakeCase(key), // Convert only camelCase keys\n            value, // Leave the value untouched\n        ]));\n    }\n    return obj; // If not an object, return as is\n}\nclass NeynarHubClient {\n    constructor(config, options = {}) {\n        if (typeof config === 'string') {\n            console.error('Error: config must be of type Configuration');\n            console.log(`\nSeems, like you are using sdk v2 but the syntax on client instantiation is for sdk v1.\nSDK v1 -> v2 migration guide: https://docs.neynar.com/reference/neynar-nodejs-sdk-v1-to-v2-migration-guide\n\nCorrect usage way to instantiate the client:\n\nimport { NeynarHubClient, Configuration } from \"@neynar/nodejs-sdk\";\n\nconst config = new Configuration({\n  apiKey: \"API_KEY\",\n  baseOptions: {\n    headers: {\n      \"x-neynar-experimental\": true,\n    },\n  },\n});\n\nconst client = new NeynarHubClient(config);\\n`);\n            throw new Error('Invalid configuration type. Expected Configuration object but received string.');\n        }\n        const { logger = logger_1.silentLogger, axiosInstance: customAxiosInstance } = options;\n        this.logger = logger;\n        this.config = new configuration_1.Configuration({\n            apiKey: config.apiKey,\n            basePath: config.basePath,\n            baseOptions: config.baseOptions,\n        });\n        const axiosInstance = customAxiosInstance || axios_1.default.create({\n            headers: {\n                \"x-sdk-version\": sdkVersion,\n                \"x-sdk\": \"node\"\n            },\n        });\n        axiosInstance.defaults.decompress = true;\n        axiosInstance.interceptors.response.use((response) => response, (error) => {\n            if (error.response && [302].includes(error.response.status)) {\n                return {\n                    data: {\n                        location: error.response.headers.location,\n                    },\n                };\n            }\n            if (NeynarHubClient.isApiErrorResponse(error)) {\n                const apiErrors = error.response.data;\n                this.logger.warn(`API errors: ${JSON.stringify(apiErrors)}`);\n            }\n            throw error;\n        });\n        this.apis = {\n            castsApi: new casts_api_1.CastsApi(this.config, undefined, axiosInstance),\n            fidsApi: new fids_api_1.FidsApi(this.config, undefined, axiosInstance),\n            hubEventsApi: new hub_events_api_1.HubEventsApi(this.config, undefined, axiosInstance),\n            infoApi: new info_api_1.InfoApi(this.config, undefined, axiosInstance),\n            linksApi: new links_api_1.LinksApi(this.config, undefined, axiosInstance),\n            messageApi: new message_api_1.MessageApi(this.config, undefined, axiosInstance),\n            onChainEventsApi: new on_chain_events_api_1.OnChainEventsApi(this.config, undefined, axiosInstance),\n            reactionsApi: new reactions_api_1.ReactionsApi(this.config, undefined, axiosInstance),\n            storageApi: new storage_api_1.StorageApi(this.config, undefined, axiosInstance),\n            userDataApi: new user_data_api_1.UserDataApi(this.config, undefined, axiosInstance),\n            usernamesApi: new usernames_api_1.UsernamesApi(this.config, undefined, axiosInstance),\n            verificationsApi: new verifications_api_1.VerificationsApi(this.config, undefined, axiosInstance),\n        };\n    }\n    static isApiErrorResponse(error) {\n        var _a;\n        if (!(error instanceof axios_1.AxiosError))\n            return false;\n        return (((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== undefined && \"message\" in error.response.data);\n    }\n    /**\n     * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.\n     *\n     * @summary By parent cast\n     *\n     * @param {object} params\n     * @param {number} params.fid [optional]  - The Farcaster ID (FID) of the parent cast's creator. This parameter must be used together with the 'hash' parameter to uniquely identify a parent cast. Required only when using hash-based lookup instead of URL-based lookup. The FID is a unique identifier assigned to each Farcaster user.\n     * @param {string} params.hash [optional]  - The unique hash identifier of the parent cast. Must be used together with the 'fid' parameter when doing hash-based lookup. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies the cast within the creator's posts. Not required if using URL-based lookup.\n     * @param {string} params.url [optional]  - Cast URL starting with 'chain://'\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const hash =\n     * const url =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchCastsByParent({ fid, hash, url, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)\n     *\n     */\n    async fetchCastsByParent(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castsApi.fetchCastsByParent(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch casts mentioning a user.\n     *\n     * @summary Mentioning an FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID that is mentioned in a cast\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchCastsMentioningUser({ fid, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)\n     *\n     */\n    async fetchCastsMentioningUser(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castsApi.fetchCastsMentioningUser(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch user\\'s casts.\n     *\n     * @summary By FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the casts' creator\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchUsersCasts({ fid, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)\n     *\n     */\n    async fetchUsersCasts(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castsApi.fetchUsersCasts(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Lookup a cast by its FID and hash.\n     *\n     * @summary By FID and Hash\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the cast's creator\n     * @param {string} params.hash  - The unique hash identifier of the cast. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies a specific cast in the Farcaster network.\n     *\n     * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const hash =\n     *\n     * client.lookupCastByHashAndFid({ fid, hash }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)\n     *\n     */\n    async lookupCastByHashAndFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.castsApi.lookupCastByHashAndFid(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of all the FIDs.\n     *\n     * @summary Fetch a list of all the FIDs\n     *\n     * @param {object} params\n     * @param {number} params.shardId  - The shard ID to filter by\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const shardId =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchFids({ shardId, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)\n     *\n     */\n    async fetchFids(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.fidsApi.fetchFids(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of events.\n     *\n     * @summary Page of events\n     *\n     * @param {object} params\n     * @param {number} params.fromEventId [optional]  - An optional Hub Id to start getting events from. This is also returned from the API as nextPageEventId, which can be used to page through all the Hub events. Set it to 0 to start from the first event.\n     *\n     * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fromEventId =\n     *\n     * client.fetchEvents({ fromEventId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)\n     *\n     */\n    async fetchEvents(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.hubEventsApi.fetchEvents(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Lookup an event by its ID.\n     *\n     * @summary Event by ID\n     *\n     * @param {object} params\n     * @param {number} params.eventId  - The Hub Id of the event\n     *\n     * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const eventId =\n     *\n     * client.lookupEvent({ eventId }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)\n     *\n     */\n    async lookupEvent(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.hubEventsApi.lookupEvent(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Retrieve hub information.\n     *\n     * @summary Sync Methods\n     *\n     * @param {object} params\n     * @param {boolean} params.dbstats  - Controls whether the response includes database statistics. When true, the response includes information about the hub's database state, storage usage, and performance metrics.\n     *\n     * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const dbstats =\n     *\n     * client.lookupHubInfo({ dbstats }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)\n     *\n     */\n    async lookupHubInfo(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.infoApi.lookupHubInfo(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of users that are following a user.\n     *\n     * @summary To target FID\n     *\n     * @param {object} params\n     * @param {number} params.targetFid  - The FID of the target user for this link\n     * @param {LinkType} params.linkType [optional]\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const targetFid =\n     * const linkType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchUserFollowers({ targetFid, linkType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n     *\n     */\n    async fetchUserFollowers(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.linksApi.fetchUserFollowers(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a list of users that a user is following.\n     *\n     * @summary From source FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the link's originator\n     * @param {LinkType} params.linkType [optional]\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const linkType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchUserFollowing({ fid, linkType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n     *\n     */\n    async fetchUserFollowing(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.linksApi.fetchUserFollowing(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Lookup a link by its FID and target FID.\n     *\n     * @summary By its FID and target FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the link's originator\n     * @param {number} params.targetFid  - The FID of the target user for this link\n     * @param {LinkType} params.linkType\n     *\n     * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const targetFid =\n     * const linkType =\n     *\n     * client.lookupUserRelation({ fid, targetFid, linkType }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)\n     *\n     */\n    async lookupUserRelation(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.linksApi.lookupUserRelation(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Submit a message to the Farcaster network.\n     *\n     * @summary Submit signed message\n     *\n     * @param {object} params\n     * @param {File} params.body  - A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n     *\n     * @returns {Promise<Message>} A promise that resolves to a `Message` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const body =\n     *\n     * client.publishMessage({ body }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)\n     *\n     */\n    async publishMessage(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.messageApi.publishMessage(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Validate a message on the Farcaster network.\n     *\n     * @summary Validate signed message\n     *\n     * @param {object} params\n     * @param {File} params.body  - A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n     *\n     * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const body =\n     *\n     * client.validateMessage({ body }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)\n     *\n     */\n    async validateMessage(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.messageApi.validateMessage(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch on-chain events provided by a user.\n     *\n     * @summary Fetch a list of on-chain events provided by an FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID being requested\n     * @param {OnChainEventType} params.eventType  - The numeric or string value of the event type being requested\n     *\n     * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const eventType =\n     *\n     * client.fetchUserOnChainEvents({ fid, eventType }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)\n     *\n     */\n    async fetchUserOnChainEvents(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onChainEventsApi.fetchUserOnChainEvents(adjustedParams);\n        return response.data;\n    }\n    /**\n     * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.\n     *\n     * @summary Fetch a list of signers provided by an FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID being requested\n     * @param {string} params.signer [optional]  - The optional key of signer\n     *\n     * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const signer =\n     *\n     * client.fetchUserOnChainSignersEvents({ fid, signer }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)\n     *\n     */\n    async fetchUserOnChainSignersEvents(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onChainEventsApi.fetchUserOnChainSignersEvents(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch an on-chain ID Registry Event for a given Address.\n     *\n     * @summary Fetch an on-chain ID Registry Event for a given Address\n     *\n     * @param {object} params\n     * @param {string} params.address  - The ETH address being requested\n     *\n     * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const address =\n     *\n     * client.lookupOnChainIdRegistryEventByAddress({ address }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)\n     *\n     */\n    async lookupOnChainIdRegistryEventByAddress(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.onChainEventsApi.lookupOnChainIdRegistryEventByAddress(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.\n     *\n     * @summary On cast\n     *\n     * @param {object} params\n     * @param {number} params.targetFid  - The FID of the cast's creator. Required to uniquely identify the cast that received the reactions. Must be used in conjunction with target_hash.\n     * @param {string} params.targetHash  - The unique hash identifier of the cast that received the reactions. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies the cast within the creator's posts. Must be used with target_fid.\n     * @param {ReactionType} params.reactionType\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const targetFid =\n     * const targetHash =\n     * const reactionType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchCastReactions({ targetFid, targetHash, reactionType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n     *\n     */\n    async fetchCastReactions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionsApi.fetchCastReactions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.\n     *\n     * @summary To a target URL\n     *\n     * @param {object} params\n     * @param {string} params.url  - Target URL starting with 'chain://'.\n     * @param {ReactionType} params.reactionType [optional]\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const url =\n     * const reactionType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchReactionsByTarget({ url, reactionType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)\n     *\n     */\n    async fetchReactionsByTarget(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionsApi.fetchReactionsByTarget(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch reactions by a user.\n     *\n     * @summary By FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the reaction's creator\n     * @param {ReactionType} params.reactionType\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const reactionType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchUserReactions({ fid, reactionType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n     *\n     */\n    async fetchUserReactions(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionsApi.fetchUserReactions(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Lookup a reaction by its FID or cast.\n     *\n     * @summary By FID or cast\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID of the reaction's creator\n     * @param {number} params.targetFid  - The FID of the cast's creator\n     * @param {string} params.targetHash  - The cast's hash\n     * @param {ReactionType} params.reactionType\n     *\n     * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const targetFid =\n     * const targetHash =\n     * const reactionType =\n     *\n     * client.lookupReactionById({ fid, targetFid, targetHash, reactionType }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)\n     *\n     */\n    async lookupReactionById(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.reactionsApi.lookupReactionById(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a user\\'s storage limits.\n     *\n     * @summary FID\\'s limits\n     *\n     * @param {object} params\n     * @param {number} params.fid\n     *\n     * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     *\n     * client.lookupUserStorageLimit({ fid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)\n     *\n     */\n    async lookupUserStorageLimit(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.storageApi.lookupUserStorageLimit(adjustedParams);\n        return response.data;\n    }\n    /**\n     * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.\n     *\n     * @summary Fetch UserData for a FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID that's being requested\n     * @param {UserDataType} params.userDataType [optional]  - The type of user data, either as a numerical value or type string. If this is omitted, all user data for the FID is returned\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const userDataType =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchUserData({ fid, userDataType, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)\n     *\n     */\n    async fetchUserData(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.userDataApi.fetchUserData(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch a proof for a username.\n     *\n     * @summary Proof for a username\n     *\n     * @param {object} params\n     * @param {string} params.name  - The Farcaster username or ENS address\n     *\n     * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const name =\n     *\n     * client.fetchUsernameProofByName({ name }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)\n     *\n     */\n    async fetchUsernameProofByName(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.usernamesApi.fetchUsernameProofByName(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch proofs provided by a user.\n     *\n     * @summary Proofs provided by an FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID being requested\n     *\n     * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     *\n     * client.fetchUsernameProofsByFid({ fid }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)\n     *\n     */\n    async fetchUsernameProofsByFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.usernamesApi.fetchUsernameProofsByFid(adjustedParams);\n        return response.data;\n    }\n    /**\n     * Fetch verifications provided by a user.\n     *\n     * @summary Provided by an FID\n     *\n     * @param {object} params\n     * @param {number} params.fid  - The FID being requested\n     * @param {string} params.address [optional]  - The optional ETH address to filter by\n     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response\n     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first\n     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n     *\n     * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object.\n     *\n     * @example\n     *\n     * // Fill in the appropriate values\n     * const fid =\n     * const address =\n     * const pageSize =\n     * const reverse =\n     * const pageToken =\n     *\n     * client.fetchVerificationsByFid({ fid, address, pageSize, reverse, pageToken }).then(response => {\n     *   console.log('response:', response);\n     * });\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)\n     *\n     */\n    async fetchVerificationsByFid(params) {\n        const adjustedParams = {};\n        Object.assign(adjustedParams, params);\n        const response = await this.apis.verificationsApi.fetchVerificationsByFid(adjustedParams);\n        return response.data;\n    }\n}\nexports.NeynarHubClient = NeynarHubClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NsaWVudHMvTmV5bmFySHViQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLDZEQUFPO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLHdHQUEwQjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQywwR0FBMkI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsd0dBQTBCO0FBQ3JELHlCQUF5QixtQkFBTyxDQUFDLG9IQUFnQztBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLDhHQUE2QjtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyw4SEFBcUM7QUFDM0Usd0JBQXdCLG1CQUFPLENBQUMsa0hBQStCO0FBQy9ELHNCQUFzQixtQkFBTyxDQUFDLDhHQUE2QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDL0Qsd0JBQXdCLG1CQUFPLENBQUMsa0hBQStCO0FBQy9ELDRCQUE0QixtQkFBTyxDQUFDLDBIQUFtQztBQUN2RSxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0Q0FBNEM7QUFDcEY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9jbGllbnRzL05leW5hckh1YkNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXluYXJIdWJDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vbG9nZ2VyXCIpO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXhpb3NcIikpO1xuY29uc3QgY29uZmlndXJhdGlvbl8xID0gcmVxdWlyZShcIi4uL2h1Yi1hcGkvY29uZmlndXJhdGlvblwiKTtcbmNvbnN0IGNhc3RzX2FwaV8xID0gcmVxdWlyZShcIi4uL2h1Yi1hcGkvYXBpcy9jYXN0cy1hcGlcIik7XG5jb25zdCBmaWRzX2FwaV8xID0gcmVxdWlyZShcIi4uL2h1Yi1hcGkvYXBpcy9maWRzLWFwaVwiKTtcbmNvbnN0IGh1Yl9ldmVudHNfYXBpXzEgPSByZXF1aXJlKFwiLi4vaHViLWFwaS9hcGlzL2h1Yi1ldmVudHMtYXBpXCIpO1xuY29uc3QgaW5mb19hcGlfMSA9IHJlcXVpcmUoXCIuLi9odWItYXBpL2FwaXMvaW5mby1hcGlcIik7XG5jb25zdCBsaW5rc19hcGlfMSA9IHJlcXVpcmUoXCIuLi9odWItYXBpL2FwaXMvbGlua3MtYXBpXCIpO1xuY29uc3QgbWVzc2FnZV9hcGlfMSA9IHJlcXVpcmUoXCIuLi9odWItYXBpL2FwaXMvbWVzc2FnZS1hcGlcIik7XG5jb25zdCBvbl9jaGFpbl9ldmVudHNfYXBpXzEgPSByZXF1aXJlKFwiLi4vaHViLWFwaS9hcGlzL29uLWNoYWluLWV2ZW50cy1hcGlcIik7XG5jb25zdCByZWFjdGlvbnNfYXBpXzEgPSByZXF1aXJlKFwiLi4vaHViLWFwaS9hcGlzL3JlYWN0aW9ucy1hcGlcIik7XG5jb25zdCBzdG9yYWdlX2FwaV8xID0gcmVxdWlyZShcIi4uL2h1Yi1hcGkvYXBpcy9zdG9yYWdlLWFwaVwiKTtcbmNvbnN0IHVzZXJfZGF0YV9hcGlfMSA9IHJlcXVpcmUoXCIuLi9odWItYXBpL2FwaXMvdXNlci1kYXRhLWFwaVwiKTtcbmNvbnN0IHVzZXJuYW1lc19hcGlfMSA9IHJlcXVpcmUoXCIuLi9odWItYXBpL2FwaXMvdXNlcm5hbWVzLWFwaVwiKTtcbmNvbnN0IHZlcmlmaWNhdGlvbnNfYXBpXzEgPSByZXF1aXJlKFwiLi4vaHViLWFwaS9hcGlzL3ZlcmlmaWNhdGlvbnMtYXBpXCIpO1xuY29uc3QgeyB2ZXJzaW9uOiBzZGtWZXJzaW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vcGFja2FnZS5qc29uXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGNhbWVsQ2FzZSBzdHJpbmcgdG8gc25ha2VfY2FzZS5cbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgbm90IGluIGNhbWVsQ2FzZSBmb3JtYXQsIGl0IHJldHVybnMgdGhlIG9yaWdpbmFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnZlcnRlZCBzdHJpbmcgaW4gc25ha2VfY2FzZSwgb3IgdGhlIG9yaWdpbmFsIHN0cmluZyBpZiBub3QgY2FtZWxDYXNlLlxuICovXG5mdW5jdGlvbiBjYW1lbFRvU25ha2VDYXNlKHN0cikge1xuICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgaXMgY2FtZWxDYXNlXG4gICAgaWYgKC9eW2Etel0rKFtBLVpdW2Etel0qKSskLy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICdfJDEnKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyOyAvLyBSZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZyBpZiBpdCdzIG5vdCBjYW1lbENhc2Vcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIHRvcC1sZXZlbCBrZXlzIG9mIGFuIG9iamVjdCBmcm9tIGNhbWVsQ2FzZSB0byBzbmFrZV9jYXNlLlxuICogSWYgYSBrZXkgaXMgbm90IGluIGNhbWVsQ2FzZSwgaXQgcmV0YWlucyBpdHMgb3JpZ2luYWwgZm9ybWF0LlxuICogTmVzdGVkIG9iamVjdHMgb3IgYXJyYXlzIGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAqIFRoaXMgaXMgZG9uZSB0byByZXZlcnQgdGhlIGNvbnZlcnNpb24gb2YgdG9wLWxldmVsIGtleXMgc2luY2Ugd2UgYWNjZXB0IHNuYWtlX2Nhc2Uga2V5cyBpbiB0aGUgQVBJIGJ1dCBjb252ZXJ0IHRoZW0gdG8gY2FtZWxDYXNlIGluIHRoZSB3cmFwcGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHdob3NlIHRvcC1sZXZlbCBrZXlzIGFyZSB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCB0b3AtbGV2ZWwga2V5cyBjb252ZXJ0ZWQgdG8gc25ha2VfY2FzZS5cbiAqL1xuZnVuY3Rpb24gY2FtZWxDYXNlVG9TbmFrZUNhc2VLZXlzKG9iaikge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyBDb252ZXJ0IG9ubHkgdGhlIHRvcC1sZXZlbCBrZXlzXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgICAgY2FtZWxUb1NuYWtlQ2FzZShrZXkpLCAvLyBDb252ZXJ0IG9ubHkgY2FtZWxDYXNlIGtleXNcbiAgICAgICAgICAgIHZhbHVlLCAvLyBMZWF2ZSB0aGUgdmFsdWUgdW50b3VjaGVkXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajsgLy8gSWYgbm90IGFuIG9iamVjdCwgcmV0dXJuIGFzIGlzXG59XG5jbGFzcyBOZXluYXJIdWJDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6IGNvbmZpZyBtdXN0IGJlIG9mIHR5cGUgQ29uZmlndXJhdGlvbicpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFxuU2VlbXMsIGxpa2UgeW91IGFyZSB1c2luZyBzZGsgdjIgYnV0IHRoZSBzeW50YXggb24gY2xpZW50IGluc3RhbnRpYXRpb24gaXMgZm9yIHNkayB2MS5cblNESyB2MSAtPiB2MiBtaWdyYXRpb24gZ3VpZGU6IGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9uZXluYXItbm9kZWpzLXNkay12MS10by12Mi1taWdyYXRpb24tZ3VpZGVcblxuQ29ycmVjdCB1c2FnZSB3YXkgdG8gaW5zdGFudGlhdGUgdGhlIGNsaWVudDpcblxuaW1wb3J0IHsgTmV5bmFySHViQ2xpZW50LCBDb25maWd1cmF0aW9uIH0gZnJvbSBcIkBuZXluYXIvbm9kZWpzLXNka1wiO1xuXG5jb25zdCBjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbih7XG4gIGFwaUtleTogXCJBUElfS0VZXCIsXG4gIGJhc2VPcHRpb25zOiB7XG4gICAgaGVhZGVyczoge1xuICAgICAgXCJ4LW5leW5hci1leHBlcmltZW50YWxcIjogdHJ1ZSxcbiAgICB9LFxuICB9LFxufSk7XG5cbmNvbnN0IGNsaWVudCA9IG5ldyBOZXluYXJIdWJDbGllbnQoY29uZmlnKTtcXG5gKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb25maWd1cmF0aW9uIHR5cGUuIEV4cGVjdGVkIENvbmZpZ3VyYXRpb24gb2JqZWN0IGJ1dCByZWNlaXZlZCBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2dnZXIgPSBsb2dnZXJfMS5zaWxlbnRMb2dnZXIsIGF4aW9zSW5zdGFuY2U6IGN1c3RvbUF4aW9zSW5zdGFuY2UgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICAgICAgICBiYXNlUGF0aDogY29uZmlnLmJhc2VQYXRoLFxuICAgICAgICAgICAgYmFzZU9wdGlvbnM6IGNvbmZpZy5iYXNlT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF4aW9zSW5zdGFuY2UgPSBjdXN0b21BeGlvc0luc3RhbmNlIHx8IGF4aW9zXzEuZGVmYXVsdC5jcmVhdGUoe1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwieC1zZGstdmVyc2lvblwiOiBzZGtWZXJzaW9uLFxuICAgICAgICAgICAgICAgIFwieC1zZGtcIjogXCJub2RlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBheGlvc0luc3RhbmNlLmRlZmF1bHRzLmRlY29tcHJlc3MgPSB0cnVlO1xuICAgICAgICBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoKHJlc3BvbnNlKSA9PiByZXNwb25zZSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgWzMwMl0uaW5jbHVkZXMoZXJyb3IucmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBlcnJvci5yZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTmV5bmFySHViQ2xpZW50LmlzQXBpRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvcnMgPSBlcnJvci5yZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEFQSSBlcnJvcnM6ICR7SlNPTi5zdHJpbmdpZnkoYXBpRXJyb3JzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlzID0ge1xuICAgICAgICAgICAgY2FzdHNBcGk6IG5ldyBjYXN0c19hcGlfMS5DYXN0c0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGZpZHNBcGk6IG5ldyBmaWRzX2FwaV8xLkZpZHNBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBodWJFdmVudHNBcGk6IG5ldyBodWJfZXZlbnRzX2FwaV8xLkh1YkV2ZW50c0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIGluZm9BcGk6IG5ldyBpbmZvX2FwaV8xLkluZm9BcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBsaW5rc0FwaTogbmV3IGxpbmtzX2FwaV8xLkxpbmtzQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgbWVzc2FnZUFwaTogbmV3IG1lc3NhZ2VfYXBpXzEuTWVzc2FnZUFwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIG9uQ2hhaW5FdmVudHNBcGk6IG5ldyBvbl9jaGFpbl9ldmVudHNfYXBpXzEuT25DaGFpbkV2ZW50c0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgICAgIHJlYWN0aW9uc0FwaTogbmV3IHJlYWN0aW9uc19hcGlfMS5SZWFjdGlvbnNBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICBzdG9yYWdlQXBpOiBuZXcgc3RvcmFnZV9hcGlfMS5TdG9yYWdlQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgdXNlckRhdGFBcGk6IG5ldyB1c2VyX2RhdGFfYXBpXzEuVXNlckRhdGFBcGkodGhpcy5jb25maWcsIHVuZGVmaW5lZCwgYXhpb3NJbnN0YW5jZSksXG4gICAgICAgICAgICB1c2VybmFtZXNBcGk6IG5ldyB1c2VybmFtZXNfYXBpXzEuVXNlcm5hbWVzQXBpKHRoaXMuY29uZmlnLCB1bmRlZmluZWQsIGF4aW9zSW5zdGFuY2UpLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uc0FwaTogbmV3IHZlcmlmaWNhdGlvbnNfYXBpXzEuVmVyaWZpY2F0aW9uc0FwaSh0aGlzLmNvbmZpZywgdW5kZWZpbmVkLCBheGlvc0luc3RhbmNlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGlzQXBpRXJyb3JSZXNwb25zZShlcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgYXhpb3NfMS5BeGlvc0Vycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgoKF9hID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gdW5kZWZpbmVkICYmIFwibWVzc2FnZVwiIGluIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgcmVwbHkgY2FzdHMgKHJlc3BvbnNlcykgdG8gYSBzcGVjaWZpYyBwYXJlbnQgY2FzdCBpbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFBhcmVudCBjYXN0cyBjYW4gYmUgaWRlbnRpZmllZCB1c2luZyBlaXRoZXIgYSBjb21iaW5hdGlvbiBvZiBGSUQgYW5kIGhhc2gsIG9yIGJ5IHRoZWlyIFVSTC4gVGhpcyBlbmRwb2ludCBlbmFibGVzIHRyYXZlcnNhbCBvZiBjb252ZXJzYXRpb24gdGhyZWFkcyBhbmQgcmV0cmlldmFsIG9mIGFsbCByZXNwb25zZXMgdG8gYSBwYXJ0aWN1bGFyIGNhc3QuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgY2FzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkIFtvcHRpb25hbF0gIC0gVGhlIEZhcmNhc3RlciBJRCAoRklEKSBvZiB0aGUgcGFyZW50IGNhc3QncyBjcmVhdG9yLiBUaGlzIHBhcmFtZXRlciBtdXN0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgJ2hhc2gnIHBhcmFtZXRlciB0byB1bmlxdWVseSBpZGVudGlmeSBhIHBhcmVudCBjYXN0LiBSZXF1aXJlZCBvbmx5IHdoZW4gdXNpbmcgaGFzaC1iYXNlZCBsb29rdXAgaW5zdGVhZCBvZiBVUkwtYmFzZWQgbG9va3VwLiBUaGUgRklEIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgYXNzaWduZWQgdG8gZWFjaCBGYXJjYXN0ZXIgdXNlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmhhc2ggW29wdGlvbmFsXSAgLSBUaGUgdW5pcXVlIGhhc2ggaWRlbnRpZmllciBvZiB0aGUgcGFyZW50IGNhc3QuIE11c3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHRoZSAnZmlkJyBwYXJhbWV0ZXIgd2hlbiBkb2luZyBoYXNoLWJhc2VkIGxvb2t1cC4gVGhpcyBpcyBhIDQwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcgcHJlZml4ZWQgd2l0aCAnMHgnIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY2FzdCB3aXRoaW4gdGhlIGNyZWF0b3IncyBwb3N0cy4gTm90IHJlcXVpcmVkIGlmIHVzaW5nIFVSTC1iYXNlZCBsb29rdXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51cmwgW29wdGlvbmFsXSAgLSBDYXN0IFVSTCBzdGFydGluZyB3aXRoICdjaGFpbjovLydcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaENhc3RzQnlQYXJlbnQyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoQ2FzdHNCeVBhcmVudDIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBoYXNoID1cbiAgICAgKiBjb25zdCB1cmwgPVxuICAgICAqIGNvbnN0IHBhZ2VTaXplID1cbiAgICAgKiBjb25zdCByZXZlcnNlID1cbiAgICAgKiBjb25zdCBwYWdlVG9rZW4gPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoQ2FzdHNCeVBhcmVudCh7IGZpZCwgaGFzaCwgdXJsLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtYnktcGFyZW50KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hDYXN0c0J5UGFyZW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jYXN0c0FwaS5mZXRjaENhc3RzQnlQYXJlbnQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY2FzdHMgbWVudGlvbmluZyBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBNZW50aW9uaW5nIGFuIEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSBGSUQgdGhhdCBpcyBtZW50aW9uZWQgaW4gYSBjYXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5wYWdlU2l6ZSBbb3B0aW9uYWxdICAtIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgW29wdGlvbmFsXSAgLSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYWdlVG9rZW4gW29wdGlvbmFsXSAgLSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJzQ2FzdHMyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hDYXN0c01lbnRpb25pbmdVc2VyKHsgZmlkLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtbWVudGlvbmluZy11c2VyKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hDYXN0c01lbnRpb25pbmdVc2VyKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jYXN0c0FwaS5mZXRjaENhc3RzTWVudGlvbmluZ1VzZXIoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdXNlclxcJ3MgY2FzdHMuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBCeSBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIG9mIHRoZSBjYXN0cycgY3JlYXRvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucGFnZVNpemUgW29wdGlvbmFsXSAgLSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIFtvcHRpb25hbF0gIC0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucGFnZVRva2VuIFtvcHRpb25hbF0gIC0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHBhZ2VTaXplID1cbiAgICAgKiBjb25zdCByZXZlcnNlID1cbiAgICAgKiBjb25zdCBwYWdlVG9rZW4gPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlcnNDYXN0cyh7IGZpZCwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWNhc3RzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2Vyc0Nhc3RzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5jYXN0c0FwaS5mZXRjaFVzZXJzQ2FzdHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgY2FzdCBieSBpdHMgRklEIGFuZCBoYXNoLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgRklEIGFuZCBIYXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCBvZiB0aGUgY2FzdCdzIGNyZWF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmhhc2ggIC0gVGhlIHVuaXF1ZSBoYXNoIGlkZW50aWZpZXIgb2YgdGhlIGNhc3QuIFRoaXMgaXMgYSA0MC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgc3RyaW5nIHByZWZpeGVkIHdpdGggJzB4JyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSBzcGVjaWZpYyBjYXN0IGluIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RBZGQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0QWRkYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBoYXNoID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBDYXN0QnlIYXNoQW5kRmlkKHsgZmlkLCBoYXNoIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtYnktaGFzaC1hbmQtZmlkKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwQ2FzdEJ5SGFzaEFuZEZpZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMuY2FzdHNBcGkubG9va3VwQ2FzdEJ5SGFzaEFuZEZpZChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBGSURzLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc2hhcmRJZCAgLSBUaGUgc2hhcmQgSUQgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5wYWdlU2l6ZSBbb3B0aW9uYWxdICAtIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgW29wdGlvbmFsXSAgLSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYWdlVG9rZW4gW29wdGlvbmFsXSAgLSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Rmlkc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlkc1Jlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3Qgc2hhcmRJZCA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hGaWRzKHsgc2hhcmRJZCwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZpZHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaEZpZHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmZpZHNBcGkuZmV0Y2hGaWRzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBldmVudHMuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBQYWdlIG9mIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZnJvbUV2ZW50SWQgW29wdGlvbmFsXSAgLSBBbiBvcHRpb25hbCBIdWIgSWQgdG8gc3RhcnQgZ2V0dGluZyBldmVudHMgZnJvbS4gVGhpcyBpcyBhbHNvIHJldHVybmVkIGZyb20gdGhlIEFQSSBhcyBuZXh0UGFnZUV2ZW50SWQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHBhZ2UgdGhyb3VnaCBhbGwgdGhlIEh1YiBldmVudHMuIFNldCBpdCB0byAwIHRvIHN0YXJ0IGZyb20gdGhlIGZpcnN0IGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hFdmVudHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoRXZlbnRzMjAwUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmcm9tRXZlbnRJZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hFdmVudHMoeyBmcm9tRXZlbnRJZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWV2ZW50cylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoRXZlbnRzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5odWJFdmVudHNBcGkuZmV0Y2hFdmVudHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGFuIGV2ZW50IGJ5IGl0cyBJRC5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEV2ZW50IGJ5IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5ldmVudElkICAtIFRoZSBIdWIgSWQgb2YgdGhlIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIdWJFdmVudD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEh1YkV2ZW50YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZXZlbnRJZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQubG9va3VwRXZlbnQoeyBldmVudElkIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWV2ZW50KVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwRXZlbnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmh1YkV2ZW50c0FwaS5sb29rdXBFdmVudChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBodWIgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTeW5jIE1ldGhvZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5kYnN0YXRzICAtIENvbnRyb2xzIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGRhdGFiYXNlIHN0YXRpc3RpY3MuIFdoZW4gdHJ1ZSwgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBodWIncyBkYXRhYmFzZSBzdGF0ZSwgc3RvcmFnZSB1c2FnZSwgYW5kIHBlcmZvcm1hbmNlIG1ldHJpY3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIdWJJbmZvUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBIdWJJbmZvUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBkYnN0YXRzID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBIdWJJbmZvKHsgZGJzdGF0cyB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1odWItaW5mbylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvb2t1cEh1YkluZm8ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLmluZm9BcGkubG9va3VwSHViSW5mbyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhcmUgZm9sbG93aW5nIGEgdXNlci5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFRvIHRhcmdldCBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRhcmdldEZpZCAgLSBUaGUgRklEIG9mIHRoZSB0YXJnZXQgdXNlciBmb3IgdGhpcyBsaW5rXG4gICAgICogQHBhcmFtIHtMaW5rVHlwZX0gcGFyYW1zLmxpbmtUeXBlIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgdGFyZ2V0RmlkID1cbiAgICAgKiBjb25zdCBsaW5rVHlwZSA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyRm9sbG93ZXJzKHsgdGFyZ2V0RmlkLCBsaW5rVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93ZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93ZXJzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5saW5rc0FwaS5mZXRjaFVzZXJGb2xsb3dlcnMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIHVzZXJzIHRoYXQgYSB1c2VyIGlzIGZvbGxvd2luZy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZyb20gc291cmNlIEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSBGSUQgb2YgdGhlIGxpbmsncyBvcmlnaW5hdG9yXG4gICAgICogQHBhcmFtIHtMaW5rVHlwZX0gcGFyYW1zLmxpbmtUeXBlIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCBsaW5rVHlwZSA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VyRm9sbG93aW5nKHsgZmlkLCBsaW5rVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93aW5nKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93aW5nKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5saW5rc0FwaS5mZXRjaFVzZXJGb2xsb3dpbmcoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgbGluayBieSBpdHMgRklEIGFuZCB0YXJnZXQgRklELlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgaXRzIEZJRCBhbmQgdGFyZ2V0IEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSBGSUQgb2YgdGhlIGxpbmsncyBvcmlnaW5hdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50YXJnZXRGaWQgIC0gVGhlIEZJRCBvZiB0aGUgdGFyZ2V0IHVzZXIgZm9yIHRoaXMgbGlua1xuICAgICAqIEBwYXJhbSB7TGlua1R5cGV9IHBhcmFtcy5saW5rVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TGlua0FkZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYExpbmtBZGRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqIGNvbnN0IHRhcmdldEZpZCA9XG4gICAgICogY29uc3QgbGlua1R5cGUgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFVzZXJSZWxhdGlvbih7IGZpZCwgdGFyZ2V0RmlkLCBsaW5rVHlwZSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXJlbGF0aW9uKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwVXNlclJlbGF0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5saW5rc0FwaS5sb29rdXBVc2VyUmVsYXRpb24oYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IGEgbWVzc2FnZSB0byB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBTdWJtaXQgc2lnbmVkIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IHBhcmFtcy5ib2R5ICAtIEEgTWVzc2FnZSBpcyBhIGRlbHRhIG9wZXJhdGlvbiBvbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFRoZSBtZXNzYWdlIHByb3RvYnVmIGlzIGFuIGVudmVsb3BlIHRoYXQgd3JhcHMgYSBNZXNzYWdlRGF0YSBvYmplY3QgYW5kIGNvbnRhaW5zIGEgaGFzaCBhbmQgc2lnbmF0dXJlIHdoaWNoIGNhbiB2ZXJpZnkgaXRzIGF1dGhlbnRpY2l0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBNZXNzYWdlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgYm9keSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQucHVibGlzaE1lc3NhZ2UoeyBib2R5IH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc3VibWl0LXNpZ25lZC1tZXNzYWdlKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgcHVibGlzaE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm1lc3NhZ2VBcGkucHVibGlzaE1lc3NhZ2UoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSBtZXNzYWdlIG9uIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFZhbGlkYXRlIHNpZ25lZCBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtGaWxlfSBwYXJhbXMuYm9keSAgLSBBIE1lc3NhZ2UgaXMgYSBkZWx0YSBvcGVyYXRpb24gb24gdGhlIEZhcmNhc3RlciBuZXR3b3JrLiBUaGUgbWVzc2FnZSBwcm90b2J1ZiBpcyBhbiBlbnZlbG9wZSB0aGF0IHdyYXBzIGEgTWVzc2FnZURhdGEgb2JqZWN0IGFuZCBjb250YWlucyBhIGhhc2ggYW5kIHNpZ25hdHVyZSB3aGljaCBjYW4gdmVyaWZ5IGl0cyBhdXRoZW50aWNpdHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWYWxpZGF0ZU1lc3NhZ2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFZhbGlkYXRlTWVzc2FnZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgYm9keSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQudmFsaWRhdGVNZXNzYWdlKHsgYm9keSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3ZhbGlkYXRlLW1lc3NhZ2UpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm1lc3NhZ2VBcGkudmFsaWRhdGVNZXNzYWdlKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIG9uLWNoYWluIGV2ZW50cyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBhIGxpc3Qgb2Ygb24tY2hhaW4gZXZlbnRzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZmlkICAtIFRoZSBGSUQgYmVpbmcgcmVxdWVzdGVkXG4gICAgICogQHBhcmFtIHtPbkNoYWluRXZlbnRUeXBlfSBwYXJhbXMuZXZlbnRUeXBlICAtIFRoZSBudW1lcmljIG9yIHN0cmluZyB2YWx1ZSBvZiB0aGUgZXZlbnQgdHlwZSBiZWluZyByZXF1ZXN0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlck9uQ2hhaW5FdmVudHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlck9uQ2hhaW5FdmVudHMyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgZXZlbnRUeXBlID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFVzZXJPbkNoYWluRXZlbnRzKHsgZmlkLCBldmVudFR5cGUgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLW9uLWNoYWluLWV2ZW50cylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVXNlck9uQ2hhaW5FdmVudHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm9uQ2hhaW5FdmVudHNBcGkuZmV0Y2hVc2VyT25DaGFpbkV2ZW50cyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAqKk5vdGU6Kiogb25lIG9mIHR3byBkaWZmZXJlbnQgcmVzcG9uc2Ugc2NoZW1hcyBpcyByZXR1cm5lZCBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjYWxsZXIgcHJvdmlkZXMgdGhlIGBzaWduZXJgIHBhcmFtZXRlci4gSWYgaW5jbHVkZWQsIGEgc2luZ2xlIGBPbkNoYWluRXZlbnRTaWduZXJgIG1lc3NhZ2UgaXMgcmV0dXJuZWQgKG9yIGEgYG5vdF9mb3VuZGAgZXJyb3IpLiBJZiBvbWl0dGVkLCBhIG5vbi1wYWdpbmF0ZWQgbGlzdCBvZiBgT25DaGFpbkV2ZW50U2lnbmVyYCBtZXNzYWdlcyBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIHNpZ25lcnMgcHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCBiZWluZyByZXF1ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpZ25lciBbb3B0aW9uYWxdICAtIFRoZSBvcHRpb25hbCBrZXkgb2Ygc2lnbmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3Qgc2lnbmVyID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5mZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50cyh7IGZpZCwgc2lnbmVyIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1vbi1jaGFpbi1zaWduZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLm9uQ2hhaW5FdmVudHNBcGkuZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYW4gb24tY2hhaW4gSUQgUmVnaXN0cnkgRXZlbnQgZm9yIGEgZ2l2ZW4gQWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGFuIG9uLWNoYWluIElEIFJlZ2lzdHJ5IEV2ZW50IGZvciBhIGdpdmVuIEFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgIC0gVGhlIEVUSCBhZGRyZXNzIGJlaW5nIHJlcXVlc3RlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T25DaGFpbkV2ZW50SWRSZWdpc3Rlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9uQ2hhaW5FdmVudElkUmVnaXN0ZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBhZGRyZXNzID1cbiAgICAgKlxuICAgICAqIGNsaWVudC5sb29rdXBPbkNoYWluSWRSZWdpc3RyeUV2ZW50QnlBZGRyZXNzKHsgYWRkcmVzcyB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1vbi1jaGFpbi1pZC1yZWdpc3RyeS1ldmVudC1ieS1hZGRyZXNzKVxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgbG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMub25DaGFpbkV2ZW50c0FwaS5sb29rdXBPbkNoYWluSWRSZWdpc3RyeUV2ZW50QnlBZGRyZXNzKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCByZWFjdGlvbnMgKGxpa2VzIG9yIHJlY2FzdHMpIG9uIGEgc3BlY2lmaWMgY2FzdCBpbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFRoZSBjYXN0IGlzIGlkZW50aWZpZWQgYnkgaXRzIGNyZWF0b3JcXCdzIEZJRCBhbmQgdW5pcXVlIGhhc2guIFRoaXMgZW5kcG9pbnQgaGVscHMgdHJhY2sgZW5nYWdlbWVudCBtZXRyaWNzIGFuZCB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHNwZWNpZmljIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBPbiBjYXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50YXJnZXRGaWQgIC0gVGhlIEZJRCBvZiB0aGUgY2FzdCdzIGNyZWF0b3IuIFJlcXVpcmVkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBjYXN0IHRoYXQgcmVjZWl2ZWQgdGhlIHJlYWN0aW9ucy4gTXVzdCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGFyZ2V0X2hhc2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy50YXJnZXRIYXNoICAtIFRoZSB1bmlxdWUgaGFzaCBpZGVudGlmaWVyIG9mIHRoZSBjYXN0IHRoYXQgcmVjZWl2ZWQgdGhlIHJlYWN0aW9ucy4gVGhpcyBpcyBhIDQwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcgcHJlZml4ZWQgd2l0aCAnMHgnIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY2FzdCB3aXRoaW4gdGhlIGNyZWF0b3IncyBwb3N0cy4gTXVzdCBiZSB1c2VkIHdpdGggdGFyZ2V0X2ZpZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uVHlwZX0gcGFyYW1zLnJlYWN0aW9uVHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucGFnZVNpemUgW29wdGlvbmFsXSAgLSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIFtvcHRpb25hbF0gIC0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucGFnZVRva2VuIFtvcHRpb25hbF0gIC0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCB0YXJnZXRGaWQgPVxuICAgICAqIGNvbnN0IHRhcmdldEhhc2ggPVxuICAgICAqIGNvbnN0IHJlYWN0aW9uVHlwZSA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hDYXN0UmVhY3Rpb25zKHsgdGFyZ2V0RmlkLCB0YXJnZXRIYXNoLCByZWFjdGlvblR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4gfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoQ2FzdFJlYWN0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhZGp1c3RlZFBhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaXMucmVhY3Rpb25zQXBpLmZldGNoQ2FzdFJlYWN0aW9ucyhhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbGwgcmVhY3Rpb25zIG9mIGEgc3BlY2lmaWMgdHlwZSAobGlrZSBvciByZWNhc3QpIHRoYXQgdGFyZ2V0IGEgZ2l2ZW4gVVJMLiBUaGlzIGVuZHBvaW50IGlzIHVzZWZ1bCBmb3IgdHJhY2tpbmcgZW5nYWdlbWVudCB3aXRoIGNvbnRlbnQgYWNyb3NzIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFRvIGEgdGFyZ2V0IFVSTFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsICAtIFRhcmdldCBVUkwgc3RhcnRpbmcgd2l0aCAnY2hhaW46Ly8nLlxuICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSBwYXJhbXMucmVhY3Rpb25UeXBlIFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgdXJsID1cbiAgICAgKiBjb25zdCByZWFjdGlvblR5cGUgPVxuICAgICAqIGNvbnN0IHBhZ2VTaXplID1cbiAgICAgKiBjb25zdCByZXZlcnNlID1cbiAgICAgKiBjb25zdCBwYWdlVG9rZW4gPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoUmVhY3Rpb25zQnlUYXJnZXQoeyB1cmwsIHJlYWN0aW9uVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlYWN0aW9ucy1ieS10YXJnZXQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFJlYWN0aW9uc0J5VGFyZ2V0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5yZWFjdGlvbnNBcGkuZmV0Y2hSZWFjdGlvbnNCeVRhcmdldChhZGp1c3RlZFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCByZWFjdGlvbnMgYnkgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgRklEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCBvZiB0aGUgcmVhY3Rpb24ncyBjcmVhdG9yXG4gICAgICogQHBhcmFtIHtSZWFjdGlvblR5cGV9IHBhcmFtcy5yZWFjdGlvblR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCByZWFjdGlvblR5cGUgPVxuICAgICAqIGNvbnN0IHBhZ2VTaXplID1cbiAgICAgKiBjb25zdCByZXZlcnNlID1cbiAgICAgKiBjb25zdCBwYWdlVG9rZW4gPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlclJlYWN0aW9ucyh7IGZpZCwgcmVhY3Rpb25UeXBlLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1yZWFjdGlvbnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFVzZXJSZWFjdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnJlYWN0aW9uc0FwaS5mZXRjaFVzZXJSZWFjdGlvbnMoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgcmVhY3Rpb24gYnkgaXRzIEZJRCBvciBjYXN0LlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgQnkgRklEIG9yIGNhc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIG9mIHRoZSByZWFjdGlvbidzIGNyZWF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRhcmdldEZpZCAgLSBUaGUgRklEIG9mIHRoZSBjYXN0J3MgY3JlYXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudGFyZ2V0SGFzaCAgLSBUaGUgY2FzdCdzIGhhc2hcbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uVHlwZX0gcGFyYW1zLnJlYWN0aW9uVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgdGFyZ2V0RmlkID1cbiAgICAgKiBjb25zdCB0YXJnZXRIYXNoID1cbiAgICAgKiBjb25zdCByZWFjdGlvblR5cGUgPVxuICAgICAqXG4gICAgICogY2xpZW50Lmxvb2t1cFJlYWN0aW9uQnlJZCh7IGZpZCwgdGFyZ2V0RmlkLCB0YXJnZXRIYXNoLCByZWFjdGlvblR5cGUgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtcmVhY3Rpb24tYnktaWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBsb29rdXBSZWFjdGlvbkJ5SWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnJlYWN0aW9uc0FwaS5sb29rdXBSZWFjdGlvbkJ5SWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSB1c2VyXFwncyBzdG9yYWdlIGxpbWl0cy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEZJRFxcJ3MgbGltaXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VMaW1pdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VMaW1pdHNSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICpcbiAgICAgKiBjbGllbnQubG9va3VwVXNlclN0b3JhZ2VMaW1pdCh7IGZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXN0b3JhZ2UtbGltaXQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBsb29rdXBVc2VyU3RvcmFnZUxpbWl0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy5zdG9yYWdlQXBpLmxvb2t1cFVzZXJTdG9yYWdlTGltaXQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogKipOb3RlOioqIG9uZSBvZiB0d28gZGlmZmVyZW50IHJlc3BvbnNlIHNjaGVtYXMgaXMgcmV0dXJuZWQgYmFzZWQgb24gd2hldGhlciB0aGUgY2FsbGVyIHByb3ZpZGVzIHRoZSBgdXNlcl9kYXRhX3R5cGVgIHBhcmFtZXRlci4gSWYgaW5jbHVkZWQsIGEgc2luZ2xlIGBVc2VyRGF0YUFkZGAgbWVzc2FnZSBpcyByZXR1cm5lZCAob3IgYSBgbm90X2ZvdW5kYCBlcnJvcikuIElmIG9taXR0ZWQsIGEgcGFnaW5hdGVkIGxpc3Qgb2YgYFVzZXJEYXRhQWRkYCBtZXNzYWdlcyBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggVXNlckRhdGEgZm9yIGEgRklEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5maWQgIC0gVGhlIEZJRCB0aGF0J3MgYmVpbmcgcmVxdWVzdGVkXG4gICAgICogQHBhcmFtIHtVc2VyRGF0YVR5cGV9IHBhcmFtcy51c2VyRGF0YVR5cGUgW29wdGlvbmFsXSAgLSBUaGUgdHlwZSBvZiB1c2VyIGRhdGEsIGVpdGhlciBhcyBhIG51bWVyaWNhbCB2YWx1ZSBvciB0eXBlIHN0cmluZy4gSWYgdGhpcyBpcyBvbWl0dGVkLCBhbGwgdXNlciBkYXRhIGZvciB0aGUgRklEIGlzIHJldHVybmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5wYWdlU2l6ZSBbb3B0aW9uYWxdICAtIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgW29wdGlvbmFsXSAgLSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wYWdlVG9rZW4gW29wdGlvbmFsXSAgLSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VyRGF0YTIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyRGF0YTIwMFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgZmlkID1cbiAgICAgKiBjb25zdCB1c2VyRGF0YVR5cGUgPVxuICAgICAqIGNvbnN0IHBhZ2VTaXplID1cbiAgICAgKiBjb25zdCByZXZlcnNlID1cbiAgICAgKiBjb25zdCBwYWdlVG9rZW4gPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlckRhdGEoeyBmaWQsIHVzZXJEYXRhVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZGF0YSlcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVXNlckRhdGEocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJEYXRhQXBpLmZldGNoVXNlckRhdGEoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBwcm9vZiBmb3IgYSB1c2VybmFtZS5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFByb29mIGZvciBhIHVzZXJuYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lICAtIFRoZSBGYXJjYXN0ZXIgdXNlcm5hbWUgb3IgRU5TIGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJOYW1lUHJvb2Y+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyTmFtZVByb29mYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gRmlsbCBpbiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzXG4gICAgICogY29uc3QgbmFtZSA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lKHsgbmFtZSB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJuYW1lLXByb29mLWJ5LW5hbWUpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFVzZXJuYW1lUHJvb2ZCeU5hbWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJuYW1lc0FwaS5mZXRjaFVzZXJuYW1lUHJvb2ZCeU5hbWUoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggcHJvb2ZzIHByb3ZpZGVkIGJ5IGEgdXNlci5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IFByb29mcyBwcm92aWRlZCBieSBhbiBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIGJlaW5nIHJlcXVlc3RlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcm5hbWVQcm9vZnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJuYW1lUHJvb2ZzUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBGaWxsIGluIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbiAgICAgKiBjb25zdCBmaWQgPVxuICAgICAqXG4gICAgICogY2xpZW50LmZldGNoVXNlcm5hbWVQcm9vZnNCeUZpZCh7IGZpZCB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdyZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJuYW1lLXByb29mcy1ieS1maWQpXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaFVzZXJuYW1lUHJvb2ZzQnlGaWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkUGFyYW1zID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWRqdXN0ZWRQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGlzLnVzZXJuYW1lc0FwaS5mZXRjaFVzZXJuYW1lUHJvb2ZzQnlGaWQoYWRqdXN0ZWRQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdmVyaWZpY2F0aW9ucyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBQcm92aWRlZCBieSBhbiBGSURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmZpZCAgLSBUaGUgRklEIGJlaW5nIHJlcXVlc3RlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyBbb3B0aW9uYWxdICAtIFRoZSBvcHRpb25hbCBFVEggYWRkcmVzcyB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBhZ2VTaXplIFtvcHRpb25hbF0gIC0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMucmV2ZXJzZSBbb3B0aW9uYWxdICAtIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBhZ2VUb2tlbiBbb3B0aW9uYWxdICAtIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFZlcmlmaWNhdGlvbnNCeUZpZDIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hWZXJpZmljYXRpb25zQnlGaWQyMDBSZXNwb25zZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEZpbGwgaW4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlc1xuICAgICAqIGNvbnN0IGZpZCA9XG4gICAgICogY29uc3QgYWRkcmVzcyA9XG4gICAgICogY29uc3QgcGFnZVNpemUgPVxuICAgICAqIGNvbnN0IHJldmVyc2UgPVxuICAgICAqIGNvbnN0IHBhZ2VUb2tlbiA9XG4gICAgICpcbiAgICAgKiBjbGllbnQuZmV0Y2hWZXJpZmljYXRpb25zQnlGaWQoeyBmaWQsIGFkZHJlc3MsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4gfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12ZXJpZmljYXRpb25zLWJ5LWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoVmVyaWZpY2F0aW9uc0J5RmlkKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKGFkanVzdGVkUGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpcy52ZXJpZmljYXRpb25zQXBpLmZldGNoVmVyaWZpY2F0aW9uc0J5RmlkKGFkanVzdGVkUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5OZXluYXJIdWJDbGllbnQgPSBOZXluYXJIdWJDbGllbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarHubClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/clients/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(params) {\n        this.apiKey = params.apiKey;\n        this.basePath = params.basePath;\n        this.baseOptions = params.baseOptions;\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NsaWVudHMvY29uZmlndXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvY2xpZW50cy9jb25maWd1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gcGFyYW1zLmFwaUtleTtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHBhcmFtcy5iYXNlUGF0aDtcbiAgICAgICAgdGhpcy5iYXNlT3B0aW9ucyA9IHBhcmFtcy5iYXNlT3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/clients/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NeynarHubClient = exports.NeynarAPIClient = void 0;\nvar NeynarAPIClient_1 = __webpack_require__(/*! ./NeynarAPIClient */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarAPIClient.js\");\nObject.defineProperty(exports, \"NeynarAPIClient\", ({ enumerable: true, get: function () { return NeynarAPIClient_1.NeynarAPIClient; } }));\nvar NeynarHubClient_1 = __webpack_require__(/*! ./NeynarHubClient */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/NeynarHubClient.js\");\nObject.defineProperty(exports, \"NeynarHubClient\", ({ enumerable: true, get: function () { return NeynarHubClient_1.NeynarHubClient; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NsaWVudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLG1HQUFtQjtBQUNuRCxtREFBa0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDdkksd0JBQXdCLG1CQUFPLENBQUMsbUdBQW1CO0FBQ25ELG1EQUFrRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9jbGllbnRzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXluYXJIdWJDbGllbnQgPSBleHBvcnRzLk5leW5hckFQSUNsaWVudCA9IHZvaWQgMDtcbnZhciBOZXluYXJBUElDbGllbnRfMSA9IHJlcXVpcmUoXCIuL05leW5hckFQSUNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5leW5hckFQSUNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmV5bmFyQVBJQ2xpZW50XzEuTmV5bmFyQVBJQ2xpZW50OyB9IH0pO1xudmFyIE5leW5hckh1YkNsaWVudF8xID0gcmVxdWlyZShcIi4vTmV5bmFySHViQ2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV5bmFySHViQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOZXluYXJIdWJDbGllbnRfMS5OZXluYXJIdWJDbGllbnQ7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/common/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SIGNED_KEY_REQUEST_TYPE = exports.SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN = void 0;\n// DO NOT CHANGE ANY VALUES IN THIS CONSTANT\nexports.SIGNED_KEY_REQUEST_VALIDATOR_EIP_712_DOMAIN = {\n    name: \"Farcaster SignedKeyRequestValidator\",\n    version: \"1\",\n    chainId: 10,\n    verifyingContract: \"0x00000000fc700472606ed4fa22623acf62c60553\",\n};\n// DO NOT CHANGE ANY VALUES IN THIS CONSTANT\nexports.SIGNED_KEY_REQUEST_TYPE = [\n    { name: \"requestFid\", type: \"uint256\" },\n    { name: \"key\", type: \"bytes\" },\n    { name: \"deadline\", type: \"uint256\" },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NvbW1vbi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsbURBQW1EO0FBQ3JGO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixNQUFNLHFDQUFxQztBQUMzQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLG1DQUFtQztBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9jb21tb24vY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSUdORURfS0VZX1JFUVVFU1RfVFlQRSA9IGV4cG9ydHMuU0lHTkVEX0tFWV9SRVFVRVNUX1ZBTElEQVRPUl9FSVBfNzEyX0RPTUFJTiA9IHZvaWQgMDtcbi8vIERPIE5PVCBDSEFOR0UgQU5ZIFZBTFVFUyBJTiBUSElTIENPTlNUQU5UXG5leHBvcnRzLlNJR05FRF9LRVlfUkVRVUVTVF9WQUxJREFUT1JfRUlQXzcxMl9ET01BSU4gPSB7XG4gICAgbmFtZTogXCJGYXJjYXN0ZXIgU2lnbmVkS2V5UmVxdWVzdFZhbGlkYXRvclwiLFxuICAgIHZlcnNpb246IFwiMVwiLFxuICAgIGNoYWluSWQ6IDEwLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcIjB4MDAwMDAwMDBmYzcwMDQ3MjYwNmVkNGZhMjI2MjNhY2Y2MmM2MDU1M1wiLFxufTtcbi8vIERPIE5PVCBDSEFOR0UgQU5ZIFZBTFVFUyBJTiBUSElTIENPTlNUQU5UXG5leHBvcnRzLlNJR05FRF9LRVlfUkVRVUVTVF9UWVBFID0gW1xuICAgIHsgbmFtZTogXCJyZXF1ZXN0RmlkXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgeyBuYW1lOiBcImtleVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICB7IG5hbWU6IFwiZGVhZGxpbmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/logger.js":
/*!****************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/common/logger.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-empty-function */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.silentLogger = void 0;\nexports.silentLogger = {\n    trace: (_message, ..._optionalParams) => { },\n    debug: (_message, ..._optionalParams) => { },\n    info: (_message, ..._optionalParams) => { },\n    warn: (_message, ..._optionalParams) => { },\n    error: (_message, ..._optionalParams) => { },\n};\n/* eslint-enable @typescript-eslint/no-unused-vars */\n/* eslint-enable @typescript-eslint/no-explicit-any */\n/* eslint-enable @typescript-eslint/no-empty-function */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NvbW1vbi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0MsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2NvbW1vbi9sb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWxlbnRMb2dnZXIgPSB2b2lkIDA7XG5leHBvcnRzLnNpbGVudExvZ2dlciA9IHtcbiAgICB0cmFjZTogKF9tZXNzYWdlLCAuLi5fb3B0aW9uYWxQYXJhbXMpID0+IHsgfSxcbiAgICBkZWJ1ZzogKF9tZXNzYWdlLCAuLi5fb3B0aW9uYWxQYXJhbXMpID0+IHsgfSxcbiAgICBpbmZvOiAoX21lc3NhZ2UsIC4uLl9vcHRpb25hbFBhcmFtcykgPT4geyB9LFxuICAgIHdhcm46IChfbWVzc2FnZSwgLi4uX29wdGlvbmFsUGFyYW1zKSA9PiB7IH0sXG4gICAgZXJyb3I6IChfbWVzc2FnZSwgLi4uX29wdGlvbmFsUGFyYW1zKSA9PiB7IH0sXG59O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/common/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/casts-api.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/casts-api.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CastsApi = exports.CastsApiFactory = exports.CastsApiFp = exports.CastsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * CastsApi - axios parameter creator\n * @export\n */\nconst CastsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.\n         * @summary By parent cast\n         * @param {number} [fid] The Farcaster ID (FID) of the parent cast\\&#39;s creator. This parameter must be used together with the \\&#39;hash\\&#39; parameter to uniquely identify a parent cast. Required only when using hash-based lookup instead of URL-based lookup. The FID is a unique identifier assigned to each Farcaster user.\n         * @param {string} [hash] The unique hash identifier of the parent cast. Must be used together with the \\&#39;fid\\&#39; parameter when doing hash-based lookup. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies the cast within the creator\\&#39;s posts. Not required if using URL-based lookup.\n         * @param {string} [url] Cast URL starting with \\&#39;chain://\\&#39;\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)\n         *\n         */\n        fetchCastsByParent: async (fid, hash, url, pageSize, reverse, pageToken, options = {}) => {\n            const localVarPath = `/v1/castsByParent`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (hash !== undefined) {\n                localVarQueryParameter['hash'] = hash;\n            }\n            if (url !== undefined) {\n                localVarQueryParameter['url'] = url;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch casts mentioning a user.\n         * @summary Mentioning an FID\n         * @param {number} fid The FID that is mentioned in a cast\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)\n         *\n         */\n        fetchCastsMentioningUser: async (fid, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastsMentioningUser', 'fid', fid);\n            const localVarPath = `/v1/castsByMention`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch user\\'s casts.\n         * @summary By FID\n         * @param {number} fid The FID of the casts\\&#39; creator\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)\n         *\n         */\n        fetchUsersCasts: async (fid, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsersCasts', 'fid', fid);\n            const localVarPath = `/v1/castsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Lookup a cast by its FID and hash.\n         * @summary By FID and Hash\n         * @param {number} fid The FID of the cast\\&#39;s creator\n         * @param {string} hash The unique hash identifier of the cast. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies a specific cast in the Farcaster network.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)\n         *\n         */\n        lookupCastByHashAndFid: async (fid, hash, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastByHashAndFid', 'fid', fid);\n            // verify required parameter 'hash' is not null or undefined\n            (0, common_1.assertParamExists)('lookupCastByHashAndFid', 'hash', hash);\n            const localVarPath = `/v1/castById`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (hash !== undefined) {\n                localVarQueryParameter['hash'] = hash;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.CastsApiAxiosParamCreator = CastsApiAxiosParamCreator;\n/**\n * CastsApi - functional programming interface\n * @export\n */\nconst CastsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.CastsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.\n         * @summary By parent cast\n         * @param {number} [fid] The Farcaster ID (FID) of the parent cast\\&#39;s creator. This parameter must be used together with the \\&#39;hash\\&#39; parameter to uniquely identify a parent cast. Required only when using hash-based lookup instead of URL-based lookup. The FID is a unique identifier assigned to each Farcaster user.\n         * @param {string} [hash] The unique hash identifier of the parent cast. Must be used together with the \\&#39;fid\\&#39; parameter when doing hash-based lookup. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies the cast within the creator\\&#39;s posts. Not required if using URL-based lookup.\n         * @param {string} [url] Cast URL starting with \\&#39;chain://\\&#39;\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)\n         *\n         */\n        async fetchCastsByParent(fid, hash, url, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastsByParent(fid, hash, url, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastsApi.fetchCastsByParent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch casts mentioning a user.\n         * @summary Mentioning an FID\n         * @param {number} fid The FID that is mentioned in a cast\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)\n         *\n         */\n        async fetchCastsMentioningUser(fid, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastsMentioningUser(fid, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastsApi.fetchCastsMentioningUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch user\\'s casts.\n         * @summary By FID\n         * @param {number} fid The FID of the casts\\&#39; creator\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)\n         *\n         */\n        async fetchUsersCasts(fid, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsersCasts(fid, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastsApi.fetchUsersCasts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Lookup a cast by its FID and hash.\n         * @summary By FID and Hash\n         * @param {number} fid The FID of the cast\\&#39;s creator\n         * @param {string} hash The unique hash identifier of the cast. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies a specific cast in the Farcaster network.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)\n         *\n         */\n        async lookupCastByHashAndFid(fid, hash, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupCastByHashAndFid(fid, hash, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CastsApi.lookupCastByHashAndFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.CastsApiFp = CastsApiFp;\n/**\n * CastsApi - factory interface\n * @export\n */\nconst CastsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.CastsApiFp)(configuration);\n    return {\n        /**\n         * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.\n         * @summary By parent cast\n         * @param {CastsApiFetchCastsByParentRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)\n         *\n         */\n        fetchCastsByParent(requestParameters = {}, options) {\n            return localVarFp.fetchCastsByParent(requestParameters.fid, requestParameters.hash, requestParameters.url, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch casts mentioning a user.\n         * @summary Mentioning an FID\n         * @param {CastsApiFetchCastsMentioningUserRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)\n         *\n         */\n        fetchCastsMentioningUser(requestParameters, options) {\n            return localVarFp.fetchCastsMentioningUser(requestParameters.fid, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch user\\'s casts.\n         * @summary By FID\n         * @param {CastsApiFetchUsersCastsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)\n         *\n         */\n        fetchUsersCasts(requestParameters, options) {\n            return localVarFp.fetchUsersCasts(requestParameters.fid, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Lookup a cast by its FID and hash.\n         * @summary By FID and Hash\n         * @param {CastsApiLookupCastByHashAndFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)\n         *\n         */\n        lookupCastByHashAndFid(requestParameters, options) {\n            return localVarFp.lookupCastByHashAndFid(requestParameters.fid, requestParameters.hash, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.CastsApiFactory = CastsApiFactory;\n/**\n * CastsApi - object-oriented interface\n * @export\n * @class CastsApi\n * @extends {BaseAPI}\n */\nclass CastsApi extends base_1.BaseAPI {\n    /**\n     * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.\n     * @summary By parent cast\n     * @param {CastsApiFetchCastsByParentRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastsApi\n     * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)\n     *\n     */\n    fetchCastsByParent(requestParameters = {}, options) {\n        return (0, exports.CastsApiFp)(this.configuration).fetchCastsByParent(requestParameters.fid, requestParameters.hash, requestParameters.url, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch casts mentioning a user.\n     * @summary Mentioning an FID\n     * @param {CastsApiFetchCastsMentioningUserRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastsApi\n     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)\n     *\n     */\n    fetchCastsMentioningUser(requestParameters, options) {\n        return (0, exports.CastsApiFp)(this.configuration).fetchCastsMentioningUser(requestParameters.fid, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch user\\'s casts.\n     * @summary By FID\n     * @param {CastsApiFetchUsersCastsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastsApi\n     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)\n     *\n     */\n    fetchUsersCasts(requestParameters, options) {\n        return (0, exports.CastsApiFp)(this.configuration).fetchUsersCasts(requestParameters.fid, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Lookup a cast by its FID and hash.\n     * @summary By FID and Hash\n     * @param {CastsApiLookupCastByHashAndFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CastsApi\n     * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)\n     *\n     */\n    lookupCastByHashAndFid(requestParameters, options) {\n        return (0, exports.CastsApiFp)(this.configuration).lookupCastByHashAndFid(requestParameters.fid, requestParameters.hash, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.CastsApi = CastsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9jYXN0cy1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQztBQUNuRyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEscURBQXFELCtEQUErRCxXQUFXO0FBQzFKLG1CQUFtQixRQUFRLDJGQUEyRixVQUFVLHNHQUFzRyxTQUFTLDBEQUEwRDtBQUN6UyxtQkFBbUIsUUFBUSxtQ0FBbUM7QUFDOUQsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9jYXN0cy1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhc3RzQXBpID0gZXhwb3J0cy5DYXN0c0FwaUZhY3RvcnkgPSBleHBvcnRzLkNhc3RzQXBpRnAgPSBleHBvcnRzLkNhc3RzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBDYXN0c0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENhc3RzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBhbGwgcmVwbHkgY2FzdHMgKHJlc3BvbnNlcykgdG8gYSBzcGVjaWZpYyBwYXJlbnQgY2FzdCBpbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFBhcmVudCBjYXN0cyBjYW4gYmUgaWRlbnRpZmllZCB1c2luZyBlaXRoZXIgYSBjb21iaW5hdGlvbiBvZiBGSUQgYW5kIGhhc2gsIG9yIGJ5IHRoZWlyIFVSTC4gVGhpcyBlbmRwb2ludCBlbmFibGVzIHRyYXZlcnNhbCBvZiBjb252ZXJzYXRpb24gdGhyZWFkcyBhbmQgcmV0cmlldmFsIG9mIGFsbCByZXNwb25zZXMgdG8gYSBwYXJ0aWN1bGFyIGNhc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IHBhcmVudCBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmlkXSBUaGUgRmFyY2FzdGVyIElEIChGSUQpIG9mIHRoZSBwYXJlbnQgY2FzdFxcJiMzOTtzIGNyZWF0b3IuIFRoaXMgcGFyYW1ldGVyIG11c3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBcXCYjMzk7aGFzaFxcJiMzOTsgcGFyYW1ldGVyIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGEgcGFyZW50IGNhc3QuIFJlcXVpcmVkIG9ubHkgd2hlbiB1c2luZyBoYXNoLWJhc2VkIGxvb2t1cCBpbnN0ZWFkIG9mIFVSTC1iYXNlZCBsb29rdXAuIFRoZSBGSUQgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBhc3NpZ25lZCB0byBlYWNoIEZhcmNhc3RlciB1c2VyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdIFRoZSB1bmlxdWUgaGFzaCBpZGVudGlmaWVyIG9mIHRoZSBwYXJlbnQgY2FzdC4gTXVzdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIFxcJiMzOTtmaWRcXCYjMzk7IHBhcmFtZXRlciB3aGVuIGRvaW5nIGhhc2gtYmFzZWQgbG9va3VwLiBUaGlzIGlzIGEgNDAtY2hhcmFjdGVyIGhleGFkZWNpbWFsIHN0cmluZyBwcmVmaXhlZCB3aXRoIFxcJiMzOTsweFxcJiMzOTsgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBjYXN0IHdpdGhpbiB0aGUgY3JlYXRvclxcJiMzOTtzIHBvc3RzLiBOb3QgcmVxdWlyZWQgaWYgdXNpbmcgVVJMLWJhc2VkIGxvb2t1cC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdIENhc3QgVVJMIHN0YXJ0aW5nIHdpdGggXFwmIzM5O2NoYWluOi8vXFwmIzM5O1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0c0J5UGFyZW50MjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RzQnlQYXJlbnQyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtYnktcGFyZW50KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDYXN0c0J5UGFyZW50OiBhc3luYyAoZmlkLCBoYXNoLCB1cmwsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9jYXN0c0J5UGFyZW50YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnaGFzaCddID0gaGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlU2l6ZSddID0gcGFnZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmV2ZXJzZSddID0gcmV2ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggY2FzdHMgbWVudGlvbmluZyBhIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IE1lbnRpb25pbmcgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCB0aGF0IGlzIG1lbnRpb25lZCBpbiBhIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3RzLW1lbnRpb25pbmctdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoQ2FzdHNNZW50aW9uaW5nVXNlcjogYXN5bmMgKGZpZCwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hDYXN0c01lbnRpb25pbmdVc2VyJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2Nhc3RzQnlNZW50aW9uYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VTaXplJ10gPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVRva2VuJ10gPSBwYWdlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB1c2VyXFwncyBjYXN0cy5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgY2FzdHNcXCYjMzk7IGNyZWF0b3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWNhc3RzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2Vyc0Nhc3RzOiBhc3luYyAoZmlkLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFVzZXJzQ2FzdHMnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvY2FzdHNCeUZpZGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlU2l6ZSddID0gcGFnZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmV2ZXJzZSddID0gcmV2ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGEgY2FzdCBieSBpdHMgRklEIGFuZCBoYXNoLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSUQgYW5kIEhhc2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSBjYXN0XFwmIzM5O3MgY3JlYXRvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBUaGUgdW5pcXVlIGhhc2ggaWRlbnRpZmllciBvZiB0aGUgY2FzdC4gVGhpcyBpcyBhIDQwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcgcHJlZml4ZWQgd2l0aCBcXCYjMzk7MHhcXCYjMzk7IHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhIHNwZWNpZmljIGNhc3QgaW4gdGhlIEZhcmNhc3RlciBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0QWRkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdEFkZGAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWNhc3QtYnktaGFzaC1hbmQtZmlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwQ2FzdEJ5SGFzaEFuZEZpZDogYXN5bmMgKGZpZCwgaGFzaCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwQ2FzdEJ5SGFzaEFuZEZpZCcsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnaGFzaCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBDYXN0QnlIYXNoQW5kRmlkJywgJ2hhc2gnLCBoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvY2FzdEJ5SWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydoYXNoJ10gPSBoYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5DYXN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gQ2FzdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQ2FzdHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBDYXN0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQ2FzdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGFsbCByZXBseSBjYXN0cyAocmVzcG9uc2VzKSB0byBhIHNwZWNpZmljIHBhcmVudCBjYXN0IGluIHRoZSBGYXJjYXN0ZXIgbmV0d29yay4gUGFyZW50IGNhc3RzIGNhbiBiZSBpZGVudGlmaWVkIHVzaW5nIGVpdGhlciBhIGNvbWJpbmF0aW9uIG9mIEZJRCBhbmQgaGFzaCwgb3IgYnkgdGhlaXIgVVJMLiBUaGlzIGVuZHBvaW50IGVuYWJsZXMgdHJhdmVyc2FsIG9mIGNvbnZlcnNhdGlvbiB0aHJlYWRzIGFuZCByZXRyaWV2YWwgb2YgYWxsIHJlc3BvbnNlcyB0byBhIHBhcnRpY3VsYXIgY2FzdC5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgcGFyZW50IGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtmaWRdIFRoZSBGYXJjYXN0ZXIgSUQgKEZJRCkgb2YgdGhlIHBhcmVudCBjYXN0XFwmIzM5O3MgY3JlYXRvci4gVGhpcyBwYXJhbWV0ZXIgbXVzdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIFxcJiMzOTtoYXNoXFwmIzM5OyBwYXJhbWV0ZXIgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYSBwYXJlbnQgY2FzdC4gUmVxdWlyZWQgb25seSB3aGVuIHVzaW5nIGhhc2gtYmFzZWQgbG9va3VwIGluc3RlYWQgb2YgVVJMLWJhc2VkIGxvb2t1cC4gVGhlIEZJRCBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGFzc2lnbmVkIHRvIGVhY2ggRmFyY2FzdGVyIHVzZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF0gVGhlIHVuaXF1ZSBoYXNoIGlkZW50aWZpZXIgb2YgdGhlIHBhcmVudCBjYXN0LiBNdXN0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgXFwmIzM5O2ZpZFxcJiMzOTsgcGFyYW1ldGVyIHdoZW4gZG9pbmcgaGFzaC1iYXNlZCBsb29rdXAuIFRoaXMgaXMgYSA0MC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgc3RyaW5nIHByZWZpeGVkIHdpdGggXFwmIzM5OzB4XFwmIzM5OyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGNhc3Qgd2l0aGluIHRoZSBjcmVhdG9yXFwmIzM5O3MgcG9zdHMuIE5vdCByZXF1aXJlZCBpZiB1c2luZyBVUkwtYmFzZWQgbG9va3VwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF0gQ2FzdCBVUkwgc3RhcnRpbmcgd2l0aCBcXCYjMzk7Y2hhaW46Ly9cXCYjMzk7XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaENhc3RzQnlQYXJlbnQyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoQ2FzdHNCeVBhcmVudDIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0cy1ieS1wYXJlbnQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaENhc3RzQnlQYXJlbnQoZmlkLCBoYXNoLCB1cmwsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2FzdHNCeVBhcmVudChmaWQsIGhhc2gsIHVybCwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Nhc3RzQXBpLmZldGNoQ2FzdHNCeVBhcmVudCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggY2FzdHMgbWVudGlvbmluZyBhIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IE1lbnRpb25pbmcgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCB0aGF0IGlzIG1lbnRpb25lZCBpbiBhIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3RzLW1lbnRpb25pbmctdXNlcilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoQ2FzdHNNZW50aW9uaW5nVXNlcihmaWQsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoQ2FzdHNNZW50aW9uaW5nVXNlcihmaWQsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDYXN0c0FwaS5mZXRjaENhc3RzTWVudGlvbmluZ1VzZXInXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHVzZXJcXCdzIGNhc3RzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSBjYXN0c1xcJiMzOTsgY3JlYXRvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJzQ2FzdHMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcnMtY2FzdHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJzQ2FzdHMoZmlkLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJzQ2FzdHMoZmlkLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ2FzdHNBcGkuZmV0Y2hVc2Vyc0Nhc3RzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSBjYXN0IGJ5IGl0cyBGSUQgYW5kIGhhc2guXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBhbmQgSGFzaFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgb2YgdGhlIGNhc3RcXCYjMzk7cyBjcmVhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIFRoZSB1bmlxdWUgaGFzaCBpZGVudGlmaWVyIG9mIHRoZSBjYXN0LiBUaGlzIGlzIGEgNDAtY2hhcmFjdGVyIGhleGFkZWNpbWFsIHN0cmluZyBwcmVmaXhlZCB3aXRoIFxcJiMzOTsweFxcJiMzOTsgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIGEgc3BlY2lmaWMgY2FzdCBpbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RBZGQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0QWRkYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2FzdC1ieS1oYXNoLWFuZC1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsb29rdXBDYXN0QnlIYXNoQW5kRmlkKGZpZCwgaGFzaCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwQ2FzdEJ5SGFzaEFuZEZpZChmaWQsIGhhc2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDYXN0c0FwaS5sb29rdXBDYXN0QnlIYXNoQW5kRmlkJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNhc3RzQXBpRnAgPSBDYXN0c0FwaUZwO1xuLyoqXG4gKiBDYXN0c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENhc3RzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQ2FzdHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGFsbCByZXBseSBjYXN0cyAocmVzcG9uc2VzKSB0byBhIHNwZWNpZmljIHBhcmVudCBjYXN0IGluIHRoZSBGYXJjYXN0ZXIgbmV0d29yay4gUGFyZW50IGNhc3RzIGNhbiBiZSBpZGVudGlmaWVkIHVzaW5nIGVpdGhlciBhIGNvbWJpbmF0aW9uIG9mIEZJRCBhbmQgaGFzaCwgb3IgYnkgdGhlaXIgVVJMLiBUaGlzIGVuZHBvaW50IGVuYWJsZXMgdHJhdmVyc2FsIG9mIGNvbnZlcnNhdGlvbiB0aHJlYWRzIGFuZCByZXRyaWV2YWwgb2YgYWxsIHJlc3BvbnNlcyB0byBhIHBhcnRpY3VsYXIgY2FzdC5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgcGFyZW50IGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtDYXN0c0FwaUZldGNoQ2FzdHNCeVBhcmVudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0c0J5UGFyZW50MjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RzQnlQYXJlbnQyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdHMtYnktcGFyZW50KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDYXN0c0J5UGFyZW50KHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ2FzdHNCeVBhcmVudChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmhhc2gsIHJlcXVlc3RQYXJhbWV0ZXJzLnVybCwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVNpemUsIHJlcXVlc3RQYXJhbWV0ZXJzLnJldmVyc2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VUb2tlbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGNhc3RzIG1lbnRpb25pbmcgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBNZW50aW9uaW5nIGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0Nhc3RzQXBpRmV0Y2hDYXN0c01lbnRpb25pbmdVc2VyUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJzQ2FzdHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0cy1tZW50aW9uaW5nLXVzZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENhc3RzTWVudGlvbmluZ1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoQ2FzdHNNZW50aW9uaW5nVXNlcihyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB1c2VyXFwncyBjYXN0cy5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgRklEXG4gICAgICAgICAqIEBwYXJhbSB7Q2FzdHNBcGlGZXRjaFVzZXJzQ2FzdHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJzLWNhc3RzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2Vyc0Nhc3RzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJzQ2FzdHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGEgY2FzdCBieSBpdHMgRklEIGFuZCBoYXNoLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSUQgYW5kIEhhc2hcbiAgICAgICAgICogQHBhcmFtIHtDYXN0c0FwaUxvb2t1cENhc3RCeUhhc2hBbmRGaWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENhc3RBZGQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBDYXN0QWRkYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtY2FzdC1ieS1oYXNoLWFuZC1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBDYXN0QnlIYXNoQW5kRmlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBDYXN0QnlIYXNoQW5kRmlkKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMuaGFzaCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ2FzdHNBcGlGYWN0b3J5ID0gQ2FzdHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBDYXN0c0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBDYXN0c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIENhc3RzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCByZXBseSBjYXN0cyAocmVzcG9uc2VzKSB0byBhIHNwZWNpZmljIHBhcmVudCBjYXN0IGluIHRoZSBGYXJjYXN0ZXIgbmV0d29yay4gUGFyZW50IGNhc3RzIGNhbiBiZSBpZGVudGlmaWVkIHVzaW5nIGVpdGhlciBhIGNvbWJpbmF0aW9uIG9mIEZJRCBhbmQgaGFzaCwgb3IgYnkgdGhlaXIgVVJMLiBUaGlzIGVuZHBvaW50IGVuYWJsZXMgdHJhdmVyc2FsIG9mIGNvbnZlcnNhdGlvbiB0aHJlYWRzIGFuZCByZXRyaWV2YWwgb2YgYWxsIHJlc3BvbnNlcyB0byBhIHBhcnRpY3VsYXIgY2FzdC5cbiAgICAgKiBAc3VtbWFyeSBCeSBwYXJlbnQgY2FzdFxuICAgICAqIEBwYXJhbSB7Q2FzdHNBcGlGZXRjaENhc3RzQnlQYXJlbnRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDYXN0c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdHNCeVBhcmVudDIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0c0J5UGFyZW50MjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0cy1ieS1wYXJlbnQpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaENhc3RzQnlQYXJlbnQocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaENhc3RzQnlQYXJlbnQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5oYXNoLCByZXF1ZXN0UGFyYW1ldGVycy51cmwsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBjYXN0cyBtZW50aW9uaW5nIGEgdXNlci5cbiAgICAgKiBAc3VtbWFyeSBNZW50aW9uaW5nIGFuIEZJRFxuICAgICAqIEBwYXJhbSB7Q2FzdHNBcGlGZXRjaENhc3RzTWVudGlvbmluZ1VzZXJSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDYXN0c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0cy1tZW50aW9uaW5nLXVzZXIpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaENhc3RzTWVudGlvbmluZ1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNhc3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hDYXN0c01lbnRpb25pbmdVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVNpemUsIHJlcXVlc3RQYXJhbWV0ZXJzLnJldmVyc2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VUb2tlbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHVzZXJcXCdzIGNhc3RzLlxuICAgICAqIEBzdW1tYXJ5IEJ5IEZJRFxuICAgICAqIEBwYXJhbSB7Q2FzdHNBcGlGZXRjaFVzZXJzQ2FzdHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDYXN0c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlcnNDYXN0czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2Vyc0Nhc3RzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2Vycy1jYXN0cylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlcnNDYXN0cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ2FzdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJzQ2FzdHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgY2FzdCBieSBpdHMgRklEIGFuZCBoYXNoLlxuICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBhbmQgSGFzaFxuICAgICAqIEBwYXJhbSB7Q2FzdHNBcGlMb29rdXBDYXN0QnlIYXNoQW5kRmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ2FzdHNBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYXN0QWRkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgQ2FzdEFkZGAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1jYXN0LWJ5LWhhc2gtYW5kLWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cENhc3RCeUhhc2hBbmRGaWQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNhc3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwQ2FzdEJ5SGFzaEFuZEZpZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmhhc2gsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FzdHNBcGkgPSBDYXN0c0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/casts-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/fids-api.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/fids-api.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FidsApi = exports.FidsApiFactory = exports.FidsApiFp = exports.FidsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * FidsApi - axios parameter creator\n * @export\n */\nconst FidsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a list of all the FIDs.\n         * @summary Fetch a list of all the FIDs\n         * @param {number} shardId The shard ID to filter by\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)\n         *\n         */\n        fetchFids: async (shardId, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'shardId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchFids', 'shardId', shardId);\n            const localVarPath = `/v1/fids`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (shardId !== undefined) {\n                localVarQueryParameter['shard_id'] = shardId;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FidsApiAxiosParamCreator = FidsApiAxiosParamCreator;\n/**\n * FidsApi - functional programming interface\n * @export\n */\nconst FidsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FidsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a list of all the FIDs.\n         * @summary Fetch a list of all the FIDs\n         * @param {number} shardId The shard ID to filter by\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)\n         *\n         */\n        async fetchFids(shardId, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFids(shardId, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FidsApi.fetchFids']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FidsApiFp = FidsApiFp;\n/**\n * FidsApi - factory interface\n * @export\n */\nconst FidsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FidsApiFp)(configuration);\n    return {\n        /**\n         * Fetch a list of all the FIDs.\n         * @summary Fetch a list of all the FIDs\n         * @param {FidsApiFetchFidsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)\n         *\n         */\n        fetchFids(requestParameters, options) {\n            return localVarFp.fetchFids(requestParameters.shardId, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FidsApiFactory = FidsApiFactory;\n/**\n * FidsApi - object-oriented interface\n * @export\n * @class FidsApi\n * @extends {BaseAPI}\n */\nclass FidsApi extends base_1.BaseAPI {\n    /**\n     * Fetch a list of all the FIDs.\n     * @summary Fetch a list of all the FIDs\n     * @param {FidsApiFetchFidsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FidsApi\n     * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)\n     *\n     */\n    fetchFids(requestParameters, options) {\n        return (0, exports.FidsApiFp)(this.configuration).fetchFids(requestParameters.shardId, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FidsApi = FidsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9maWRzLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGdDQUFnQztBQUMvRixnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvaHViLWFwaS9hcGlzL2ZpZHMtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBIdWIgQVBJXG4gKiBQZXJmb3JtIGJhc2ljIHF1ZXJpZXMgb2YgRmFyY2FzdGVyIHN0YXRlIHZpYSB0aGUgUkVTVCBBUEkgb2YgYSBGYXJjYXN0ZXIgaHViLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjM1LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWRzQXBpID0gZXhwb3J0cy5GaWRzQXBpRmFjdG9yeSA9IGV4cG9ydHMuRmlkc0FwaUZwID0gZXhwb3J0cy5GaWRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBGaWRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRmlkc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2hhcmRJZCBUaGUgc2hhcmQgSUQgdG8gZmlsdGVyIGJ5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaWRzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWRzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZpZHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEZpZHM6IGFzeW5jIChzaGFyZElkLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NoYXJkSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hGaWRzJywgJ3NoYXJkSWQnLCBzaGFyZElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvZmlkc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChzaGFyZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzaGFyZF9pZCddID0gc2hhcmRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVNpemUnXSA9IHBhZ2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldmVyc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3JldmVyc2UnXSA9IHJldmVyc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlVG9rZW4nXSA9IHBhZ2VUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRmlkc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gRmlkc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBGaWRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRmlkc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuRmlkc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2hhcmRJZCBUaGUgc2hhcmQgSUQgdG8gZmlsdGVyIGJ5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaWRzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGaWRzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZpZHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEZpZHMoc2hhcmRJZCwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hGaWRzKHNoYXJkSWQsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGaWRzQXBpLmZldGNoRmlkcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5GaWRzQXBpRnAgPSBGaWRzQXBpRnA7XG4vKipcbiAqIEZpZHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBGaWRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuRmlkc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEc1xuICAgICAgICAgKiBAcGFyYW0ge0ZpZHNBcGlGZXRjaEZpZHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpZHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpZHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZmlkcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoRmlkcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hGaWRzKHJlcXVlc3RQYXJhbWV0ZXJzLnNoYXJkSWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZpZHNBcGlGYWN0b3J5ID0gRmlkc0FwaUZhY3Rvcnk7XG4vKipcbiAqIEZpZHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRmlkc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEZpZHNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgRklEcy5cbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBGSURzXG4gICAgICogQHBhcmFtIHtGaWRzQXBpRmV0Y2hGaWRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRmlkc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpZHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpZHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWZpZHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaEZpZHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZpZHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEZpZHMocmVxdWVzdFBhcmFtZXRlcnMuc2hhcmRJZCwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVNpemUsIHJlcXVlc3RQYXJhbWV0ZXJzLnJldmVyc2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VUb2tlbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWRzQXBpID0gRmlkc0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/fids-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/hub-events-api.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/hub-events-api.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HubEventsApi = exports.HubEventsApiFactory = exports.HubEventsApiFp = exports.HubEventsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * HubEventsApi - axios parameter creator\n * @export\n */\nconst HubEventsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a list of events.\n         * @summary Page of events\n         * @param {number} [fromEventId] An optional Hub Id to start getting events from. This is also returned from the API as nextPageEventId, which can be used to page through all the Hub events. Set it to 0 to start from the first event.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)\n         *\n         */\n        fetchEvents: async (fromEventId, options = {}) => {\n            const localVarPath = `/v1/events`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fromEventId !== undefined) {\n                localVarQueryParameter['from_event_id'] = fromEventId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Lookup an event by its ID.\n         * @summary Event by ID\n         * @param {number} eventId The Hub Id of the event\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)\n         *\n         */\n        lookupEvent: async (eventId, options = {}) => {\n            // verify required parameter 'eventId' is not null or undefined\n            (0, common_1.assertParamExists)('lookupEvent', 'eventId', eventId);\n            const localVarPath = `/v1/eventById`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (eventId !== undefined) {\n                localVarQueryParameter['event_id'] = eventId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.HubEventsApiAxiosParamCreator = HubEventsApiAxiosParamCreator;\n/**\n * HubEventsApi - functional programming interface\n * @export\n */\nconst HubEventsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.HubEventsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a list of events.\n         * @summary Page of events\n         * @param {number} [fromEventId] An optional Hub Id to start getting events from. This is also returned from the API as nextPageEventId, which can be used to page through all the Hub events. Set it to 0 to start from the first event.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)\n         *\n         */\n        async fetchEvents(fromEventId, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchEvents(fromEventId, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HubEventsApi.fetchEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Lookup an event by its ID.\n         * @summary Event by ID\n         * @param {number} eventId The Hub Id of the event\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)\n         *\n         */\n        async lookupEvent(eventId, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupEvent(eventId, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['HubEventsApi.lookupEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.HubEventsApiFp = HubEventsApiFp;\n/**\n * HubEventsApi - factory interface\n * @export\n */\nconst HubEventsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.HubEventsApiFp)(configuration);\n    return {\n        /**\n         * Fetch a list of events.\n         * @summary Page of events\n         * @param {HubEventsApiFetchEventsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)\n         *\n         */\n        fetchEvents(requestParameters = {}, options) {\n            return localVarFp.fetchEvents(requestParameters.fromEventId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Lookup an event by its ID.\n         * @summary Event by ID\n         * @param {HubEventsApiLookupEventRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)\n         *\n         */\n        lookupEvent(requestParameters, options) {\n            return localVarFp.lookupEvent(requestParameters.eventId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.HubEventsApiFactory = HubEventsApiFactory;\n/**\n * HubEventsApi - object-oriented interface\n * @export\n * @class HubEventsApi\n * @extends {BaseAPI}\n */\nclass HubEventsApi extends base_1.BaseAPI {\n    /**\n     * Fetch a list of events.\n     * @summary Page of events\n     * @param {HubEventsApiFetchEventsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HubEventsApi\n     * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)\n     *\n     */\n    fetchEvents(requestParameters = {}, options) {\n        return (0, exports.HubEventsApiFp)(this.configuration).fetchEvents(requestParameters.fromEventId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Lookup an event by its ID.\n     * @summary Event by ID\n     * @param {HubEventsApiLookupEventRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof HubEventsApi\n     * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)\n     *\n     */\n    lookupEvent(requestParameters, options) {\n        return (0, exports.HubEventsApiFp)(this.configuration).lookupEvent(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.HubEventsApi = HubEventsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9odWItZXZlbnRzLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcscUNBQXFDO0FBQ25ILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9odWItZXZlbnRzLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHViRXZlbnRzQXBpID0gZXhwb3J0cy5IdWJFdmVudHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5IdWJFdmVudHNBcGlGcCA9IGV4cG9ydHMuSHViRXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBIdWJFdmVudHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBIdWJFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBldmVudHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBhZ2Ugb2YgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUV2ZW50SWRdIEFuIG9wdGlvbmFsIEh1YiBJZCB0byBzdGFydCBnZXR0aW5nIGV2ZW50cyBmcm9tLiBUaGlzIGlzIGFsc28gcmV0dXJuZWQgZnJvbSB0aGUgQVBJIGFzIG5leHRQYWdlRXZlbnRJZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcGFnZSB0aHJvdWdoIGFsbCB0aGUgSHViIGV2ZW50cy4gU2V0IGl0IHRvIDAgdG8gc3RhcnQgZnJvbSB0aGUgZmlyc3QgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaEV2ZW50czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ldmVudHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEV2ZW50czogYXN5bmMgKGZyb21FdmVudElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvZXZlbnRzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZyb21FdmVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmcm9tX2V2ZW50X2lkJ10gPSBmcm9tRXZlbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvb2t1cCBhbiBldmVudCBieSBpdHMgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEV2ZW50IGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudElkIFRoZSBIdWIgSWQgb2YgdGhlIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEh1YkV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgSHViRXZlbnRgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1ldmVudClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cEV2ZW50OiBhc3luYyAoZXZlbnRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdldmVudElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cEV2ZW50JywgJ2V2ZW50SWQnLCBldmVudElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvZXZlbnRCeUlkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGV2ZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2V2ZW50X2lkJ10gPSBldmVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5IdWJFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEh1YkV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBIdWJFdmVudHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBIdWJFdmVudHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkh1YkV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIGV2ZW50cy5cbiAgICAgICAgICogQHN1bW1hcnkgUGFnZSBvZiBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tRXZlbnRJZF0gQW4gb3B0aW9uYWwgSHViIElkIHRvIHN0YXJ0IGdldHRpbmcgZXZlbnRzIGZyb20uIFRoaXMgaXMgYWxzbyByZXR1cm5lZCBmcm9tIHRoZSBBUEkgYXMgbmV4dFBhZ2VFdmVudElkLCB3aGljaCBjYW4gYmUgdXNlZCB0byBwYWdlIHRocm91Z2ggYWxsIHRoZSBIdWIgZXZlbnRzLiBTZXQgaXQgdG8gMCB0byBzdGFydCBmcm9tIHRoZSBmaXJzdCBldmVudC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hFdmVudHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoRXZlbnRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWV2ZW50cylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoRXZlbnRzKGZyb21FdmVudElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEV2ZW50cyhmcm9tRXZlbnRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0h1YkV2ZW50c0FwaS5mZXRjaEV2ZW50cyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGFuIGV2ZW50IGJ5IGl0cyBJRC5cbiAgICAgICAgICogQHN1bW1hcnkgRXZlbnQgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50SWQgVGhlIEh1YiBJZCBvZiB0aGUgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SHViRXZlbnQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBIdWJFdmVudGAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLWV2ZW50KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwRXZlbnQoZXZlbnRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwRXZlbnQoZXZlbnRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0h1YkV2ZW50c0FwaS5sb29rdXBFdmVudCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5IdWJFdmVudHNBcGlGcCA9IEh1YkV2ZW50c0FwaUZwO1xuLyoqXG4gKiBIdWJFdmVudHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBIdWJFdmVudHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5IdWJFdmVudHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiBldmVudHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IFBhZ2Ugb2YgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7SHViRXZlbnRzQXBpRmV0Y2hFdmVudHNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaEV2ZW50czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1ldmVudHMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEV2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEV2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycy5mcm9tRXZlbnRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvb2t1cCBhbiBldmVudCBieSBpdHMgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEV2ZW50IGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7SHViRXZlbnRzQXBpTG9va3VwRXZlbnRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEh1YkV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgSHViRXZlbnRgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1ldmVudClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cEV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5sb29rdXBFdmVudChyZXF1ZXN0UGFyYW1ldGVycy5ldmVudElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5IdWJFdmVudHNBcGlGYWN0b3J5ID0gSHViRXZlbnRzQXBpRmFjdG9yeTtcbi8qKlxuICogSHViRXZlbnRzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEh1YkV2ZW50c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEh1YkV2ZW50c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgZXZlbnRzLlxuICAgICAqIEBzdW1tYXJ5IFBhZ2Ugb2YgZXZlbnRzXG4gICAgICogQHBhcmFtIHtIdWJFdmVudHNBcGlGZXRjaEV2ZW50c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEh1YkV2ZW50c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaEV2ZW50czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtZXZlbnRzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hFdmVudHMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuSHViRXZlbnRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hFdmVudHMocmVxdWVzdFBhcmFtZXRlcnMuZnJvbUV2ZW50SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rdXAgYW4gZXZlbnQgYnkgaXRzIElELlxuICAgICAqIEBzdW1tYXJ5IEV2ZW50IGJ5IElEXG4gICAgICogQHBhcmFtIHtIdWJFdmVudHNBcGlMb29rdXBFdmVudFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEh1YkV2ZW50c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEh1YkV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgSHViRXZlbnRgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtZXZlbnQpXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuSHViRXZlbnRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwRXZlbnQocmVxdWVzdFBhcmFtZXRlcnMuZXZlbnRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdWJFdmVudHNBcGkgPSBIdWJFdmVudHNBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/hub-events-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/info-api.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/info-api.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InfoApi = exports.InfoApiFactory = exports.InfoApiFp = exports.InfoApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * InfoApi - axios parameter creator\n * @export\n */\nconst InfoApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve hub information.\n         * @summary Sync Methods\n         * @param {boolean} dbstats Controls whether the response includes database statistics. When true, the response includes information about the hub\\&#39;s database state, storage usage, and performance metrics.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)\n         *\n         */\n        lookupHubInfo: async (dbstats, options = {}) => {\n            // verify required parameter 'dbstats' is not null or undefined\n            (0, common_1.assertParamExists)('lookupHubInfo', 'dbstats', dbstats);\n            const localVarPath = `/v1/info`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (dbstats !== undefined) {\n                localVarQueryParameter['dbstats'] = dbstats;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.InfoApiAxiosParamCreator = InfoApiAxiosParamCreator;\n/**\n * InfoApi - functional programming interface\n * @export\n */\nconst InfoApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.InfoApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve hub information.\n         * @summary Sync Methods\n         * @param {boolean} dbstats Controls whether the response includes database statistics. When true, the response includes information about the hub\\&#39;s database state, storage usage, and performance metrics.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)\n         *\n         */\n        async lookupHubInfo(dbstats, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupHubInfo(dbstats, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InfoApi.lookupHubInfo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.InfoApiFp = InfoApiFp;\n/**\n * InfoApi - factory interface\n * @export\n */\nconst InfoApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.InfoApiFp)(configuration);\n    return {\n        /**\n         * Retrieve hub information.\n         * @summary Sync Methods\n         * @param {InfoApiLookupHubInfoRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)\n         *\n         */\n        lookupHubInfo(requestParameters, options) {\n            return localVarFp.lookupHubInfo(requestParameters.dbstats, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.InfoApiFactory = InfoApiFactory;\n/**\n * InfoApi - object-oriented interface\n * @export\n * @class InfoApi\n * @extends {BaseAPI}\n */\nclass InfoApi extends base_1.BaseAPI {\n    /**\n     * Retrieve hub information.\n     * @summary Sync Methods\n     * @param {InfoApiLookupHubInfoRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InfoApi\n     * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)\n     *\n     */\n    lookupHubInfo(requestParameters, options) {\n        return (0, exports.InfoApiFp)(this.configuration).lookupHubInfo(requestParameters.dbstats, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.InfoApi = InfoApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9pbmZvLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGdDQUFnQztBQUMvRixnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsb0lBQW9JO0FBQ2hLLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsb0lBQW9JO0FBQ2hLLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2FwaXMvaW5mby1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZm9BcGkgPSBleHBvcnRzLkluZm9BcGlGYWN0b3J5ID0gZXhwb3J0cy5JbmZvQXBpRnAgPSBleHBvcnRzLkluZm9BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEluZm9BcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBJbmZvQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBodWIgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IFN5bmMgTWV0aG9kc1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRic3RhdHMgQ29udHJvbHMgd2hldGhlciB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgZGF0YWJhc2Ugc3RhdGlzdGljcy4gV2hlbiB0cnVlLCB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGh1YlxcJiMzOTtzIGRhdGFiYXNlIHN0YXRlLCBzdG9yYWdlIHVzYWdlLCBhbmQgcGVyZm9ybWFuY2UgbWV0cmljcy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8SHViSW5mb1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgSHViSW5mb1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtaHViLWluZm8pXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBIdWJJbmZvOiBhc3luYyAoZGJzdGF0cywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdkYnN0YXRzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cEh1YkluZm8nLCAnZGJzdGF0cycsIGRic3RhdHMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9pbmZvYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGRic3RhdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Ric3RhdHMnXSA9IGRic3RhdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkluZm9BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEluZm9BcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogSW5mb0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEluZm9BcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkluZm9BcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGh1YiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgU3luYyBNZXRob2RzXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGJzdGF0cyBDb250cm9scyB3aGV0aGVyIHRoZSByZXNwb25zZSBpbmNsdWRlcyBkYXRhYmFzZSBzdGF0aXN0aWNzLiBXaGVuIHRydWUsIHRoZSByZXNwb25zZSBpbmNsdWRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaHViXFwmIzM5O3MgZGF0YWJhc2Ugc3RhdGUsIHN0b3JhZ2UgdXNhZ2UsIGFuZCBwZXJmb3JtYW5jZSBtZXRyaWNzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIdWJJbmZvUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBIdWJJbmZvUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1odWItaW5mbylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cEh1YkluZm8oZGJzdGF0cywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwSHViSW5mbyhkYnN0YXRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnSW5mb0FwaS5sb29rdXBIdWJJbmZvJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkluZm9BcGlGcCA9IEluZm9BcGlGcDtcbi8qKlxuICogSW5mb0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEluZm9BcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5JbmZvQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBodWIgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IFN5bmMgTWV0aG9kc1xuICAgICAgICAgKiBAcGFyYW0ge0luZm9BcGlMb29rdXBIdWJJbmZvUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIdWJJbmZvUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBIdWJJbmZvUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1odWItaW5mbylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cEh1YkluZm8ocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cEh1YkluZm8ocmVxdWVzdFBhcmFtZXRlcnMuZGJzdGF0cywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuSW5mb0FwaUZhY3RvcnkgPSBJbmZvQXBpRmFjdG9yeTtcbi8qKlxuICogSW5mb0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBJbmZvQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgSW5mb0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBodWIgaW5mb3JtYXRpb24uXG4gICAgICogQHN1bW1hcnkgU3luYyBNZXRob2RzXG4gICAgICogQHBhcmFtIHtJbmZvQXBpTG9va3VwSHViSW5mb1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEluZm9BcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIdWJJbmZvUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBIdWJJbmZvUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtaHViLWluZm8pXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBIdWJJbmZvKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5JbmZvQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwSHViSW5mbyhyZXF1ZXN0UGFyYW1ldGVycy5kYnN0YXRzLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkluZm9BcGkgPSBJbmZvQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/info-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/links-api.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/links-api.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LinksApi = exports.LinksApiFactory = exports.LinksApiFp = exports.LinksApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * LinksApi - axios parameter creator\n * @export\n */\nconst LinksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a list of users that are following a user.\n         * @summary To target FID\n         * @param {number} targetFid The FID of the target user for this link\n         * @param {LinkType} [linkType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        fetchUserFollowers: async (targetFid, linkType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'targetFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserFollowers', 'targetFid', targetFid);\n            const localVarPath = `/v1/linksByTargetFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (targetFid !== undefined) {\n                localVarQueryParameter['target_fid'] = targetFid;\n            }\n            if (linkType !== undefined) {\n                localVarQueryParameter['link_type'] = linkType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch a list of users that a user is following.\n         * @summary From source FID\n         * @param {number} fid The FID of the link\\&#39;s originator\n         * @param {LinkType} [linkType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        fetchUserFollowing: async (fid, linkType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserFollowing', 'fid', fid);\n            const localVarPath = `/v1/linksByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (linkType !== undefined) {\n                localVarQueryParameter['link_type'] = linkType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Lookup a link by its FID and target FID.\n         * @summary By its FID and target FID\n         * @param {number} fid The FID of the link\\&#39;s originator\n         * @param {number} targetFid The FID of the target user for this link\n         * @param {LinkType} linkType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)\n         *\n         */\n        lookupUserRelation: async (fid, targetFid, linkType, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserRelation', 'fid', fid);\n            // verify required parameter 'targetFid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserRelation', 'targetFid', targetFid);\n            // verify required parameter 'linkType' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserRelation', 'linkType', linkType);\n            const localVarPath = `/v1/linkById`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (targetFid !== undefined) {\n                localVarQueryParameter['target_fid'] = targetFid;\n            }\n            if (linkType !== undefined) {\n                localVarQueryParameter['link_type'] = linkType;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.LinksApiAxiosParamCreator = LinksApiAxiosParamCreator;\n/**\n * LinksApi - functional programming interface\n * @export\n */\nconst LinksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.LinksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a list of users that are following a user.\n         * @summary To target FID\n         * @param {number} targetFid The FID of the target user for this link\n         * @param {LinkType} [linkType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        async fetchUserFollowers(targetFid, linkType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserFollowers(targetFid, linkType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.fetchUserFollowers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch a list of users that a user is following.\n         * @summary From source FID\n         * @param {number} fid The FID of the link\\&#39;s originator\n         * @param {LinkType} [linkType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        async fetchUserFollowing(fid, linkType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserFollowing(fid, linkType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.fetchUserFollowing']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Lookup a link by its FID and target FID.\n         * @summary By its FID and target FID\n         * @param {number} fid The FID of the link\\&#39;s originator\n         * @param {number} targetFid The FID of the target user for this link\n         * @param {LinkType} linkType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)\n         *\n         */\n        async lookupUserRelation(fid, targetFid, linkType, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserRelation(fid, targetFid, linkType, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LinksApi.lookupUserRelation']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.LinksApiFp = LinksApiFp;\n/**\n * LinksApi - factory interface\n * @export\n */\nconst LinksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.LinksApiFp)(configuration);\n    return {\n        /**\n         * Fetch a list of users that are following a user.\n         * @summary To target FID\n         * @param {LinksApiFetchUserFollowersRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n         *\n         */\n        fetchUserFollowers(requestParameters, options) {\n            return localVarFp.fetchUserFollowers(requestParameters.targetFid, requestParameters.linkType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch a list of users that a user is following.\n         * @summary From source FID\n         * @param {LinksApiFetchUserFollowingRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n         *\n         */\n        fetchUserFollowing(requestParameters, options) {\n            return localVarFp.fetchUserFollowing(requestParameters.fid, requestParameters.linkType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Lookup a link by its FID and target FID.\n         * @summary By its FID and target FID\n         * @param {LinksApiLookupUserRelationRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)\n         *\n         */\n        lookupUserRelation(requestParameters, options) {\n            return localVarFp.lookupUserRelation(requestParameters.fid, requestParameters.targetFid, requestParameters.linkType, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.LinksApiFactory = LinksApiFactory;\n/**\n * LinksApi - object-oriented interface\n * @export\n * @class LinksApi\n * @extends {BaseAPI}\n */\nclass LinksApi extends base_1.BaseAPI {\n    /**\n     * Fetch a list of users that are following a user.\n     * @summary To target FID\n     * @param {LinksApiFetchUserFollowersRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LinksApi\n     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)\n     *\n     */\n    fetchUserFollowers(requestParameters, options) {\n        return (0, exports.LinksApiFp)(this.configuration).fetchUserFollowers(requestParameters.targetFid, requestParameters.linkType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch a list of users that a user is following.\n     * @summary From source FID\n     * @param {LinksApiFetchUserFollowingRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LinksApi\n     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)\n     *\n     */\n    fetchUserFollowing(requestParameters, options) {\n        return (0, exports.LinksApiFp)(this.configuration).fetchUserFollowing(requestParameters.fid, requestParameters.linkType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Lookup a link by its FID and target FID.\n     * @summary By its FID and target FID\n     * @param {LinksApiLookupUserRelationRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LinksApi\n     * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)\n     *\n     */\n    lookupUserRelation(requestParameters, options) {\n        return (0, exports.LinksApiFp)(this.configuration).lookupUserRelation(requestParameters.fid, requestParameters.targetFid, requestParameters.linkType, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.LinksApi = LinksApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9saW5rcy1hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQztBQUNuRyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQVc7QUFDcEM7QUFDQSxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLDZCQUE2QjtBQUN4RCxtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FB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VDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2FwaXMvbGlua3MtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZhcmNhc3RlciBIdWIgQVBJXG4gKiBQZXJmb3JtIGJhc2ljIHF1ZXJpZXMgb2YgRmFyY2FzdGVyIHN0YXRlIHZpYSB0aGUgUkVTVCBBUEkgb2YgYSBGYXJjYXN0ZXIgaHViLiBTZWUgdGhlIFtOZXluYXIgZG9jc10oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAyLjM1LjBcbiAqIENvbnRhY3Q6IHRlYW1AbmV5bmFyLmNvbVxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaW5rc0FwaSA9IGV4cG9ydHMuTGlua3NBcGlGYWN0b3J5ID0gZXhwb3J0cy5MaW5rc0FwaUZwID0gZXhwb3J0cy5MaW5rc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogTGlua3NBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBMaW5rc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSBsaXN0IG9mIHVzZXJzIHRoYXQgYXJlIGZvbGxvd2luZyBhIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IFRvIHRhcmdldCBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldEZpZCBUaGUgRklEIG9mIHRoZSB0YXJnZXQgdXNlciBmb3IgdGhpcyBsaW5rXG4gICAgICAgICAqIEBwYXJhbSB7TGlua1R5cGV9IFtsaW5rVHlwZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyRm9sbG93aW5nMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93ZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyRm9sbG93ZXJzOiBhc3luYyAodGFyZ2V0RmlkLCBsaW5rVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRGaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyRm9sbG93ZXJzJywgJ3RhcmdldEZpZCcsIHRhcmdldEZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2xpbmtzQnlUYXJnZXRGaWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0YXJnZXRfZmlkJ10gPSB0YXJnZXRGaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlua1R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbmtfdHlwZSddID0gbGlua1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VTaXplJ10gPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVRva2VuJ10gPSBwYWdlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhIHVzZXIgaXMgZm9sbG93aW5nLlxuICAgICAgICAgKiBAc3VtbWFyeSBGcm9tIHNvdXJjZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSBsaW5rXFwmIzM5O3Mgb3JpZ2luYXRvclxuICAgICAgICAgKiBAcGFyYW0ge0xpbmtUeXBlfSBbbGlua1R5cGVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckZvbGxvd2luZzogYXN5bmMgKGZpZCwgbGlua1R5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZmlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlckZvbGxvd2luZycsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9saW5rc0J5RmlkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlua1R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbmtfdHlwZSddID0gbGlua1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VTaXplJ10gPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVRva2VuJ10gPSBwYWdlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSBsaW5rIGJ5IGl0cyBGSUQgYW5kIHRhcmdldCBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGl0cyBGSUQgYW5kIHRhcmdldCBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSBsaW5rXFwmIzM5O3Mgb3JpZ2luYXRvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0RmlkIFRoZSBGSUQgb2YgdGhlIHRhcmdldCB1c2VyIGZvciB0aGlzIGxpbmtcbiAgICAgICAgICogQHBhcmFtIHtMaW5rVHlwZX0gbGlua1R5cGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TGlua0FkZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYExpbmtBZGRgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXJlbGF0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwVXNlclJlbGF0aW9uOiBhc3luYyAoZmlkLCB0YXJnZXRGaWQsIGxpbmtUeXBlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBVc2VyUmVsYXRpb24nLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RhcmdldEZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBVc2VyUmVsYXRpb24nLCAndGFyZ2V0RmlkJywgdGFyZ2V0RmlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2xpbmtUeXBlJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cFVzZXJSZWxhdGlvbicsICdsaW5rVHlwZScsIGxpbmtUeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbGlua0J5SWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RhcmdldF9maWQnXSA9IHRhcmdldEZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5rVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGlua190eXBlJ10gPSBsaW5rVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTGlua3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IExpbmtzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIExpbmtzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTGlua3NBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkxpbmtzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhcmUgZm9sbG93aW5nIGEgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgVG8gdGFyZ2V0IEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0RmlkIFRoZSBGSUQgb2YgdGhlIHRhcmdldCB1c2VyIGZvciB0aGlzIGxpbmtcbiAgICAgICAgICogQHBhcmFtIHtMaW5rVHlwZX0gW2xpbmtUeXBlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VyRm9sbG93aW5nMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dlcnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJGb2xsb3dlcnModGFyZ2V0RmlkLCBsaW5rVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2VyRm9sbG93ZXJzKHRhcmdldEZpZCwgbGlua1R5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydMaW5rc0FwaS5mZXRjaFVzZXJGb2xsb3dlcnMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB0aGF0IGEgdXNlciBpcyBmb2xsb3dpbmcuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZyb20gc291cmNlIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgb2YgdGhlIGxpbmtcXCYjMzk7cyBvcmlnaW5hdG9yXG4gICAgICAgICAqIEBwYXJhbSB7TGlua1R5cGV9IFtsaW5rVHlwZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyRm9sbG93aW5nMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZm9sbG93aW5nKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyRm9sbG93aW5nKGZpZCwgbGlua1R5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlckZvbGxvd2luZyhmaWQsIGxpbmtUeXBlLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTGlua3NBcGkuZmV0Y2hVc2VyRm9sbG93aW5nJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSBsaW5rIGJ5IGl0cyBGSUQgYW5kIHRhcmdldCBGSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IGl0cyBGSUQgYW5kIHRhcmdldCBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSBsaW5rXFwmIzM5O3Mgb3JpZ2luYXRvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0RmlkIFRoZSBGSUQgb2YgdGhlIHRhcmdldCB1c2VyIGZvciB0aGlzIGxpbmtcbiAgICAgICAgICogQHBhcmFtIHtMaW5rVHlwZX0gbGlua1R5cGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TGlua0FkZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYExpbmtBZGRgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXJlbGF0aW9uKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwVXNlclJlbGF0aW9uKGZpZCwgdGFyZ2V0RmlkLCBsaW5rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwVXNlclJlbGF0aW9uKGZpZCwgdGFyZ2V0RmlkLCBsaW5rVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0xpbmtzQXBpLmxvb2t1cFVzZXJSZWxhdGlvbiddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5MaW5rc0FwaUZwID0gTGlua3NBcGlGcDtcbi8qKlxuICogTGlua3NBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBMaW5rc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkxpbmtzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhcmUgZm9sbG93aW5nIGEgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgVG8gdGFyZ2V0IEZJRFxuICAgICAgICAgKiBAcGFyYW0ge0xpbmtzQXBpRmV0Y2hVc2VyRm9sbG93ZXJzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2VycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckZvbGxvd2VycyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyRm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGlua1R5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhIHVzZXIgaXMgZm9sbG93aW5nLlxuICAgICAgICAgKiBAc3VtbWFyeSBGcm9tIHNvdXJjZSBGSURcbiAgICAgICAgICogQHBhcmFtIHtMaW5rc0FwaUZldGNoVXNlckZvbGxvd2luZ1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VyRm9sbG93aW5nMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dpbmcpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJGb2xsb3dpbmcocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVXNlckZvbGxvd2luZyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbmtUeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9va3VwIGEgbGluayBieSBpdHMgRklEIGFuZCB0YXJnZXQgRklELlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBpdHMgRklEIGFuZCB0YXJnZXQgRklEXG4gICAgICAgICAqIEBwYXJhbSB7TGlua3NBcGlMb29rdXBVc2VyUmVsYXRpb25SZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPExpbmtBZGQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBMaW5rQWRkYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1yZWxhdGlvbilcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJSZWxhdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwVXNlclJlbGF0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0RmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW5rVHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTGlua3NBcGlGYWN0b3J5ID0gTGlua3NBcGlGYWN0b3J5O1xuLyoqXG4gKiBMaW5rc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBMaW5rc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIExpbmtzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiB1c2VycyB0aGF0IGFyZSBmb2xsb3dpbmcgYSB1c2VyLlxuICAgICAqIEBzdW1tYXJ5IFRvIHRhcmdldCBGSURcbiAgICAgKiBAcGFyYW0ge0xpbmtzQXBpRmV0Y2hVc2VyRm9sbG93ZXJzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgTGlua3NBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJGb2xsb3dpbmcyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1mb2xsb3dlcnMpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFVzZXJGb2xsb3dlcnMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkxpbmtzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyRm9sbG93ZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMubGlua1R5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBhIHVzZXIgaXMgZm9sbG93aW5nLlxuICAgICAqIEBzdW1tYXJ5IEZyb20gc291cmNlIEZJRFxuICAgICAqIEBwYXJhbSB7TGlua3NBcGlGZXRjaFVzZXJGb2xsb3dpbmdSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBMaW5rc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckZvbGxvd2luZzIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyRm9sbG93aW5nMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLWZvbGxvd2luZylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlckZvbGxvd2luZyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTGlua3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJGb2xsb3dpbmcocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5saW5rVHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVNpemUsIHJlcXVlc3RQYXJhbWV0ZXJzLnJldmVyc2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VUb2tlbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhIGxpbmsgYnkgaXRzIEZJRCBhbmQgdGFyZ2V0IEZJRC5cbiAgICAgKiBAc3VtbWFyeSBCeSBpdHMgRklEIGFuZCB0YXJnZXQgRklEXG4gICAgICogQHBhcmFtIHtMaW5rc0FwaUxvb2t1cFVzZXJSZWxhdGlvblJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIExpbmtzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TGlua0FkZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYExpbmtBZGRgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1yZWxhdGlvbilcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cFVzZXJSZWxhdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTGlua3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBVc2VyUmVsYXRpb24ocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmxpbmtUeXBlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkxpbmtzQXBpID0gTGlua3NBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/links-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/message-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/message-api.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageApi = exports.MessageApiFactory = exports.MessageApiFp = exports.MessageApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * MessageApi - axios parameter creator\n * @export\n */\nconst MessageApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Submit a message to the Farcaster network.\n         * @summary Submit signed message\n         * @param {File} body A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Message>} A promise that resolves to a `Message` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)\n         *\n         */\n        publishMessage: async (body, options = {}) => {\n            // verify required parameter 'body' is not null or undefined\n            (0, common_1.assertParamExists)('publishMessage', 'body', body);\n            const localVarPath = `/v1/submitMessage`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Validate a message on the Farcaster network.\n         * @summary Validate signed message\n         * @param {File} body A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)\n         *\n         */\n        validateMessage: async (body, options = {}) => {\n            // verify required parameter 'body' is not null or undefined\n            (0, common_1.assertParamExists)('validateMessage', 'body', body);\n            const localVarPath = `/v1/validateMessage`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.MessageApiAxiosParamCreator = MessageApiAxiosParamCreator;\n/**\n * MessageApi - functional programming interface\n * @export\n */\nconst MessageApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.MessageApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Submit a message to the Farcaster network.\n         * @summary Submit signed message\n         * @param {File} body A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Message>} A promise that resolves to a `Message` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)\n         *\n         */\n        async publishMessage(body, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.publishMessage(body, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MessageApi.publishMessage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Validate a message on the Farcaster network.\n         * @summary Validate signed message\n         * @param {File} body A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)\n         *\n         */\n        async validateMessage(body, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.validateMessage(body, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MessageApi.validateMessage']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.MessageApiFp = MessageApiFp;\n/**\n * MessageApi - factory interface\n * @export\n */\nconst MessageApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.MessageApiFp)(configuration);\n    return {\n        /**\n         * Submit a message to the Farcaster network.\n         * @summary Submit signed message\n         * @param {MessageApiPublishMessageRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Message>} A promise that resolves to a `Message` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)\n         *\n         */\n        publishMessage(requestParameters, options) {\n            return localVarFp.publishMessage(requestParameters.body, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Validate a message on the Farcaster network.\n         * @summary Validate signed message\n         * @param {MessageApiValidateMessageRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)\n         *\n         */\n        validateMessage(requestParameters, options) {\n            return localVarFp.validateMessage(requestParameters.body, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.MessageApiFactory = MessageApiFactory;\n/**\n * MessageApi - object-oriented interface\n * @export\n * @class MessageApi\n * @extends {BaseAPI}\n */\nclass MessageApi extends base_1.BaseAPI {\n    /**\n     * Submit a message to the Farcaster network.\n     * @summary Submit signed message\n     * @param {MessageApiPublishMessageRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MessageApi\n     * @returns {Promise<Message>} A promise that resolves to a `Message` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)\n     *\n     */\n    publishMessage(requestParameters, options) {\n        return (0, exports.MessageApiFp)(this.configuration).publishMessage(requestParameters.body, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Validate a message on the Farcaster network.\n     * @summary Validate signed message\n     * @param {MessageApiValidateMessageRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MessageApi\n     * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)\n     *\n     */\n    validateMessage(requestParameters, options) {\n        return (0, exports.MessageApiFp)(this.configuration).validateMessage(requestParameters.body, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.MessageApi = MessageApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9tZXNzYWdlLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsbUNBQW1DO0FBQzNHLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixrQ0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGtDQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9tZXNzYWdlLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZUFwaSA9IGV4cG9ydHMuTWVzc2FnZUFwaUZhY3RvcnkgPSBleHBvcnRzLk1lc3NhZ2VBcGlGcCA9IGV4cG9ydHMuTWVzc2FnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogTWVzc2FnZUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1lc3NhZ2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCBhIG1lc3NhZ2UgdG8gdGhlIEZhcmNhc3RlciBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgc2lnbmVkIG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBib2R5IEEgTWVzc2FnZSBpcyBhIGRlbHRhIG9wZXJhdGlvbiBvbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFRoZSBtZXNzYWdlIHByb3RvYnVmIGlzIGFuIGVudmVsb3BlIHRoYXQgd3JhcHMgYSBNZXNzYWdlRGF0YSBvYmplY3QgYW5kIGNvbnRhaW5zIGEgaGFzaCBhbmQgc2lnbmF0dXJlIHdoaWNoIGNhbiB2ZXJpZnkgaXRzIGF1dGhlbnRpY2l0eS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE1lc3NhZ2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3N1Ym1pdC1zaWduZWQtbWVzc2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hNZXNzYWdlOiBhc3luYyAoYm9keSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdib2R5JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3B1Ymxpc2hNZXNzYWdlJywgJ2JvZHknLCBib2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc3VibWl0TWVzc2FnZWA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ1BPU1QnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYm9keSwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgYSBtZXNzYWdlIG9uIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgVmFsaWRhdGUgc2lnbmVkIG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHtGaWxlfSBib2R5IEEgTWVzc2FnZSBpcyBhIGRlbHRhIG9wZXJhdGlvbiBvbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFRoZSBtZXNzYWdlIHByb3RvYnVmIGlzIGFuIGVudmVsb3BlIHRoYXQgd3JhcHMgYSBNZXNzYWdlRGF0YSBvYmplY3QgYW5kIGNvbnRhaW5zIGEgaGFzaCBhbmQgc2lnbmF0dXJlIHdoaWNoIGNhbiB2ZXJpZnkgaXRzIGF1dGhlbnRpY2l0eS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmFsaWRhdGVNZXNzYWdlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBWYWxpZGF0ZU1lc3NhZ2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvdmFsaWRhdGUtbWVzc2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZTogYXN5bmMgKGJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYm9keScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCd2YWxpZGF0ZU1lc3NhZ2UnLCAnYm9keScsIGJvZHkpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS92YWxpZGF0ZU1lc3NhZ2VgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdQT1NUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJvZHksIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTWVzc2FnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gTWVzc2FnZUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBNZXNzYWdlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuTWVzc2FnZUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IGEgbWVzc2FnZSB0byB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCBzaWduZWQgbWVzc2FnZVxuICAgICAgICAgKiBAcGFyYW0ge0ZpbGV9IGJvZHkgQSBNZXNzYWdlIGlzIGEgZGVsdGEgb3BlcmF0aW9uIG9uIHRoZSBGYXJjYXN0ZXIgbmV0d29yay4gVGhlIG1lc3NhZ2UgcHJvdG9idWYgaXMgYW4gZW52ZWxvcGUgdGhhdCB3cmFwcyBhIE1lc3NhZ2VEYXRhIG9iamVjdCBhbmQgY29udGFpbnMgYSBoYXNoIGFuZCBzaWduYXR1cmUgd2hpY2ggY2FuIHZlcmlmeSBpdHMgYXV0aGVudGljaXR5LlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTWVzc2FnZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2Uvc3VibWl0LXNpZ25lZC1tZXNzYWdlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHVibGlzaE1lc3NhZ2UoYm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucHVibGlzaE1lc3NhZ2UoYm9keSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ01lc3NhZ2VBcGkucHVibGlzaE1lc3NhZ2UnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRlIGEgbWVzc2FnZSBvbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IFZhbGlkYXRlIHNpZ25lZCBtZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7RmlsZX0gYm9keSBBIE1lc3NhZ2UgaXMgYSBkZWx0YSBvcGVyYXRpb24gb24gdGhlIEZhcmNhc3RlciBuZXR3b3JrLiBUaGUgbWVzc2FnZSBwcm90b2J1ZiBpcyBhbiBlbnZlbG9wZSB0aGF0IHdyYXBzIGEgTWVzc2FnZURhdGEgb2JqZWN0IGFuZCBjb250YWlucyBhIGhhc2ggYW5kIHNpZ25hdHVyZSB3aGljaCBjYW4gdmVyaWZ5IGl0cyBhdXRoZW50aWNpdHkuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZhbGlkYXRlTWVzc2FnZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVmFsaWRhdGVNZXNzYWdlUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3ZhbGlkYXRlLW1lc3NhZ2UpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB2YWxpZGF0ZU1lc3NhZ2UoYm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IudmFsaWRhdGVNZXNzYWdlKGJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydNZXNzYWdlQXBpLnZhbGlkYXRlTWVzc2FnZSddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NZXNzYWdlQXBpRnAgPSBNZXNzYWdlQXBpRnA7XG4vKipcbiAqIE1lc3NhZ2VBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBNZXNzYWdlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuTWVzc2FnZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IGEgbWVzc2FnZSB0byB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCBzaWduZWQgbWVzc2FnZVxuICAgICAgICAgKiBAcGFyYW0ge01lc3NhZ2VBcGlQdWJsaXNoTWVzc2FnZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE1lc3NhZ2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3N1Ym1pdC1zaWduZWQtbWVzc2FnZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHB1Ymxpc2hNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5wdWJsaXNoTWVzc2FnZShyZXF1ZXN0UGFyYW1ldGVycy5ib2R5LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgYSBtZXNzYWdlIG9uIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgVmFsaWRhdGUgc2lnbmVkIG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHtNZXNzYWdlQXBpVmFsaWRhdGVNZXNzYWdlUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWYWxpZGF0ZU1lc3NhZ2VSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFZhbGlkYXRlTWVzc2FnZVJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS92YWxpZGF0ZS1tZXNzYWdlKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsaWRhdGVNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC52YWxpZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMuYm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTWVzc2FnZUFwaUZhY3RvcnkgPSBNZXNzYWdlQXBpRmFjdG9yeTtcbi8qKlxuICogTWVzc2FnZUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBNZXNzYWdlQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgTWVzc2FnZUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBTdWJtaXQgYSBtZXNzYWdlIHRvIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgKiBAc3VtbWFyeSBTdWJtaXQgc2lnbmVkIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VBcGlQdWJsaXNoTWVzc2FnZVJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE1lc3NhZ2VBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgTWVzc2FnZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3N1Ym1pdC1zaWduZWQtbWVzc2FnZSlcbiAgICAgKlxuICAgICAqL1xuICAgIHB1Ymxpc2hNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5NZXNzYWdlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucHVibGlzaE1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMuYm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGEgbWVzc2FnZSBvbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICogQHN1bW1hcnkgVmFsaWRhdGUgc2lnbmVkIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VBcGlWYWxpZGF0ZU1lc3NhZ2VSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNZXNzYWdlQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VmFsaWRhdGVNZXNzYWdlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBWYWxpZGF0ZU1lc3NhZ2VSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL3ZhbGlkYXRlLW1lc3NhZ2UpXG4gICAgICpcbiAgICAgKi9cbiAgICB2YWxpZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk1lc3NhZ2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS52YWxpZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMuYm9keSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlQXBpID0gTWVzc2FnZUFwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/message-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/on-chain-events-api.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/on-chain-events-api.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OnChainEventsApi = exports.OnChainEventsApiFactory = exports.OnChainEventsApiFp = exports.OnChainEventsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * OnChainEventsApi - axios parameter creator\n * @export\n */\nconst OnChainEventsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch on-chain events provided by a user.\n         * @summary Fetch a list of on-chain events provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {OnChainEventType} eventType The numeric or string value of the event type being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)\n         *\n         */\n        fetchUserOnChainEvents: async (fid, eventType, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserOnChainEvents', 'fid', fid);\n            // verify required parameter 'eventType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserOnChainEvents', 'eventType', eventType);\n            const localVarPath = `/v1/onChainEventsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (eventType !== undefined) {\n                localVarQueryParameter['event_type'] = eventType;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.\n         * @summary Fetch a list of signers provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {string} [signer] The optional key of signer\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)\n         *\n         */\n        fetchUserOnChainSignersEvents: async (fid, signer, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserOnChainSignersEvents', 'fid', fid);\n            const localVarPath = `/v1/onChainSignersByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (signer !== undefined) {\n                localVarQueryParameter['signer'] = signer;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch an on-chain ID Registry Event for a given Address.\n         * @summary Fetch an on-chain ID Registry Event for a given Address\n         * @param {string} address The ETH address being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)\n         *\n         */\n        lookupOnChainIdRegistryEventByAddress: async (address, options = {}) => {\n            // verify required parameter 'address' is not null or undefined\n            (0, common_1.assertParamExists)('lookupOnChainIdRegistryEventByAddress', 'address', address);\n            const localVarPath = `/v1/onChainIdRegistryEventByAddress`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (address !== undefined) {\n                localVarQueryParameter['address'] = address;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.OnChainEventsApiAxiosParamCreator = OnChainEventsApiAxiosParamCreator;\n/**\n * OnChainEventsApi - functional programming interface\n * @export\n */\nconst OnChainEventsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.OnChainEventsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch on-chain events provided by a user.\n         * @summary Fetch a list of on-chain events provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {OnChainEventType} eventType The numeric or string value of the event type being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)\n         *\n         */\n        async fetchUserOnChainEvents(fid, eventType, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserOnChainEvents(fid, eventType, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnChainEventsApi.fetchUserOnChainEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.\n         * @summary Fetch a list of signers provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {string} [signer] The optional key of signer\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)\n         *\n         */\n        async fetchUserOnChainSignersEvents(fid, signer, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserOnChainSignersEvents(fid, signer, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnChainEventsApi.fetchUserOnChainSignersEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch an on-chain ID Registry Event for a given Address.\n         * @summary Fetch an on-chain ID Registry Event for a given Address\n         * @param {string} address The ETH address being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)\n         *\n         */\n        async lookupOnChainIdRegistryEventByAddress(address, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupOnChainIdRegistryEventByAddress(address, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OnChainEventsApi.lookupOnChainIdRegistryEventByAddress']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.OnChainEventsApiFp = OnChainEventsApiFp;\n/**\n * OnChainEventsApi - factory interface\n * @export\n */\nconst OnChainEventsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.OnChainEventsApiFp)(configuration);\n    return {\n        /**\n         * Fetch on-chain events provided by a user.\n         * @summary Fetch a list of on-chain events provided by an FID\n         * @param {OnChainEventsApiFetchUserOnChainEventsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)\n         *\n         */\n        fetchUserOnChainEvents(requestParameters, options) {\n            return localVarFp.fetchUserOnChainEvents(requestParameters.fid, requestParameters.eventType, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.\n         * @summary Fetch a list of signers provided by an FID\n         * @param {OnChainEventsApiFetchUserOnChainSignersEventsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)\n         *\n         */\n        fetchUserOnChainSignersEvents(requestParameters, options) {\n            return localVarFp.fetchUserOnChainSignersEvents(requestParameters.fid, requestParameters.signer, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch an on-chain ID Registry Event for a given Address.\n         * @summary Fetch an on-chain ID Registry Event for a given Address\n         * @param {OnChainEventsApiLookupOnChainIdRegistryEventByAddressRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)\n         *\n         */\n        lookupOnChainIdRegistryEventByAddress(requestParameters, options) {\n            return localVarFp.lookupOnChainIdRegistryEventByAddress(requestParameters.address, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OnChainEventsApiFactory = OnChainEventsApiFactory;\n/**\n * OnChainEventsApi - object-oriented interface\n * @export\n * @class OnChainEventsApi\n * @extends {BaseAPI}\n */\nclass OnChainEventsApi extends base_1.BaseAPI {\n    /**\n     * Fetch on-chain events provided by a user.\n     * @summary Fetch a list of on-chain events provided by an FID\n     * @param {OnChainEventsApiFetchUserOnChainEventsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnChainEventsApi\n     * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)\n     *\n     */\n    fetchUserOnChainEvents(requestParameters, options) {\n        return (0, exports.OnChainEventsApiFp)(this.configuration).fetchUserOnChainEvents(requestParameters.fid, requestParameters.eventType, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.\n     * @summary Fetch a list of signers provided by an FID\n     * @param {OnChainEventsApiFetchUserOnChainSignersEventsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnChainEventsApi\n     * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)\n     *\n     */\n    fetchUserOnChainSignersEvents(requestParameters, options) {\n        return (0, exports.OnChainEventsApiFp)(this.configuration).fetchUserOnChainSignersEvents(requestParameters.fid, requestParameters.signer, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch an on-chain ID Registry Event for a given Address.\n     * @summary Fetch an on-chain ID Registry Event for a given Address\n     * @param {OnChainEventsApiLookupOnChainIdRegistryEventByAddressRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnChainEventsApi\n     * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)\n     *\n     */\n    lookupOnChainIdRegistryEventByAddress(requestParameters, options) {\n        return (0, exports.OnChainEventsApiFp)(this.configuration).lookupOnChainIdRegistryEventByAddress(requestParameters.address, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OnChainEventsApi = OnChainEventsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9vbi1jaGFpbi1ldmVudHMtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywrQkFBK0IsR0FBRywwQkFBMEIsR0FBRyx5Q0FBeUM7QUFDbkksZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQStDO0FBQ2xFLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQXNEO0FBQ3pFLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUErQztBQUM5RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDRDQUE0QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsbURBQW1EO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBOEQ7QUFDN0UsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2FwaXMvb24tY2hhaW4tZXZlbnRzLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT25DaGFpbkV2ZW50c0FwaSA9IGV4cG9ydHMuT25DaGFpbkV2ZW50c0FwaUZhY3RvcnkgPSBleHBvcnRzLk9uQ2hhaW5FdmVudHNBcGlGcCA9IGV4cG9ydHMuT25DaGFpbkV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogT25DaGFpbkV2ZW50c0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uQ2hhaW5FdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIG9uLWNoYWluIGV2ZW50cyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgbGlzdCBvZiBvbi1jaGFpbiBldmVudHMgcHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPbkNoYWluRXZlbnRUeXBlfSBldmVudFR5cGUgVGhlIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlIG9mIHRoZSBldmVudCB0eXBlIGJlaW5nIHJlcXVlc3RlZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJPbkNoYWluRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJPbkNoYWluRXZlbnRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItb24tY2hhaW4tZXZlbnRzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyT25DaGFpbkV2ZW50czogYXN5bmMgKGZpZCwgZXZlbnRUeXBlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFVzZXJPbkNoYWluRXZlbnRzJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdldmVudFR5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyT25DaGFpbkV2ZW50cycsICdldmVudFR5cGUnLCBldmVudFR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9vbkNoYWluRXZlbnRzQnlGaWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2V2ZW50X3R5cGUnXSA9IGV2ZW50VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHNpZ25lcmAgcGFyYW1ldGVyLiBJZiBpbmNsdWRlZCwgYSBzaW5nbGUgYE9uQ2hhaW5FdmVudFNpZ25lcmAgbWVzc2FnZSBpcyByZXR1cm5lZCAob3IgYSBgbm90X2ZvdW5kYCBlcnJvcikuIElmIG9taXR0ZWQsIGEgbm9uLXBhZ2luYXRlZCBsaXN0IG9mIGBPbkNoYWluRXZlbnRTaWduZXJgIG1lc3NhZ2VzIGlzIHJldHVybmVkIGluc3RlYWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgbGlzdCBvZiBzaWduZXJzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2lnbmVyXSBUaGUgb3B0aW9uYWwga2V5IG9mIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1vbi1jaGFpbi1zaWduZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHM6IGFzeW5jIChmaWQsIHNpZ25lciwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMnLCAnZmlkJywgZmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvb25DaGFpblNpZ25lcnNCeUZpZGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpZ25lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc2lnbmVyJ10gPSBzaWduZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhbiBvbi1jaGFpbiBJRCBSZWdpc3RyeSBFdmVudCBmb3IgYSBnaXZlbiBBZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhbiBvbi1jaGFpbiBJRCBSZWdpc3RyeSBFdmVudCBmb3IgYSBnaXZlbiBBZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIFRoZSBFVEggYWRkcmVzcyBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T25DaGFpbkV2ZW50SWRSZWdpc3Rlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9uQ2hhaW5FdmVudElkUmVnaXN0ZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1vbi1jaGFpbi1pZC1yZWdpc3RyeS1ldmVudC1ieS1hZGRyZXNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzczogYXN5bmMgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsb29rdXBPbkNoYWluSWRSZWdpc3RyeUV2ZW50QnlBZGRyZXNzJywgJ2FkZHJlc3MnLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvb25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhZGRyZXNzJ10gPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5PbkNoYWluRXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBPbkNoYWluRXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE9uQ2hhaW5FdmVudHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBPbkNoYWluRXZlbnRzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5PbkNoYWluRXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBvbi1jaGFpbiBldmVudHMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhIGxpc3Qgb2Ygb24tY2hhaW4gZXZlbnRzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7T25DaGFpbkV2ZW50VHlwZX0gZXZlbnRUeXBlIFRoZSBudW1lcmljIG9yIHN0cmluZyB2YWx1ZSBvZiB0aGUgZXZlbnQgdHlwZSBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VyT25DaGFpbkV2ZW50czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyT25DaGFpbkV2ZW50czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLW9uLWNoYWluLWV2ZW50cylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoVXNlck9uQ2hhaW5FdmVudHMoZmlkLCBldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlck9uQ2hhaW5FdmVudHMoZmlkLCBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydPbkNoYWluRXZlbnRzQXBpLmZldGNoVXNlck9uQ2hhaW5FdmVudHMnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHNpZ25lcmAgcGFyYW1ldGVyLiBJZiBpbmNsdWRlZCwgYSBzaW5nbGUgYE9uQ2hhaW5FdmVudFNpZ25lcmAgbWVzc2FnZSBpcyByZXR1cm5lZCAob3IgYSBgbm90X2ZvdW5kYCBlcnJvcikuIElmIG9taXR0ZWQsIGEgbm9uLXBhZ2luYXRlZCBsaXN0IG9mIGBPbkNoYWluRXZlbnRTaWduZXJgIG1lc3NhZ2VzIGlzIHJldHVybmVkIGluc3RlYWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgbGlzdCBvZiBzaWduZXJzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlkIFRoZSBGSUQgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2lnbmVyXSBUaGUgb3B0aW9uYWwga2V5IG9mIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50czIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1vbi1jaGFpbi1zaWduZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMoZmlkLCBzaWduZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlck9uQ2hhaW5TaWduZXJzRXZlbnRzKGZpZCwgc2lnbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnT25DaGFpbkV2ZW50c0FwaS5mZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50cyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYW4gb24tY2hhaW4gSUQgUmVnaXN0cnkgRXZlbnQgZm9yIGEgZ2l2ZW4gQWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggYW4gb24tY2hhaW4gSUQgUmVnaXN0cnkgRXZlbnQgZm9yIGEgZ2l2ZW4gQWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBUaGUgRVRIIGFkZHJlc3MgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9uQ2hhaW5FdmVudElkUmVnaXN0ZXI+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBPbkNoYWluRXZlbnRJZFJlZ2lzdGVyYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtb24tY2hhaW4taWQtcmVnaXN0cnktZXZlbnQtYnktYWRkcmVzcylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxvb2t1cE9uQ2hhaW5JZFJlZ2lzdHJ5RXZlbnRCeUFkZHJlc3MoYWRkcmVzcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnT25DaGFpbkV2ZW50c0FwaS5sb29rdXBPbkNoYWluSWRSZWdpc3RyeUV2ZW50QnlBZGRyZXNzJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk9uQ2hhaW5FdmVudHNBcGlGcCA9IE9uQ2hhaW5FdmVudHNBcGlGcDtcbi8qKlxuICogT25DaGFpbkV2ZW50c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uQ2hhaW5FdmVudHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5PbkNoYWluRXZlbnRzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBvbi1jaGFpbiBldmVudHMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBhIGxpc3Qgb2Ygb24tY2hhaW4gZXZlbnRzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge09uQ2hhaW5FdmVudHNBcGlGZXRjaFVzZXJPbkNoYWluRXZlbnRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJPbkNoYWluRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJPbkNoYWluRXZlbnRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItb24tY2hhaW4tZXZlbnRzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyT25DaGFpbkV2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VyT25DaGFpbkV2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmV2ZW50VHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHNpZ25lcmAgcGFyYW1ldGVyLiBJZiBpbmNsdWRlZCwgYSBzaW5nbGUgYE9uQ2hhaW5FdmVudFNpZ25lcmAgbWVzc2FnZSBpcyByZXR1cm5lZCAob3IgYSBgbm90X2ZvdW5kYCBlcnJvcikuIElmIG9taXR0ZWQsIGEgbm9uLXBhZ2luYXRlZCBsaXN0IG9mIGBPbkNoYWluRXZlbnRTaWduZXJgIG1lc3NhZ2VzIGlzIHJldHVybmVkIGluc3RlYWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgbGlzdCBvZiBzaWduZXJzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAgICAgKiBAcGFyYW0ge09uQ2hhaW5FdmVudHNBcGlGZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50c1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlck9uQ2hhaW5TaWduZXJzRXZlbnRzMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItb24tY2hhaW4tc2lnbmVycylcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlck9uQ2hhaW5TaWduZXJzRXZlbnRzKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnNpZ25lciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGFuIG9uLWNoYWluIElEIFJlZ2lzdHJ5IEV2ZW50IGZvciBhIGdpdmVuIEFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGFuIG9uLWNoYWluIElEIFJlZ2lzdHJ5IEV2ZW50IGZvciBhIGdpdmVuIEFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtPbkNoYWluRXZlbnRzQXBpTG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8T25DaGFpbkV2ZW50SWRSZWdpc3Rlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9uQ2hhaW5FdmVudElkUmVnaXN0ZXJgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC1vbi1jaGFpbi1pZC1yZWdpc3RyeS1ldmVudC1ieS1hZGRyZXNzKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubG9va3VwT25DaGFpbklkUmVnaXN0cnlFdmVudEJ5QWRkcmVzcyhyZXF1ZXN0UGFyYW1ldGVycy5hZGRyZXNzLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5PbkNoYWluRXZlbnRzQXBpRmFjdG9yeSA9IE9uQ2hhaW5FdmVudHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBPbkNoYWluRXZlbnRzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE9uQ2hhaW5FdmVudHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBPbkNoYWluRXZlbnRzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEZldGNoIG9uLWNoYWluIGV2ZW50cyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYSBsaXN0IG9mIG9uLWNoYWluIGV2ZW50cyBwcm92aWRlZCBieSBhbiBGSURcbiAgICAgKiBAcGFyYW0ge09uQ2hhaW5FdmVudHNBcGlGZXRjaFVzZXJPbkNoYWluRXZlbnRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25DaGFpbkV2ZW50c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlck9uQ2hhaW5FdmVudHMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlck9uQ2hhaW5FdmVudHMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItb24tY2hhaW4tZXZlbnRzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VyT25DaGFpbkV2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuT25DaGFpbkV2ZW50c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmZldGNoVXNlck9uQ2hhaW5FdmVudHMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5ldmVudFR5cGUsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAqKk5vdGU6Kiogb25lIG9mIHR3byBkaWZmZXJlbnQgcmVzcG9uc2Ugc2NoZW1hcyBpcyByZXR1cm5lZCBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjYWxsZXIgcHJvdmlkZXMgdGhlIGBzaWduZXJgIHBhcmFtZXRlci4gSWYgaW5jbHVkZWQsIGEgc2luZ2xlIGBPbkNoYWluRXZlbnRTaWduZXJgIG1lc3NhZ2UgaXMgcmV0dXJuZWQgKG9yIGEgYG5vdF9mb3VuZGAgZXJyb3IpLiBJZiBvbWl0dGVkLCBhIG5vbi1wYWdpbmF0ZWQgbGlzdCBvZiBgT25DaGFpbkV2ZW50U2lnbmVyYCBtZXNzYWdlcyBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGEgbGlzdCBvZiBzaWduZXJzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAqIEBwYXJhbSB7T25DaGFpbkV2ZW50c0FwaUZldGNoVXNlck9uQ2hhaW5TaWduZXJzRXZlbnRzUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25DaGFpbkV2ZW50c0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlck9uQ2hhaW5TaWduZXJzRXZlbnRzMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50czIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1vbi1jaGFpbi1zaWduZXJzKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VyT25DaGFpblNpZ25lcnNFdmVudHMocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk9uQ2hhaW5FdmVudHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJPbkNoYWluU2lnbmVyc0V2ZW50cyhyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnNpZ25lciwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFuIG9uLWNoYWluIElEIFJlZ2lzdHJ5IEV2ZW50IGZvciBhIGdpdmVuIEFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggYW4gb24tY2hhaW4gSUQgUmVnaXN0cnkgRXZlbnQgZm9yIGEgZ2l2ZW4gQWRkcmVzc1xuICAgICAqIEBwYXJhbSB7T25DaGFpbkV2ZW50c0FwaUxvb2t1cE9uQ2hhaW5JZFJlZ2lzdHJ5RXZlbnRCeUFkZHJlc3NSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPbkNoYWluRXZlbnRzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T25DaGFpbkV2ZW50SWRSZWdpc3Rlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYE9uQ2hhaW5FdmVudElkUmVnaXN0ZXJgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtb24tY2hhaW4taWQtcmVnaXN0cnktZXZlbnQtYnktYWRkcmVzcylcbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cE9uQ2hhaW5JZFJlZ2lzdHJ5RXZlbnRCeUFkZHJlc3MocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk9uQ2hhaW5FdmVudHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBPbkNoYWluSWRSZWdpc3RyeUV2ZW50QnlBZGRyZXNzKHJlcXVlc3RQYXJhbWV0ZXJzLmFkZHJlc3MsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuT25DaGFpbkV2ZW50c0FwaSA9IE9uQ2hhaW5FdmVudHNBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/on-chain-events-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/reactions-api.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/reactions-api.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReactionsApi = exports.ReactionsApiFactory = exports.ReactionsApiFp = exports.ReactionsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * ReactionsApi - axios parameter creator\n * @export\n */\nconst ReactionsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.\n         * @summary On cast\n         * @param {number} targetFid The FID of the cast\\&#39;s creator. Required to uniquely identify the cast that received the reactions. Must be used in conjunction with target_hash.\n         * @param {string} targetHash The unique hash identifier of the cast that received the reactions. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies the cast within the creator\\&#39;s posts. Must be used with target_fid.\n         * @param {ReactionType} reactionType\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        fetchCastReactions: async (targetFid, targetHash, reactionType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'targetFid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastReactions', 'targetFid', targetFid);\n            // verify required parameter 'targetHash' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastReactions', 'targetHash', targetHash);\n            // verify required parameter 'reactionType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchCastReactions', 'reactionType', reactionType);\n            const localVarPath = `/v1/reactionsByCast`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (targetFid !== undefined) {\n                localVarQueryParameter['target_fid'] = targetFid;\n            }\n            if (targetHash !== undefined) {\n                localVarQueryParameter['target_hash'] = targetHash;\n            }\n            if (reactionType !== undefined) {\n                localVarQueryParameter['reaction_type'] = reactionType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.\n         * @summary To a target URL\n         * @param {string} url Target URL starting with \\&#39;chain://\\&#39;.\n         * @param {ReactionType} [reactionType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)\n         *\n         */\n        fetchReactionsByTarget: async (url, reactionType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'url' is not null or undefined\n            (0, common_1.assertParamExists)('fetchReactionsByTarget', 'url', url);\n            const localVarPath = `/v1/reactionsByTarget`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (url !== undefined) {\n                localVarQueryParameter['url'] = url;\n            }\n            if (reactionType !== undefined) {\n                localVarQueryParameter['reaction_type'] = reactionType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch reactions by a user.\n         * @summary By FID\n         * @param {number} fid The FID of the reaction\\&#39;s creator\n         * @param {ReactionType} reactionType\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        fetchUserReactions: async (fid, reactionType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserReactions', 'fid', fid);\n            // verify required parameter 'reactionType' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserReactions', 'reactionType', reactionType);\n            const localVarPath = `/v1/reactionsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (reactionType !== undefined) {\n                localVarQueryParameter['reaction_type'] = reactionType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Lookup a reaction by its FID or cast.\n         * @summary By FID or cast\n         * @param {number} fid The FID of the reaction\\&#39;s creator\n         * @param {number} targetFid The FID of the cast\\&#39;s creator\n         * @param {string} targetHash The cast\\&#39;s hash\n         * @param {ReactionType} reactionType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)\n         *\n         */\n        lookupReactionById: async (fid, targetFid, targetHash, reactionType, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupReactionById', 'fid', fid);\n            // verify required parameter 'targetFid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupReactionById', 'targetFid', targetFid);\n            // verify required parameter 'targetHash' is not null or undefined\n            (0, common_1.assertParamExists)('lookupReactionById', 'targetHash', targetHash);\n            // verify required parameter 'reactionType' is not null or undefined\n            (0, common_1.assertParamExists)('lookupReactionById', 'reactionType', reactionType);\n            const localVarPath = `/v1/reactionById`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (targetFid !== undefined) {\n                localVarQueryParameter['target_fid'] = targetFid;\n            }\n            if (targetHash !== undefined) {\n                localVarQueryParameter['target_hash'] = targetHash;\n            }\n            if (reactionType !== undefined) {\n                localVarQueryParameter['reaction_type'] = reactionType;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ReactionsApiAxiosParamCreator = ReactionsApiAxiosParamCreator;\n/**\n * ReactionsApi - functional programming interface\n * @export\n */\nconst ReactionsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ReactionsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.\n         * @summary On cast\n         * @param {number} targetFid The FID of the cast\\&#39;s creator. Required to uniquely identify the cast that received the reactions. Must be used in conjunction with target_hash.\n         * @param {string} targetHash The unique hash identifier of the cast that received the reactions. This is a 40-character hexadecimal string prefixed with \\&#39;0x\\&#39; that uniquely identifies the cast within the creator\\&#39;s posts. Must be used with target_fid.\n         * @param {ReactionType} reactionType\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        async fetchCastReactions(targetFid, targetHash, reactionType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchCastReactions(targetFid, targetHash, reactionType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionsApi.fetchCastReactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.\n         * @summary To a target URL\n         * @param {string} url Target URL starting with \\&#39;chain://\\&#39;.\n         * @param {ReactionType} [reactionType]\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)\n         *\n         */\n        async fetchReactionsByTarget(url, reactionType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchReactionsByTarget(url, reactionType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionsApi.fetchReactionsByTarget']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch reactions by a user.\n         * @summary By FID\n         * @param {number} fid The FID of the reaction\\&#39;s creator\n         * @param {ReactionType} reactionType\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        async fetchUserReactions(fid, reactionType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserReactions(fid, reactionType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionsApi.fetchUserReactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Lookup a reaction by its FID or cast.\n         * @summary By FID or cast\n         * @param {number} fid The FID of the reaction\\&#39;s creator\n         * @param {number} targetFid The FID of the cast\\&#39;s creator\n         * @param {string} targetHash The cast\\&#39;s hash\n         * @param {ReactionType} reactionType\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)\n         *\n         */\n        async lookupReactionById(fid, targetFid, targetHash, reactionType, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupReactionById(fid, targetFid, targetHash, reactionType, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ReactionsApi.lookupReactionById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ReactionsApiFp = ReactionsApiFp;\n/**\n * ReactionsApi - factory interface\n * @export\n */\nconst ReactionsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ReactionsApiFp)(configuration);\n    return {\n        /**\n         * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.\n         * @summary On cast\n         * @param {ReactionsApiFetchCastReactionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n         *\n         */\n        fetchCastReactions(requestParameters, options) {\n            return localVarFp.fetchCastReactions(requestParameters.targetFid, requestParameters.targetHash, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.\n         * @summary To a target URL\n         * @param {ReactionsApiFetchReactionsByTargetRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)\n         *\n         */\n        fetchReactionsByTarget(requestParameters, options) {\n            return localVarFp.fetchReactionsByTarget(requestParameters.url, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch reactions by a user.\n         * @summary By FID\n         * @param {ReactionsApiFetchUserReactionsRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n         *\n         */\n        fetchUserReactions(requestParameters, options) {\n            return localVarFp.fetchUserReactions(requestParameters.fid, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Lookup a reaction by its FID or cast.\n         * @summary By FID or cast\n         * @param {ReactionsApiLookupReactionByIdRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)\n         *\n         */\n        lookupReactionById(requestParameters, options) {\n            return localVarFp.lookupReactionById(requestParameters.fid, requestParameters.targetFid, requestParameters.targetHash, requestParameters.reactionType, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ReactionsApiFactory = ReactionsApiFactory;\n/**\n * ReactionsApi - object-oriented interface\n * @export\n * @class ReactionsApi\n * @extends {BaseAPI}\n */\nclass ReactionsApi extends base_1.BaseAPI {\n    /**\n     * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.\n     * @summary On cast\n     * @param {ReactionsApiFetchCastReactionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionsApi\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)\n     *\n     */\n    fetchCastReactions(requestParameters, options) {\n        return (0, exports.ReactionsApiFp)(this.configuration).fetchCastReactions(requestParameters.targetFid, requestParameters.targetHash, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.\n     * @summary To a target URL\n     * @param {ReactionsApiFetchReactionsByTargetRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionsApi\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)\n     *\n     */\n    fetchReactionsByTarget(requestParameters, options) {\n        return (0, exports.ReactionsApiFp)(this.configuration).fetchReactionsByTarget(requestParameters.url, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch reactions by a user.\n     * @summary By FID\n     * @param {ReactionsApiFetchUserReactionsRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionsApi\n     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)\n     *\n     */\n    fetchUserReactions(requestParameters, options) {\n        return (0, exports.ReactionsApiFp)(this.configuration).fetchUserReactions(requestParameters.fid, requestParameters.reactionType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Lookup a reaction by its FID or cast.\n     * @summary By FID or cast\n     * @param {ReactionsApiLookupReactionByIdRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReactionsApi\n     * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)\n     *\n     */\n    lookupReactionById(requestParameters, options) {\n        return (0, exports.ReactionsApiFp)(this.configuration).lookupReactionById(requestParameters.fid, requestParameters.targetFid, requestParameters.targetHash, requestParameters.reactionType, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ReactionsApi = ReactionsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9yZWFjdGlvbnMtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxxQ0FBcUM7QUFDbkgsZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLG1DQUFtQztBQUM5RCxtQkFBbUIsUUFBUSw2SUFBNkksU0FBUywwREFBMEQ7QUFDM08sbUJBQW1CLGNBQWM7QUFDakMsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQix3Q0FBd0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFD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MUQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdDQUF3QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvaHViLWFwaS9hcGlzL3JlYWN0aW9ucy1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWN0aW9uc0FwaSA9IGV4cG9ydHMuUmVhY3Rpb25zQXBpRmFjdG9yeSA9IGV4cG9ydHMuUmVhY3Rpb25zQXBpRnAgPSBleHBvcnRzLlJlYWN0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogUmVhY3Rpb25zQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVhY3Rpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBhbGwgcmVhY3Rpb25zIChsaWtlcyBvciByZWNhc3RzKSBvbiBhIHNwZWNpZmljIGNhc3QgaW4gdGhlIEZhcmNhc3RlciBuZXR3b3JrLiBUaGUgY2FzdCBpcyBpZGVudGlmaWVkIGJ5IGl0cyBjcmVhdG9yXFwncyBGSUQgYW5kIHVuaXF1ZSBoYXNoLiBUaGlzIGVuZHBvaW50IGhlbHBzIHRyYWNrIGVuZ2FnZW1lbnQgbWV0cmljcyBhbmQgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCBzcGVjaWZpYyBjb250ZW50LlxuICAgICAgICAgKiBAc3VtbWFyeSBPbiBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRGaWQgVGhlIEZJRCBvZiB0aGUgY2FzdFxcJiMzOTtzIGNyZWF0b3IuIFJlcXVpcmVkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBjYXN0IHRoYXQgcmVjZWl2ZWQgdGhlIHJlYWN0aW9ucy4gTXVzdCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGFyZ2V0X2hhc2guXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRIYXNoIFRoZSB1bmlxdWUgaGFzaCBpZGVudGlmaWVyIG9mIHRoZSBjYXN0IHRoYXQgcmVjZWl2ZWQgdGhlIHJlYWN0aW9ucy4gVGhpcyBpcyBhIDQwLWNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcgcHJlZml4ZWQgd2l0aCBcXCYjMzk7MHhcXCYjMzk7IHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY2FzdCB3aXRoaW4gdGhlIGNyZWF0b3JcXCYjMzk7cyBwb3N0cy4gTXVzdCBiZSB1c2VkIHdpdGggdGFyZ2V0X2ZpZC5cbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvblR5cGV9IHJlYWN0aW9uVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtY2FzdC1yZWFjdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaENhc3RSZWFjdGlvbnM6IGFzeW5jICh0YXJnZXRGaWQsIHRhcmdldEhhc2gsIHJlYWN0aW9uVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRGaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hDYXN0UmVhY3Rpb25zJywgJ3RhcmdldEZpZCcsIHRhcmdldEZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRIYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoQ2FzdFJlYWN0aW9ucycsICd0YXJnZXRIYXNoJywgdGFyZ2V0SGFzaCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdyZWFjdGlvblR5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hDYXN0UmVhY3Rpb25zJywgJ3JlYWN0aW9uVHlwZScsIHJlYWN0aW9uVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3JlYWN0aW9uc0J5Q2FzdGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRGaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RhcmdldF9maWQnXSA9IHRhcmdldEZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRIYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd0YXJnZXRfaGFzaCddID0gdGFyZ2V0SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFjdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3JlYWN0aW9uX3R5cGUnXSA9IHJlYWN0aW9uVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVNpemUnXSA9IHBhZ2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldmVyc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3JldmVyc2UnXSA9IHJldmVyc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlVG9rZW4nXSA9IHBhZ2VUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGFsbCByZWFjdGlvbnMgb2YgYSBzcGVjaWZpYyB0eXBlIChsaWtlIG9yIHJlY2FzdCkgdGhhdCB0YXJnZXQgYSBnaXZlbiBVUkwuIFRoaXMgZW5kcG9pbnQgaXMgdXNlZnVsIGZvciB0cmFja2luZyBlbmdhZ2VtZW50IHdpdGggY29udGVudCBhY3Jvc3MgdGhlIEZhcmNhc3RlciBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBUbyBhIHRhcmdldCBVUkxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUYXJnZXQgVVJMIHN0YXJ0aW5nIHdpdGggXFwmIzM5O2NoYWluOi8vXFwmIzM5Oy5cbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvblR5cGV9IFtyZWFjdGlvblR5cGVdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1yZWFjdGlvbnMtYnktdGFyZ2V0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hSZWFjdGlvbnNCeVRhcmdldDogYXN5bmMgKHVybCwgcmVhY3Rpb25UeXBlLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3VybCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFJlYWN0aW9uc0J5VGFyZ2V0JywgJ3VybCcsIHVybCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3JlYWN0aW9uc0J5VGFyZ2V0YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndXJsJ10gPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhY3Rpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZWFjdGlvbl90eXBlJ10gPSByZWFjdGlvblR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VTaXplJ10gPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVRva2VuJ10gPSBwYWdlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCByZWFjdGlvbnMgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIG9mIHRoZSByZWFjdGlvblxcJiMzOTtzIGNyZWF0b3JcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvblR5cGV9IHJlYWN0aW9uVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlci1yZWFjdGlvbnMpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFVzZXJSZWFjdGlvbnM6IGFzeW5jIChmaWQsIHJlYWN0aW9uVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyUmVhY3Rpb25zJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdyZWFjdGlvblR5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyUmVhY3Rpb25zJywgJ3JlYWN0aW9uVHlwZScsIHJlYWN0aW9uVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3JlYWN0aW9uc0J5RmlkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhY3Rpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZWFjdGlvbl90eXBlJ10gPSByZWFjdGlvblR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VTaXplJ10gPSBwYWdlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydyZXZlcnNlJ10gPSByZXZlcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZVRva2VuJ10gPSBwYWdlVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIpLCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zKSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSByZWFjdGlvbiBieSBpdHMgRklEIG9yIGNhc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBvciBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgcmVhY3Rpb25cXCYjMzk7cyBjcmVhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRGaWQgVGhlIEZJRCBvZiB0aGUgY2FzdFxcJiMzOTtzIGNyZWF0b3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEhhc2ggVGhlIGNhc3RcXCYjMzk7cyBoYXNoXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSByZWFjdGlvblR5cGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXJlYWN0aW9uLWJ5LWlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwUmVhY3Rpb25CeUlkOiBhc3luYyAoZmlkLCB0YXJnZXRGaWQsIHRhcmdldEhhc2gsIHJlYWN0aW9uVHlwZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwUmVhY3Rpb25CeUlkJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRGaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwUmVhY3Rpb25CeUlkJywgJ3RhcmdldEZpZCcsIHRhcmdldEZpZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0YXJnZXRIYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xvb2t1cFJlYWN0aW9uQnlJZCcsICd0YXJnZXRIYXNoJywgdGFyZ2V0SGFzaCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdyZWFjdGlvblR5cGUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwUmVhY3Rpb25CeUlkJywgJ3JlYWN0aW9uVHlwZScsIHJlYWN0aW9uVHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3JlYWN0aW9uQnlJZGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogJ0dFVCcgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBBcGlLZXlBdXRoIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIngtYXBpLWtleVwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2ZpZCddID0gZmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldEZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsndGFyZ2V0X2ZpZCddID0gdGFyZ2V0RmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldEhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RhcmdldF9oYXNoJ10gPSB0YXJnZXRIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlYWN0aW9uVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmVhY3Rpb25fdHlwZSddID0gcmVhY3Rpb25UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZWFjdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFJlYWN0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBSZWFjdGlvbnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBSZWFjdGlvbnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlJlYWN0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgYWxsIHJlYWN0aW9ucyAobGlrZXMgb3IgcmVjYXN0cykgb24gYSBzcGVjaWZpYyBjYXN0IGluIHRoZSBGYXJjYXN0ZXIgbmV0d29yay4gVGhlIGNhc3QgaXMgaWRlbnRpZmllZCBieSBpdHMgY3JlYXRvclxcJ3MgRklEIGFuZCB1bmlxdWUgaGFzaC4gVGhpcyBlbmRwb2ludCBoZWxwcyB0cmFjayBlbmdhZ2VtZW50IG1ldHJpY3MgYW5kIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggc3BlY2lmaWMgY29udGVudC5cbiAgICAgICAgICogQHN1bW1hcnkgT24gY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0RmlkIFRoZSBGSUQgb2YgdGhlIGNhc3RcXCYjMzk7cyBjcmVhdG9yLiBSZXF1aXJlZCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgY2FzdCB0aGF0IHJlY2VpdmVkIHRoZSByZWFjdGlvbnMuIE11c3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRhcmdldF9oYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SGFzaCBUaGUgdW5pcXVlIGhhc2ggaWRlbnRpZmllciBvZiB0aGUgY2FzdCB0aGF0IHJlY2VpdmVkIHRoZSByZWFjdGlvbnMuIFRoaXMgaXMgYSA0MC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgc3RyaW5nIHByZWZpeGVkIHdpdGggXFwmIzM5OzB4XFwmIzM5OyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGNhc3Qgd2l0aGluIHRoZSBjcmVhdG9yXFwmIzM5O3MgcG9zdHMuIE11c3QgYmUgdXNlZCB3aXRoIHRhcmdldF9maWQuXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSByZWFjdGlvblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3QtcmVhY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hDYXN0UmVhY3Rpb25zKHRhcmdldEZpZCwgdGFyZ2V0SGFzaCwgcmVhY3Rpb25UeXBlLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaENhc3RSZWFjdGlvbnModGFyZ2V0RmlkLCB0YXJnZXRIYXNoLCByZWFjdGlvblR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydSZWFjdGlvbnNBcGkuZmV0Y2hDYXN0UmVhY3Rpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhbGwgcmVhY3Rpb25zIG9mIGEgc3BlY2lmaWMgdHlwZSAobGlrZSBvciByZWNhc3QpIHRoYXQgdGFyZ2V0IGEgZ2l2ZW4gVVJMLiBUaGlzIGVuZHBvaW50IGlzIHVzZWZ1bCBmb3IgdHJhY2tpbmcgZW5nYWdlbWVudCB3aXRoIGNvbnRlbnQgYWNyb3NzIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgVG8gYSB0YXJnZXQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGFyZ2V0IFVSTCBzdGFydGluZyB3aXRoIFxcJiMzOTtjaGFpbjovL1xcJiMzOTsuXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSBbcmVhY3Rpb25UeXBlXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBNYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXR1cm4gaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gUmV2ZXJzZSB0aGUgc29ydCBvcmRlciwgcmV0dXJuaW5nIGxhdGVzdCBtZXNzYWdlcyBmaXJzdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VUb2tlbl0gVGhlIHBhZ2UgdG9rZW4gcmV0dXJuZWQgYnkgdGhlIHByZXZpb3VzIHF1ZXJ5LCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgZmV0Y2ggdGhlIGZpcnN0IHBhZ2VcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVhY3Rpb25zLWJ5LXRhcmdldClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoUmVhY3Rpb25zQnlUYXJnZXQodXJsLCByZWFjdGlvblR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoUmVhY3Rpb25zQnlUYXJnZXQodXJsLCByZWFjdGlvblR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydSZWFjdGlvbnNBcGkuZmV0Y2hSZWFjdGlvbnNCeVRhcmdldCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggcmVhY3Rpb25zIGJ5IGEgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgQnkgRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgcmVhY3Rpb25cXCYjMzk7cyBjcmVhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSByZWFjdGlvblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItcmVhY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hVc2VyUmVhY3Rpb25zKGZpZCwgcmVhY3Rpb25UeXBlLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJSZWFjdGlvbnMoZmlkLCByZWFjdGlvblR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydSZWFjdGlvbnNBcGkuZmV0Y2hVc2VyUmVhY3Rpb25zJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSByZWFjdGlvbiBieSBpdHMgRklEIG9yIGNhc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBvciBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBvZiB0aGUgcmVhY3Rpb25cXCYjMzk7cyBjcmVhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRGaWQgVGhlIEZJRCBvZiB0aGUgY2FzdFxcJiMzOTtzIGNyZWF0b3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEhhc2ggVGhlIGNhc3RcXCYjMzk7cyBoYXNoXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25UeXBlfSByZWFjdGlvblR5cGVcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVhY3Rpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBSZWFjdGlvbmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXJlYWN0aW9uLWJ5LWlkKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbG9va3VwUmVhY3Rpb25CeUlkKGZpZCwgdGFyZ2V0RmlkLCB0YXJnZXRIYXNoLCByZWFjdGlvblR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxvb2t1cFJlYWN0aW9uQnlJZChmaWQsIHRhcmdldEZpZCwgdGFyZ2V0SGFzaCwgcmVhY3Rpb25UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnUmVhY3Rpb25zQXBpLmxvb2t1cFJlYWN0aW9uQnlJZCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZWFjdGlvbnNBcGlGcCA9IFJlYWN0aW9uc0FwaUZwO1xuLyoqXG4gKiBSZWFjdGlvbnNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBSZWFjdGlvbnNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5SZWFjdGlvbnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGFsbCByZWFjdGlvbnMgKGxpa2VzIG9yIHJlY2FzdHMpIG9uIGEgc3BlY2lmaWMgY2FzdCBpbiB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuIFRoZSBjYXN0IGlzIGlkZW50aWZpZWQgYnkgaXRzIGNyZWF0b3JcXCdzIEZJRCBhbmQgdW5pcXVlIGhhc2guIFRoaXMgZW5kcG9pbnQgaGVscHMgdHJhY2sgZW5nYWdlbWVudCBtZXRyaWNzIGFuZCB1c2VyIGludGVyYWN0aW9ucyB3aXRoIHNwZWNpZmljIGNvbnRlbnQuXG4gICAgICAgICAqIEBzdW1tYXJ5IE9uIGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvbnNBcGlGZXRjaENhc3RSZWFjdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLWNhc3QtcmVhY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hDYXN0UmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaENhc3RSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0RmlkLCByZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRIYXNoLCByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGlvblR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhbGwgcmVhY3Rpb25zIG9mIGEgc3BlY2lmaWMgdHlwZSAobGlrZSBvciByZWNhc3QpIHRoYXQgdGFyZ2V0IGEgZ2l2ZW4gVVJMLiBUaGlzIGVuZHBvaW50IGlzIHVzZWZ1bCBmb3IgdHJhY2tpbmcgZW5nYWdlbWVudCB3aXRoIGNvbnRlbnQgYWNyb3NzIHRoZSBGYXJjYXN0ZXIgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgVG8gYSB0YXJnZXQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25zQXBpRmV0Y2hSZWFjdGlvbnNCeVRhcmdldFJlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtcmVhY3Rpb25zLWJ5LXRhcmdldClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoUmVhY3Rpb25zQnlUYXJnZXQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoUmVhY3Rpb25zQnlUYXJnZXQocmVxdWVzdFBhcmFtZXRlcnMudXJsLCByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGlvblR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCByZWFjdGlvbnMgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBCeSBGSURcbiAgICAgICAgICogQHBhcmFtIHtSZWFjdGlvbnNBcGlGZXRjaFVzZXJSZWFjdGlvbnNSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItcmVhY3Rpb25zKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VyUmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFVzZXJSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGlvblR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29rdXAgYSByZWFjdGlvbiBieSBpdHMgRklEIG9yIGNhc3QuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBvciBjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7UmVhY3Rpb25zQXBpTG9va3VwUmVhY3Rpb25CeUlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlYWN0aW9uYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtcmVhY3Rpb24tYnktaWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBsb29rdXBSZWFjdGlvbkJ5SWQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cFJlYWN0aW9uQnlJZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0SGFzaCwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25UeXBlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZWFjdGlvbnNBcGlGYWN0b3J5ID0gUmVhY3Rpb25zQXBpRmFjdG9yeTtcbi8qKlxuICogUmVhY3Rpb25zQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFJlYWN0aW9uc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFJlYWN0aW9uc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgcmVhY3Rpb25zIChsaWtlcyBvciByZWNhc3RzKSBvbiBhIHNwZWNpZmljIGNhc3QgaW4gdGhlIEZhcmNhc3RlciBuZXR3b3JrLiBUaGUgY2FzdCBpcyBpZGVudGlmaWVkIGJ5IGl0cyBjcmVhdG9yXFwncyBGSUQgYW5kIHVuaXF1ZSBoYXNoLiBUaGlzIGVuZHBvaW50IGhlbHBzIHRyYWNrIGVuZ2FnZW1lbnQgbWV0cmljcyBhbmQgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCBzcGVjaWZpYyBjb250ZW50LlxuICAgICAqIEBzdW1tYXJ5IE9uIGNhc3RcbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uc0FwaUZldGNoQ2FzdFJlYWN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFJlYWN0aW9uc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC1jYXN0LXJlYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoQ2FzdFJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuUmVhY3Rpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hDYXN0UmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEZpZCwgcmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0SGFzaCwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25UeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHJlYWN0aW9ucyBvZiBhIHNwZWNpZmljIHR5cGUgKGxpa2Ugb3IgcmVjYXN0KSB0aGF0IHRhcmdldCBhIGdpdmVuIFVSTC4gVGhpcyBlbmRwb2ludCBpcyB1c2VmdWwgZm9yIHRyYWNraW5nIGVuZ2FnZW1lbnQgd2l0aCBjb250ZW50IGFjcm9zcyB0aGUgRmFyY2FzdGVyIG5ldHdvcmsuXG4gICAgICogQHN1bW1hcnkgVG8gYSB0YXJnZXQgVVJMXG4gICAgICogQHBhcmFtIHtSZWFjdGlvbnNBcGlGZXRjaFJlYWN0aW9uc0J5VGFyZ2V0UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgUmVhY3Rpb25zQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaENhc3RSZWFjdGlvbnMyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXJlYWN0aW9ucy1ieS10YXJnZXQpXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaFJlYWN0aW9uc0J5VGFyZ2V0KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5SZWFjdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFJlYWN0aW9uc0J5VGFyZ2V0KHJlcXVlc3RQYXJhbWV0ZXJzLnVybCwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25UeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggcmVhY3Rpb25zIGJ5IGEgdXNlci5cbiAgICAgKiBAc3VtbWFyeSBCeSBGSURcbiAgICAgKiBAcGFyYW0ge1JlYWN0aW9uc0FwaUZldGNoVXNlclJlYWN0aW9uc1JlcXVlc3R9IHJlcXVlc3RQYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFJlYWN0aW9uc0FwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoQ2FzdFJlYWN0aW9uczIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hDYXN0UmVhY3Rpb25zMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VyLXJlYWN0aW9ucylcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlclJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuUmVhY3Rpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyUmVhY3Rpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3Rpb25UeXBlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgcmVhY3Rpb24gYnkgaXRzIEZJRCBvciBjYXN0LlxuICAgICAqIEBzdW1tYXJ5IEJ5IEZJRCBvciBjYXN0XG4gICAgICogQHBhcmFtIHtSZWFjdGlvbnNBcGlMb29rdXBSZWFjdGlvbkJ5SWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBSZWFjdGlvbnNBcGlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFjdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFJlYWN0aW9uYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXJlYWN0aW9uLWJ5LWlkKVxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwUmVhY3Rpb25CeUlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5SZWFjdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5sb29rdXBSZWFjdGlvbkJ5SWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRGaWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldEhhc2gsIHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aW9uVHlwZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFjdGlvbnNBcGkgPSBSZWFjdGlvbnNBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/reactions-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/storage-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/storage-api.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageApi = exports.StorageApiFactory = exports.StorageApiFp = exports.StorageApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * StorageApi - axios parameter creator\n * @export\n */\nconst StorageApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a user\\'s storage limits.\n         * @summary FID\\'s limits\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)\n         *\n         */\n        lookupUserStorageLimit: async (fid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('lookupUserStorageLimit', 'fid', fid);\n            const localVarPath = `/v1/storageLimitsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.StorageApiAxiosParamCreator = StorageApiAxiosParamCreator;\n/**\n * StorageApi - functional programming interface\n * @export\n */\nconst StorageApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.StorageApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a user\\'s storage limits.\n         * @summary FID\\'s limits\n         * @param {number} fid\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)\n         *\n         */\n        async lookupUserStorageLimit(fid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserStorageLimit(fid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['StorageApi.lookupUserStorageLimit']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.StorageApiFp = StorageApiFp;\n/**\n * StorageApi - factory interface\n * @export\n */\nconst StorageApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.StorageApiFp)(configuration);\n    return {\n        /**\n         * Fetch a user\\'s storage limits.\n         * @summary FID\\'s limits\n         * @param {StorageApiLookupUserStorageLimitRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)\n         *\n         */\n        lookupUserStorageLimit(requestParameters, options) {\n            return localVarFp.lookupUserStorageLimit(requestParameters.fid, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StorageApiFactory = StorageApiFactory;\n/**\n * StorageApi - object-oriented interface\n * @export\n * @class StorageApi\n * @extends {BaseAPI}\n */\nclass StorageApi extends base_1.BaseAPI {\n    /**\n     * Fetch a user\\'s storage limits.\n     * @summary FID\\'s limits\n     * @param {StorageApiLookupUserStorageLimitRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StorageApi\n     * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)\n     *\n     */\n    lookupUserStorageLimit(requestParameters, options) {\n        return (0, exports.StorageApiFp)(this.configuration).lookupUserStorageLimit(requestParameters.fid, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StorageApi = StorageApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9zdG9yYWdlLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsbUNBQW1DO0FBQzNHLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUF5QztBQUN4RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy9zdG9yYWdlLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcmFnZUFwaSA9IGV4cG9ydHMuU3RvcmFnZUFwaUZhY3RvcnkgPSBleHBvcnRzLlN0b3JhZ2VBcGlGcCA9IGV4cG9ydHMuU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogU3RvcmFnZUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFN0b3JhZ2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgdXNlclxcJ3Mgc3RvcmFnZSBsaW1pdHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZJRFxcJ3MgbGltaXRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8U3RvcmFnZUxpbWl0c1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgU3RvcmFnZUxpbWl0c1Jlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9sb29rdXAtdXNlci1zdG9yYWdlLWxpbWl0KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgbG9va3VwVXNlclN0b3JhZ2VMaW1pdDogYXN5bmMgKGZpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbG9va3VwVXNlclN0b3JhZ2VMaW1pdCcsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zdG9yYWdlTGltaXRzQnlGaWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3RvcmFnZUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU3RvcmFnZUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggYSB1c2VyXFwncyBzdG9yYWdlIGxpbWl0cy5cbiAgICAgICAgICogQHN1bW1hcnkgRklEXFwncyBsaW1pdHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdG9yYWdlTGltaXRzUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBTdG9yYWdlTGltaXRzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXN0b3JhZ2UtbGltaXQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsb29rdXBVc2VyU3RvcmFnZUxpbWl0KGZpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubG9va3VwVXNlclN0b3JhZ2VMaW1pdChmaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdG9yYWdlQXBpLmxvb2t1cFVzZXJTdG9yYWdlTGltaXQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3RvcmFnZUFwaUZwID0gU3RvcmFnZUFwaUZwO1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3RvcmFnZUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlN0b3JhZ2VBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgdXNlclxcJ3Mgc3RvcmFnZSBsaW1pdHMuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZJRFxcJ3MgbGltaXRzXG4gICAgICAgICAqIEBwYXJhbSB7U3RvcmFnZUFwaUxvb2t1cFVzZXJTdG9yYWdlTGltaXRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VMaW1pdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VMaW1pdHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvbG9va3VwLXVzZXItc3RvcmFnZS1saW1pdClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxvb2t1cFVzZXJTdG9yYWdlTGltaXQocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxvb2t1cFVzZXJTdG9yYWdlTGltaXQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdG9yYWdlQXBpRmFjdG9yeSA9IFN0b3JhZ2VBcGlGYWN0b3J5O1xuLyoqXG4gKiBTdG9yYWdlQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFN0b3JhZ2VBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTdG9yYWdlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEZldGNoIGEgdXNlclxcJ3Mgc3RvcmFnZSBsaW1pdHMuXG4gICAgICogQHN1bW1hcnkgRklEXFwncyBsaW1pdHNcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VBcGlMb29rdXBVc2VyU3RvcmFnZUxpbWl0UmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3RvcmFnZUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFN0b3JhZ2VMaW1pdHNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFN0b3JhZ2VMaW1pdHNSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2xvb2t1cC11c2VyLXN0b3JhZ2UtbGltaXQpXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBVc2VyU3RvcmFnZUxpbWl0KHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdG9yYWdlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubG9va3VwVXNlclN0b3JhZ2VMaW1pdChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcmFnZUFwaSA9IFN0b3JhZ2VBcGk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/storage-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/user-data-api.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/user-data-api.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserDataApi = exports.UserDataApiFactory = exports.UserDataApiFp = exports.UserDataApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * UserDataApi - axios parameter creator\n * @export\n */\nconst UserDataApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.\n         * @summary Fetch UserData for a FID\n         * @param {number} fid The FID that\\&#39;s being requested\n         * @param {UserDataType} [userDataType] The type of user data, either as a numerical value or type string. If this is omitted, all user data for the FID is returned\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)\n         *\n         */\n        fetchUserData: async (fid, userDataType, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUserData', 'fid', fid);\n            const localVarPath = `/v1/userDataByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (userDataType !== undefined) {\n                localVarQueryParameter['user_data_type'] = userDataType;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UserDataApiAxiosParamCreator = UserDataApiAxiosParamCreator;\n/**\n * UserDataApi - functional programming interface\n * @export\n */\nconst UserDataApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UserDataApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.\n         * @summary Fetch UserData for a FID\n         * @param {number} fid The FID that\\&#39;s being requested\n         * @param {UserDataType} [userDataType] The type of user data, either as a numerical value or type string. If this is omitted, all user data for the FID is returned\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)\n         *\n         */\n        async fetchUserData(fid, userDataType, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUserData(fid, userDataType, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserDataApi.fetchUserData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UserDataApiFp = UserDataApiFp;\n/**\n * UserDataApi - factory interface\n * @export\n */\nconst UserDataApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UserDataApiFp)(configuration);\n    return {\n        /**\n         * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.\n         * @summary Fetch UserData for a FID\n         * @param {UserDataApiFetchUserDataRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)\n         *\n         */\n        fetchUserData(requestParameters, options) {\n            return localVarFp.fetchUserData(requestParameters.fid, requestParameters.userDataType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UserDataApiFactory = UserDataApiFactory;\n/**\n * UserDataApi - object-oriented interface\n * @export\n * @class UserDataApi\n * @extends {BaseAPI}\n */\nclass UserDataApi extends base_1.BaseAPI {\n    /**\n     * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.\n     * @summary Fetch UserData for a FID\n     * @param {UserDataApiFetchUserDataRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UserDataApi\n     * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)\n     *\n     */\n    fetchUserData(requestParameters, options) {\n        return (0, exports.UserDataApiFp)(this.configuration).fetchUserData(requestParameters.fid, requestParameters.userDataType, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UserDataApi = UserDataApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy91c2VyLWRhdGEtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxvQ0FBb0M7QUFDL0csZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLHNCQUFzQjtBQUNqRCxtQkFBbUIsY0FBYztBQUNqQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLHNCQUFzQjtBQUNqRCxtQkFBbUIsY0FBYztBQUNqQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2FwaXMvdXNlci1kYXRhLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXNlckRhdGFBcGkgPSBleHBvcnRzLlVzZXJEYXRhQXBpRmFjdG9yeSA9IGV4cG9ydHMuVXNlckRhdGFBcGlGcCA9IGV4cG9ydHMuVXNlckRhdGFBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIFVzZXJEYXRhQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlckRhdGFBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHVzZXJfZGF0YV90eXBlYCBwYXJhbWV0ZXIuIElmIGluY2x1ZGVkLCBhIHNpbmdsZSBgVXNlckRhdGFBZGRgIG1lc3NhZ2UgaXMgcmV0dXJuZWQgKG9yIGEgYG5vdF9mb3VuZGAgZXJyb3IpLiBJZiBvbWl0dGVkLCBhIHBhZ2luYXRlZCBsaXN0IG9mIGBVc2VyRGF0YUFkZGAgbWVzc2FnZXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggVXNlckRhdGEgZm9yIGEgRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCB0aGF0XFwmIzM5O3MgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckRhdGFUeXBlfSBbdXNlckRhdGFUeXBlXSBUaGUgdHlwZSBvZiB1c2VyIGRhdGEsIGVpdGhlciBhcyBhIG51bWVyaWNhbCB2YWx1ZSBvciB0eXBlIHN0cmluZy4gSWYgdGhpcyBpcyBvbWl0dGVkLCBhbGwgdXNlciBkYXRhIGZvciB0aGUgRklEIGlzIHJldHVybmVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZGF0YSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckRhdGE6IGFzeW5jIChmaWQsIHVzZXJEYXRhVHlwZSwgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VyRGF0YScsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS91c2VyRGF0YUJ5RmlkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbWV0aG9kOiAnR0VUJyB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIEFwaUtleUF1dGggcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwieC1hcGkta2V5XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGZpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZmlkJ10gPSBmaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWyd1c2VyX2RhdGFfdHlwZSddID0gdXNlckRhdGFUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlU2l6ZSddID0gcGFnZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmV2ZXJzZSddID0gcmV2ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Vc2VyRGF0YUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gVXNlckRhdGFBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVXNlckRhdGFBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBVc2VyRGF0YUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuVXNlckRhdGFBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHVzZXJfZGF0YV90eXBlYCBwYXJhbWV0ZXIuIElmIGluY2x1ZGVkLCBhIHNpbmdsZSBgVXNlckRhdGFBZGRgIG1lc3NhZ2UgaXMgcmV0dXJuZWQgKG9yIGEgYG5vdF9mb3VuZGAgZXJyb3IpLiBJZiBvbWl0dGVkLCBhIHBhZ2luYXRlZCBsaXN0IG9mIGBVc2VyRGF0YUFkZGAgbWVzc2FnZXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggVXNlckRhdGEgZm9yIGEgRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCB0aGF0XFwmIzM5O3MgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckRhdGFUeXBlfSBbdXNlckRhdGFUeXBlXSBUaGUgdHlwZSBvZiB1c2VyIGRhdGEsIGVpdGhlciBhcyBhIG51bWVyaWNhbCB2YWx1ZSBvciB0eXBlIHN0cmluZy4gSWYgdGhpcyBpcyBvbWl0dGVkLCBhbGwgdXNlciBkYXRhIGZvciB0aGUgRklEIGlzIHJldHVybmVkXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZGF0YSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoVXNlckRhdGEoZmlkLCB1c2VyRGF0YVR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVXNlckRhdGEoZmlkLCB1c2VyRGF0YVR5cGUsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VyRGF0YUFwaS5mZXRjaFVzZXJEYXRhJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlVzZXJEYXRhQXBpRnAgPSBVc2VyRGF0YUFwaUZwO1xuLyoqXG4gKiBVc2VyRGF0YUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJEYXRhQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVXNlckRhdGFBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICoqTm90ZToqKiBvbmUgb2YgdHdvIGRpZmZlcmVudCByZXNwb25zZSBzY2hlbWFzIGlzIHJldHVybmVkIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgYHVzZXJfZGF0YV90eXBlYCBwYXJhbWV0ZXIuIElmIGluY2x1ZGVkLCBhIHNpbmdsZSBgVXNlckRhdGFBZGRgIG1lc3NhZ2UgaXMgcmV0dXJuZWQgKG9yIGEgYG5vdF9mb3VuZGAgZXJyb3IpLiBJZiBvbWl0dGVkLCBhIHBhZ2luYXRlZCBsaXN0IG9mIGBVc2VyRGF0YUFkZGAgbWVzc2FnZXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggVXNlckRhdGEgZm9yIGEgRklEXG4gICAgICAgICAqIEBwYXJhbSB7VXNlckRhdGFBcGlGZXRjaFVzZXJEYXRhUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFVzZXJEYXRhMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZGF0YSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlckRhdGEocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmZldGNoVXNlckRhdGEocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy51c2VyRGF0YVR5cGUsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlVzZXJEYXRhQXBpRmFjdG9yeSA9IFVzZXJEYXRhQXBpRmFjdG9yeTtcbi8qKlxuICogVXNlckRhdGFBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVXNlckRhdGFBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBVc2VyRGF0YUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiAqKk5vdGU6Kiogb25lIG9mIHR3byBkaWZmZXJlbnQgcmVzcG9uc2Ugc2NoZW1hcyBpcyByZXR1cm5lZCBiYXNlZCBvbiB3aGV0aGVyIHRoZSBjYWxsZXIgcHJvdmlkZXMgdGhlIGB1c2VyX2RhdGFfdHlwZWAgcGFyYW1ldGVyLiBJZiBpbmNsdWRlZCwgYSBzaW5nbGUgYFVzZXJEYXRhQWRkYCBtZXNzYWdlIGlzIHJldHVybmVkIChvciBhIGBub3RfZm91bmRgIGVycm9yKS4gSWYgb21pdHRlZCwgYSBwYWdpbmF0ZWQgbGlzdCBvZiBgVXNlckRhdGFBZGRgIG1lc3NhZ2VzIGlzIHJldHVybmVkIGluc3RlYWQuXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggVXNlckRhdGEgZm9yIGEgRklEXG4gICAgICogQHBhcmFtIHtVc2VyRGF0YUFwaUZldGNoVXNlckRhdGFSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBVc2VyRGF0YUFwaVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVXNlckRhdGEyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVXNlckRhdGEyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXItZGF0YSlcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVXNlckRhdGEocmVxdWVzdFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlVzZXJEYXRhQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hVc2VyRGF0YShyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJEYXRhVHlwZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVNpemUsIHJlcXVlc3RQYXJhbWV0ZXJzLnJldmVyc2UsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VUb2tlbiwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Vc2VyRGF0YUFwaSA9IFVzZXJEYXRhQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/user-data-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/usernames-api.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/usernames-api.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UsernamesApi = exports.UsernamesApiFactory = exports.UsernamesApiFp = exports.UsernamesApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * UsernamesApi - axios parameter creator\n * @export\n */\nconst UsernamesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch a proof for a username.\n         * @summary Proof for a username\n         * @param {string} name The Farcaster username or ENS address\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)\n         *\n         */\n        fetchUsernameProofByName: async (name, options = {}) => {\n            // verify required parameter 'name' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsernameProofByName', 'name', name);\n            const localVarPath = `/v1/userNameProofByName`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (name !== undefined) {\n                localVarQueryParameter['name'] = name;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch proofs provided by a user.\n         * @summary Proofs provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)\n         *\n         */\n        fetchUsernameProofsByFid: async (fid, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchUsernameProofsByFid', 'fid', fid);\n            const localVarPath = `/v1/userNameProofsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UsernamesApiAxiosParamCreator = UsernamesApiAxiosParamCreator;\n/**\n * UsernamesApi - functional programming interface\n * @export\n */\nconst UsernamesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UsernamesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch a proof for a username.\n         * @summary Proof for a username\n         * @param {string} name The Farcaster username or ENS address\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)\n         *\n         */\n        async fetchUsernameProofByName(name, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsernameProofByName(name, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsernamesApi.fetchUsernameProofByName']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch proofs provided by a user.\n         * @summary Proofs provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)\n         *\n         */\n        async fetchUsernameProofsByFid(fid, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchUsernameProofsByFid(fid, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UsernamesApi.fetchUsernameProofsByFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UsernamesApiFp = UsernamesApiFp;\n/**\n * UsernamesApi - factory interface\n * @export\n */\nconst UsernamesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UsernamesApiFp)(configuration);\n    return {\n        /**\n         * Fetch a proof for a username.\n         * @summary Proof for a username\n         * @param {UsernamesApiFetchUsernameProofByNameRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)\n         *\n         */\n        fetchUsernameProofByName(requestParameters, options) {\n            return localVarFp.fetchUsernameProofByName(requestParameters.name, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch proofs provided by a user.\n         * @summary Proofs provided by an FID\n         * @param {UsernamesApiFetchUsernameProofsByFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)\n         *\n         */\n        fetchUsernameProofsByFid(requestParameters, options) {\n            return localVarFp.fetchUsernameProofsByFid(requestParameters.fid, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UsernamesApiFactory = UsernamesApiFactory;\n/**\n * UsernamesApi - object-oriented interface\n * @export\n * @class UsernamesApi\n * @extends {BaseAPI}\n */\nclass UsernamesApi extends base_1.BaseAPI {\n    /**\n     * Fetch a proof for a username.\n     * @summary Proof for a username\n     * @param {UsernamesApiFetchUsernameProofByNameRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsernamesApi\n     * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)\n     *\n     */\n    fetchUsernameProofByName(requestParameters, options) {\n        return (0, exports.UsernamesApiFp)(this.configuration).fetchUsernameProofByName(requestParameters.name, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch proofs provided by a user.\n     * @summary Proofs provided by an FID\n     * @param {UsernamesApiFetchUsernameProofsByFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsernamesApi\n     * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)\n     *\n     */\n    fetchUsernameProofsByFid(requestParameters, options) {\n        return (0, exports.UsernamesApiFp)(this.configuration).fetchUsernameProofsByFid(requestParameters.fid, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UsernamesApi = UsernamesApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy91c2VybmFtZXMtYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxxQ0FBcUM7QUFDbkgsZ0NBQWdDLG1CQUFPLENBQUMsNkRBQU87QUFDL0M7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3BDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQTZDO0FBQ2hFLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQTZDO0FBQzVELGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvaHViLWFwaS9hcGlzL3VzZXJuYW1lcy1hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVzZXJuYW1lc0FwaSA9IGV4cG9ydHMuVXNlcm5hbWVzQXBpRmFjdG9yeSA9IGV4cG9ydHMuVXNlcm5hbWVzQXBpRnAgPSBleHBvcnRzLlVzZXJuYW1lc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogVXNlcm5hbWVzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcm5hbWVzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBhIHByb29mIGZvciBhIHVzZXJuYW1lLlxuICAgICAgICAgKiBAc3VtbWFyeSBQcm9vZiBmb3IgYSB1c2VybmFtZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgRmFyY2FzdGVyIHVzZXJuYW1lIG9yIEVOUyBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVzZXJOYW1lUHJvb2Y+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBVc2VyTmFtZVByb29mYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VybmFtZS1wcm9vZi1ieS1uYW1lKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lOiBhc3luYyAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoVXNlcm5hbWVQcm9vZkJ5TmFtZScsICduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3VzZXJOYW1lUHJvb2ZCeU5hbWVgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHByb29mcyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb29mcyBwcm92aWRlZCBieSBhbiBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIGJlaW5nIHJlcXVlc3RlZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VybmFtZVByb29mc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcm5hbWVQcm9vZnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcm5hbWUtcHJvb2ZzLWJ5LWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlcm5hbWVQcm9vZnNCeUZpZDogYXN5bmMgKGZpZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmaWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hVc2VybmFtZVByb29mc0J5RmlkJywgJ2ZpZCcsIGZpZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3VzZXJOYW1lUHJvb2ZzQnlGaWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcm5hbWVzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBVc2VybmFtZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVXNlcm5hbWVzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcm5hbWVzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5Vc2VybmFtZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgcHJvb2YgZm9yIGEgdXNlcm5hbWUuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb29mIGZvciBhIHVzZXJuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBGYXJjYXN0ZXIgdXNlcm5hbWUgb3IgRU5TIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlck5hbWVQcm9vZj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJOYW1lUHJvb2ZgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJuYW1lLXByb29mLWJ5LW5hbWUpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJuYW1lUHJvb2ZCeU5hbWUobmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lKG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5zZXJ2ZXJJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydVc2VybmFtZXNBcGkuZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lJ10pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBwcm9vZnMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBQcm9vZnMgcHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcm5hbWVQcm9vZnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJuYW1lUHJvb2ZzUmVzcG9uc2VgIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtBUEkgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLm5leW5hci5jb20vcmVmZXJlbmNlL2ZldGNoLXVzZXJuYW1lLXByb29mcy1ieS1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFVzZXJuYW1lUHJvb2ZzQnlGaWQoZmlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFVzZXJuYW1lUHJvb2ZzQnlGaWQoZmlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uc2VydmVySW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gKF9jID0gKF9iID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVXNlcm5hbWVzQXBpLmZldGNoVXNlcm5hbWVQcm9vZnNCeUZpZCddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Vc2VybmFtZXNBcGlGcCA9IFVzZXJuYW1lc0FwaUZwO1xuLyoqXG4gKiBVc2VybmFtZXNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBVc2VybmFtZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Vc2VybmFtZXNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGEgcHJvb2YgZm9yIGEgdXNlcm5hbWUuXG4gICAgICAgICAqIEBzdW1tYXJ5IFByb29mIGZvciBhIHVzZXJuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7VXNlcm5hbWVzQXBpRmV0Y2hVc2VybmFtZVByb29mQnlOYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VyTmFtZVByb29mPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlck5hbWVQcm9vZmAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcm5hbWUtcHJvb2YtYnktbmFtZSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlcm5hbWVQcm9vZkJ5TmFtZShyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBwcm9vZnMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBQcm9vZnMgcHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7VXNlcm5hbWVzQXBpRmV0Y2hVc2VybmFtZVByb29mc0J5RmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxVc2VybmFtZVByb29mc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVXNlcm5hbWVQcm9vZnNSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdXNlcm5hbWUtcHJvb2ZzLWJ5LWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVXNlcm5hbWVQcm9vZnNCeUZpZChyZXF1ZXN0UGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hVc2VybmFtZVByb29mc0J5RmlkKHJlcXVlc3RQYXJhbWV0ZXJzLmZpZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcm5hbWVzQXBpRmFjdG9yeSA9IFVzZXJuYW1lc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFVzZXJuYW1lc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBVc2VybmFtZXNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBVc2VybmFtZXNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBwcm9vZiBmb3IgYSB1c2VybmFtZS5cbiAgICAgKiBAc3VtbWFyeSBQcm9vZiBmb3IgYSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7VXNlcm5hbWVzQXBpRmV0Y2hVc2VybmFtZVByb29mQnlOYW1lUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlcm5hbWVzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlck5hbWVQcm9vZj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJOYW1lUHJvb2ZgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VybmFtZS1wcm9vZi1ieS1uYW1lKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VybmFtZVByb29mQnlOYW1lKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Vc2VybmFtZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJuYW1lUHJvb2ZCeU5hbWUocmVxdWVzdFBhcmFtZXRlcnMubmFtZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHByb29mcyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICogQHN1bW1hcnkgUHJvb2ZzIHByb3ZpZGVkIGJ5IGFuIEZJRFxuICAgICAqIEBwYXJhbSB7VXNlcm5hbWVzQXBpRmV0Y2hVc2VybmFtZVByb29mc0J5RmlkUmVxdWVzdH0gcmVxdWVzdFBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVXNlcm5hbWVzQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VXNlcm5hbWVQcm9vZnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYFVzZXJuYW1lUHJvb2ZzUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC11c2VybmFtZS1wcm9vZnMtYnktZmlkKVxuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2hVc2VybmFtZVByb29mc0J5RmlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Vc2VybmFtZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFVzZXJuYW1lUHJvb2ZzQnlGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJuYW1lc0FwaSA9IFVzZXJuYW1lc0FwaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/usernames-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/verifications-api.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/verifications-api.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VerificationsApi = exports.VerificationsApiFactory = exports.VerificationsApiFp = exports.VerificationsApiAxiosParamCreator = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n * VerificationsApi - axios parameter creator\n * @export\n */\nconst VerificationsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Fetch verifications provided by a user.\n         * @summary Provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {string} [address] The optional ETH address to filter by\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)\n         *\n         */\n        fetchVerificationsByFid: async (fid, address, pageSize, reverse, pageToken, options = {}) => {\n            // verify required parameter 'fid' is not null or undefined\n            (0, common_1.assertParamExists)('fetchVerificationsByFid', 'fid', fid);\n            const localVarPath = `/v1/verificationsByFid`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication ApiKeyAuth required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"x-api-key\", configuration);\n            if (fid !== undefined) {\n                localVarQueryParameter['fid'] = fid;\n            }\n            if (address !== undefined) {\n                localVarQueryParameter['address'] = address;\n            }\n            if (pageSize !== undefined) {\n                localVarQueryParameter['pageSize'] = pageSize;\n            }\n            if (reverse !== undefined) {\n                localVarQueryParameter['reverse'] = reverse;\n            }\n            if (pageToken !== undefined) {\n                localVarQueryParameter['pageToken'] = pageToken;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.VerificationsApiAxiosParamCreator = VerificationsApiAxiosParamCreator;\n/**\n * VerificationsApi - functional programming interface\n * @export\n */\nconst VerificationsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.VerificationsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Fetch verifications provided by a user.\n         * @summary Provided by an FID\n         * @param {number} fid The FID being requested\n         * @param {string} [address] The optional ETH address to filter by\n         * @param {number} [pageSize] Maximum number of messages to return in a single response\n         * @param {boolean} [reverse] Reverse the sort order, returning latest messages first\n         * @param {string} [pageToken] The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)\n         *\n         */\n        async fetchVerificationsByFid(fid, address, pageSize, reverse, pageToken, options) {\n            var _a, _b, _c;\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchVerificationsByFid(fid, address, pageSize, reverse, pageToken, options);\n            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['VerificationsApi.fetchVerificationsByFid']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.VerificationsApiFp = VerificationsApiFp;\n/**\n * VerificationsApi - factory interface\n * @export\n */\nconst VerificationsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.VerificationsApiFp)(configuration);\n    return {\n        /**\n         * Fetch verifications provided by a user.\n         * @summary Provided by an FID\n         * @param {VerificationsApiFetchVerificationsByFidRequest} requestParameters Request parameters.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object\n         *\n         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)\n         *\n         */\n        fetchVerificationsByFid(requestParameters, options) {\n            return localVarFp.fetchVerificationsByFid(requestParameters.fid, requestParameters.address, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.VerificationsApiFactory = VerificationsApiFactory;\n/**\n * VerificationsApi - object-oriented interface\n * @export\n * @class VerificationsApi\n * @extends {BaseAPI}\n */\nclass VerificationsApi extends base_1.BaseAPI {\n    /**\n     * Fetch verifications provided by a user.\n     * @summary Provided by an FID\n     * @param {VerificationsApiFetchVerificationsByFidRequest} requestParameters Request parameters.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VerificationsApi\n     * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object\n     *\n     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)\n     *\n     */\n    fetchVerificationsByFid(requestParameters, options) {\n        return (0, exports.VerificationsApiFp)(this.configuration).fetchVerificationsByFid(requestParameters.fid, requestParameters.address, requestParameters.pageSize, requestParameters.reverse, requestParameters.pageToken, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.VerificationsApi = VerificationsApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy92ZXJpZmljYXRpb25zLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCLEdBQUcseUNBQXlDO0FBQ25JLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVztBQUNwQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCLDZDQUE2QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNkNBQTZDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQixxQkFBcUIsNkNBQTZDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFnRDtBQUMvRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYXBpcy92ZXJpZmljYXRpb25zLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVyaWZpY2F0aW9uc0FwaSA9IGV4cG9ydHMuVmVyaWZpY2F0aW9uc0FwaUZhY3RvcnkgPSBleHBvcnRzLlZlcmlmaWNhdGlvbnNBcGlGcCA9IGV4cG9ydHMuVmVyaWZpY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogVmVyaWZpY2F0aW9uc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZlcmlmaWNhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHZlcmlmaWNhdGlvbnMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBQcm92aWRlZCBieSBhbiBGSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZpZCBUaGUgRklEIGJlaW5nIHJlcXVlc3RlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FkZHJlc3NdIFRoZSBvcHRpb25hbCBFVEggYWRkcmVzcyB0byBmaWx0ZXIgYnlcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuIGluIGEgc2luZ2xlIHJlc3BvbnNlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIFJldmVyc2UgdGhlIHNvcnQgb3JkZXIsIHJldHVybmluZyBsYXRlc3QgbWVzc2FnZXMgZmlyc3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlVG9rZW5dIFRoZSBwYWdlIHRva2VuIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBxdWVyeSwgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgZW1wdHksIGZldGNoIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVmVyaWZpY2F0aW9uc0J5RmlkMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFZlcmlmaWNhdGlvbnNCeUZpZDIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12ZXJpZmljYXRpb25zLWJ5LWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVmVyaWZpY2F0aW9uc0J5RmlkOiBhc3luYyAoZmlkLCBhZGRyZXNzLCBwYWdlU2l6ZSwgcmV2ZXJzZSwgcGFnZVRva2VuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFZlcmlmaWNhdGlvbnNCeUZpZCcsICdmaWQnLCBmaWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS92ZXJpZmljYXRpb25zQnlGaWRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6ICdHRVQnIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gQXBpS2V5QXV0aCByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJ4LWFwaS1rZXlcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAoZmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmaWQnXSA9IGZpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhZGRyZXNzJ10gPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlU2l6ZSddID0gcGFnZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncmV2ZXJzZSddID0gcmV2ZXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyKSwgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5WZXJpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBWZXJpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFZlcmlmaWNhdGlvbnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBWZXJpZmljYXRpb25zQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5WZXJpZmljYXRpb25zQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCB2ZXJpZmljYXRpb25zIHByb3ZpZGVkIGJ5IGEgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgUHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWQgVGhlIEZJRCBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSBUaGUgb3B0aW9uYWwgRVRIIGFkZHJlc3MgdG8gZmlsdGVyIGJ5XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIE1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVybiBpbiBhIHNpbmdsZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBSZXZlcnNlIHRoZSBzb3J0IG9yZGVyLCByZXR1cm5pbmcgbGF0ZXN0IG1lc3NhZ2VzIGZpcnN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZVRva2VuXSBUaGUgcGFnZSB0b2tlbiByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgcXVlcnksIHRvIGZldGNoIHRoZSBuZXh0IHBhZ2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGVtcHR5LCBmZXRjaCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFZlcmlmaWNhdGlvbnNCeUZpZDIwMFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmV0Y2hWZXJpZmljYXRpb25zQnlGaWQyMDBSZXNwb25zZWAgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW0FQSSBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UvZmV0Y2gtdmVyaWZpY2F0aW9ucy1ieS1maWQpXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFZlcmlmaWNhdGlvbnNCeUZpZChmaWQsIGFkZHJlc3MsIHBhZ2VTaXplLCByZXZlcnNlLCBwYWdlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoVmVyaWZpY2F0aW9uc0J5RmlkKGZpZCwgYWRkcmVzcywgcGFnZVNpemUsIHJldmVyc2UsIHBhZ2VUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IChfYyA9IChfYiA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1ZlcmlmaWNhdGlvbnNBcGkuZmV0Y2hWZXJpZmljYXRpb25zQnlGaWQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVmVyaWZpY2F0aW9uc0FwaUZwID0gVmVyaWZpY2F0aW9uc0FwaUZwO1xuLyoqXG4gKiBWZXJpZmljYXRpb25zQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmVyaWZpY2F0aW9uc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlZlcmlmaWNhdGlvbnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHZlcmlmaWNhdGlvbnMgcHJvdmlkZWQgYnkgYSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBQcm92aWRlZCBieSBhbiBGSURcbiAgICAgICAgICogQHBhcmFtIHtWZXJpZmljYXRpb25zQXBpRmV0Y2hWZXJpZmljYXRpb25zQnlGaWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoVmVyaWZpY2F0aW9uc0J5RmlkMjAwUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBGZXRjaFZlcmlmaWNhdGlvbnNCeUZpZDIwMFJlc3BvbnNlYCBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12ZXJpZmljYXRpb25zLWJ5LWZpZClcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZldGNoVmVyaWZpY2F0aW9uc0J5RmlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFZlcmlmaWNhdGlvbnNCeUZpZChyZXF1ZXN0UGFyYW1ldGVycy5maWQsIHJlcXVlc3RQYXJhbWV0ZXJzLmFkZHJlc3MsIHJlcXVlc3RQYXJhbWV0ZXJzLnBhZ2VTaXplLCByZXF1ZXN0UGFyYW1ldGVycy5yZXZlcnNlLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlVG9rZW4sIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlZlcmlmaWNhdGlvbnNBcGlGYWN0b3J5ID0gVmVyaWZpY2F0aW9uc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFZlcmlmaWNhdGlvbnNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgVmVyaWZpY2F0aW9uc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFZlcmlmaWNhdGlvbnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggdmVyaWZpY2F0aW9ucyBwcm92aWRlZCBieSBhIHVzZXIuXG4gICAgICogQHN1bW1hcnkgUHJvdmlkZWQgYnkgYW4gRklEXG4gICAgICogQHBhcmFtIHtWZXJpZmljYXRpb25zQXBpRmV0Y2hWZXJpZmljYXRpb25zQnlGaWRSZXF1ZXN0fSByZXF1ZXN0UGFyYW1ldGVycyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBWZXJpZmljYXRpb25zQXBpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hWZXJpZmljYXRpb25zQnlGaWQyMDBSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZldGNoVmVyaWZpY2F0aW9uc0J5RmlkMjAwUmVzcG9uc2VgIG9iamVjdFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBbQVBJIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZS9mZXRjaC12ZXJpZmljYXRpb25zLWJ5LWZpZClcbiAgICAgKlxuICAgICAqL1xuICAgIGZldGNoVmVyaWZpY2F0aW9uc0J5RmlkKHJlcXVlc3RQYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5WZXJpZmljYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hWZXJpZmljYXRpb25zQnlGaWQocmVxdWVzdFBhcmFtZXRlcnMuZmlkLCByZXF1ZXN0UGFyYW1ldGVycy5hZGRyZXNzLCByZXF1ZXN0UGFyYW1ldGVycy5wYWdlU2l6ZSwgcmVxdWVzdFBhcmFtZXRlcnMucmV2ZXJzZSwgcmVxdWVzdFBhcmFtZXRlcnMucGFnZVRva2VuLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlZlcmlmaWNhdGlvbnNBcGkgPSBWZXJpZmljYXRpb25zQXBpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/apis/verifications-api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js":
/*!***************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nexports.BASE_PATH = \"https://hub-api.neynar.com\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        var _a;\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n/**\n *\n * @export\n */\nexports.operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLDBCQUEwQixHQUFHLGlCQUFpQjtBQUNySCxnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2Jhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IGV4cG9ydHMuUmVxdWlyZWRFcnJvciA9IGV4cG9ydHMuQmFzZUFQSSA9IGV4cG9ydHMuQ09MTEVDVElPTl9GT1JNQVRTID0gZXhwb3J0cy5CQVNFX1BBVEggPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5leHBvcnRzLkJBU0VfUEFUSCA9IFwiaHR0cHM6Ly9odWItYXBpLm5leW5hci5jb21cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IHtcbiAgICBjc3Y6IFwiLFwiLFxuICAgIHNzdjogXCIgXCIsXG4gICAgdHN2OiBcIlxcdFwiLFxuICAgIHBpcGVzOiBcInxcIixcbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQmFzZUFQSVxuICovXG5jbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBiYXNlUGF0aCA9IGV4cG9ydHMuQkFTRV9QQVRILCBheGlvcyA9IGF4aW9zXzEuZGVmYXVsdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICAgICAgdGhpcy5heGlvcyA9IGF4aW9zO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSAoX2EgPSBjb25maWd1cmF0aW9uLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFQSSA9IEJhc2VBUEk7XG47XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUmVxdWlyZWRFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBSZXF1aXJlZEVycm9yO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = async function (object, keyParamName, configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = async function (object, configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = async function (object, name, scopes, configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n};\nexports.setOAuthToObject = setOAuthToObject;\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        var _a;\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: (axios.defaults.baseURL ? '' : (_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsb0JBQW9CLEdBQUcsNkJBQTZCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ3pSLGVBQWUsbUJBQU8sQ0FBQyw2RUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFdBQVcscUNBQXFDLGFBQWE7QUFDckk7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILElBQUksRUFBRSxzQkFBc0IsRUFBRSxXQUFXO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx3QkFBd0IsNExBQTRMO0FBQ25SO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2NvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGYXJjYXN0ZXIgSHViIEFQSVxuICogUGVyZm9ybSBiYXNpYyBxdWVyaWVzIG9mIEZhcmNhc3RlciBzdGF0ZSB2aWEgdGhlIFJFU1QgQVBJIG9mIGEgRmFyY2FzdGVyIGh1Yi4gU2VlIHRoZSBbTmV5bmFyIGRvY3NdKGh0dHBzOi8vZG9jcy5uZXluYXIuY29tL3JlZmVyZW5jZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMi4zNS4wXG4gKiBDb250YWN0OiB0ZWFtQG5leW5hci5jb21cbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uID0gZXhwb3J0cy50b1BhdGhTdHJpbmcgPSBleHBvcnRzLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IGV4cG9ydHMuc2V0U2VhcmNoUGFyYW1zID0gZXhwb3J0cy5zZXRPQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEJhc2ljQXV0aFRvT2JqZWN0ID0gZXhwb3J0cy5zZXRBcGlLZXlUb09iamVjdCA9IGV4cG9ydHMuYXNzZXJ0UGFyYW1FeGlzdHMgPSBleHBvcnRzLkRVTU1ZX0JBU0VfVVJMID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0cy5EVU1NWV9CQVNFX1VSTCA9ICdodHRwczovL2V4YW1wbGUuY29tJztcbi8qKlxuICpcbiAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IGFzc2VydFBhcmFtRXhpc3RzID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSwgcGFyYW1OYW1lLCBwYXJhbVZhbHVlKSB7XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwgfHwgcGFyYW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBiYXNlXzEuUmVxdWlyZWRFcnJvcihwYXJhbU5hbWUsIGBSZXF1aXJlZCBwYXJhbWV0ZXIgJHtwYXJhbU5hbWV9IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgJHtmdW5jdGlvbk5hbWV9LmApO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydFBhcmFtRXhpc3RzID0gYXNzZXJ0UGFyYW1FeGlzdHM7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldEFwaUtleVRvT2JqZWN0ID0gYXN5bmMgZnVuY3Rpb24gKG9iamVjdCwga2V5UGFyYW1OYW1lLCBjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgY29uc3QgbG9jYWxWYXJBcGlLZXlWYWx1ZSA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFwaUtleSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhd2FpdCBjb25maWd1cmF0aW9uLmFwaUtleShrZXlQYXJhbU5hbWUpXG4gICAgICAgICAgICA6IGF3YWl0IGNvbmZpZ3VyYXRpb24uYXBpS2V5O1xuICAgICAgICBvYmplY3Rba2V5UGFyYW1OYW1lXSA9IGxvY2FsVmFyQXBpS2V5VmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0QXBpS2V5VG9PYmplY3QgPSBzZXRBcGlLZXlUb09iamVjdDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0QmFzaWNBdXRoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgKGNvbmZpZ3VyYXRpb24udXNlcm5hbWUgfHwgY29uZmlndXJhdGlvbi5wYXNzd29yZCkpIHtcbiAgICAgICAgb2JqZWN0W1wiYXV0aFwiXSA9IHsgdXNlcm5hbWU6IGNvbmZpZ3VyYXRpb24udXNlcm5hbWUsIHBhc3N3b3JkOiBjb25maWd1cmF0aW9uLnBhc3N3b3JkIH07XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0QmFzaWNBdXRoVG9PYmplY3QgPSBzZXRCYXNpY0F1dGhUb09iamVjdDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0QmVhcmVyQXV0aFRvT2JqZWN0ID0gYXN5bmMgZnVuY3Rpb24gKG9iamVjdCwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKClcbiAgICAgICAgICAgIDogYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgb2JqZWN0W1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIFwiICsgYWNjZXNzVG9rZW47XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0QmVhcmVyQXV0aFRvT2JqZWN0ID0gc2V0QmVhcmVyQXV0aFRvT2JqZWN0O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRPQXV0aFRvT2JqZWN0ID0gYXN5bmMgZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgc2NvcGVzLCBjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBsb2NhbFZhckFjY2Vzc1Rva2VuVmFsdWUgPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKG5hbWUsIHNjb3BlcylcbiAgICAgICAgICAgIDogYXdhaXQgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgb2JqZWN0W1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIFwiICsgbG9jYWxWYXJBY2Nlc3NUb2tlblZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLnNldE9BdXRoVG9PYmplY3QgPSBzZXRPQXV0aFRvT2JqZWN0O1xuZnVuY3Rpb24gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBwYXJhbWV0ZXIsIGtleSA9IFwiXCIpIHtcbiAgICBpZiAocGFyYW1ldGVyID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXIuZm9yRWFjaChpdGVtID0+IHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgaXRlbSwga2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpLmZvckVhY2goY3VycmVudEtleSA9PiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIHBhcmFtZXRlcltjdXJyZW50S2V5XSwgYCR7a2V5fSR7a2V5ICE9PSAnJyA/ICcuJyA6ICcnfSR7Y3VycmVudEtleX1gKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh1cmxTZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHVybFNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLnNldChrZXksIHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICh1cmwsIC4uLm9iamVjdHMpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHNlYXJjaFBhcmFtcywgb2JqZWN0cyk7XG4gICAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xufTtcbmV4cG9ydHMuc2V0U2VhcmNoUGFyYW1zID0gc2V0U2VhcmNoUGFyYW1zO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXJpYWxpemVEYXRhSWZOZWVkZWQgPSBmdW5jdGlvbiAodmFsdWUsIHJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3Qgbm9uU3RyaW5nID0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJztcbiAgICBjb25zdCBuZWVkc1NlcmlhbGl6YXRpb24gPSBub25TdHJpbmcgJiYgY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmlzSnNvbk1pbWVcbiAgICAgICAgPyBjb25maWd1cmF0aW9uLmlzSnNvbk1pbWUocmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pXG4gICAgICAgIDogbm9uU3RyaW5nO1xuICAgIHJldHVybiBuZWVkc1NlcmlhbGl6YXRpb25cbiAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSlcbiAgICAgICAgOiAodmFsdWUgfHwgXCJcIik7XG59O1xuZXhwb3J0cy5zZXJpYWxpemVEYXRhSWZOZWVkZWQgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQ7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHRvUGF0aFN0cmluZyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufTtcbmV4cG9ydHMudG9QYXRoU3RyaW5nID0gdG9QYXRoU3RyaW5nO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBmdW5jdGlvbiAoYXhpb3NBcmdzLCBnbG9iYWxBeGlvcywgQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIChheGlvcyA9IGdsb2JhbEF4aW9zLCBiYXNlUGF0aCA9IEJBU0VfUEFUSCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGF4aW9zUmVxdWVzdEFyZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF4aW9zQXJncy5vcHRpb25zKSwgeyB1cmw6IChheGlvcy5kZWZhdWx0cy5iYXNlVVJMID8gJycgOiAoX2EgPSBjb25maWd1cmF0aW9uID09PSBudWxsIHx8IGNvbmZpZ3VyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ3VyYXRpb24uYmFzZVBhdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGJhc2VQYXRoKSArIGF4aW9zQXJncy51cmwgfSk7XG4gICAgICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGF4aW9zUmVxdWVzdEFyZ3MpO1xuICAgIH07XG59O1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBjcmVhdGVSZXF1ZXN0RnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/hub-api/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Farcaster Hub API\n * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.\n *\n * The version of the OpenAPI document: 2.35.0\n * Contact: team@neynar.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2h1Yi1hcGkvY29uZmlndXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVcsc0JBQXNCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC9odWItYXBpL2NvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRmFyY2FzdGVyIEh1YiBBUElcbiAqIFBlcmZvcm0gYmFzaWMgcXVlcmllcyBvZiBGYXJjYXN0ZXIgc3RhdGUgdmlhIHRoZSBSRVNUIEFQSSBvZiBhIEZhcmNhc3RlciBodWIuIFNlZSB0aGUgW05leW5hciBkb2NzXShodHRwczovL2RvY3MubmV5bmFyLmNvbS9yZWZlcmVuY2UpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDIuMzUuMFxuICogQ29udGFjdDogdGVhbUBuZXluYXIuY29tXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xuICAgICAgICB0aGlzLmFwaUtleSA9IHBhcmFtLmFwaUtleTtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHBhcmFtLnVzZXJuYW1lO1xuICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFyYW0ucGFzc3dvcmQ7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBwYXJhbS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHBhcmFtLmJhc2VQYXRoO1xuICAgICAgICB0aGlzLnNlcnZlckluZGV4ID0gcGFyYW0uc2VydmVySW5kZXg7XG4gICAgICAgIHRoaXMuYmFzZU9wdGlvbnMgPSBwYXJhbS5iYXNlT3B0aW9ucztcbiAgICAgICAgdGhpcy5mb3JtRGF0YUN0b3IgPSBwYXJhbS5mb3JtRGF0YUN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBNSU1FIGlzIGEgSlNPTiBNSU1FLlxuICAgICAqIEpTT04gTUlNRSBleGFtcGxlczpcbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGOFxuICAgICAqICAgQVBQTElDQVRJT04vSlNPTlxuICAgICAqICAgYXBwbGljYXRpb24vdm5kLmNvbXBhbnkranNvblxuICAgICAqIEBwYXJhbSBtaW1lIC0gTUlNRSAoTXVsdGlwdXJwb3NlIEludGVybmV0IE1haWwgRXh0ZW5zaW9ucylcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIE1JTUUgaXMgSlNPTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSnNvbk1pbWUobWltZSkge1xuICAgICAgICBjb25zdCBqc29uTWltZSA9IG5ldyBSZWdFeHAoJ14oYXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDsuKik/JCcsICdpJyk7XG4gICAgICAgIHJldHVybiBtaW1lICE9PSBudWxsICYmIChqc29uTWltZS50ZXN0KG1pbWUpIHx8IG1pbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvbicpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/hub-api/configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst requiredVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/package.json\").engines).node;\n// Check Node.js version before requiring/doing anything else\nif (!semver.satisfies(process.version, requiredVersion)) {\n    console.error(`Unsupported Node.js version! Your version: ${process.version}. Required version: ${requiredVersion}.`);\n    process.exit(1);\n}\n__exportStar(__webpack_require__(/*! ./clients */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/index.js\"), exports);\nvar configuration_1 = __webpack_require__(/*! ./clients/configuration */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/clients/configuration.js\");\nObject.defineProperty(exports, \"Configuration\", ({ enumerable: true, get: function () { return configuration_1.Configuration; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0Isd0JBQXdCLDRHQUFrQztBQUMxRDtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQixzQkFBc0IsZ0JBQWdCO0FBQ3RIO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUZBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDZFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw2RUFBUztBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQyx1R0FBeUI7QUFDdkQsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgcmVxdWlyZWRWZXJzaW9uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS5lbmdpbmVzLm5vZGU7XG4vLyBDaGVjayBOb2RlLmpzIHZlcnNpb24gYmVmb3JlIHJlcXVpcmluZy9kb2luZyBhbnl0aGluZyBlbHNlXG5pZiAoIXNlbXZlci5zYXRpc2ZpZXMocHJvY2Vzcy52ZXJzaW9uLCByZXF1aXJlZFZlcnNpb24pKSB7XG4gICAgY29uc29sZS5lcnJvcihgVW5zdXBwb3J0ZWQgTm9kZS5qcyB2ZXJzaW9uISBZb3VyIHZlcnNpb246ICR7cHJvY2Vzcy52ZXJzaW9ufS4gUmVxdWlyZWQgdmVyc2lvbjogJHtyZXF1aXJlZFZlcnNpb259LmApO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbn1cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGllbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xudmFyIGNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NsaWVudHMvY29uZmlndXJhdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ3VyYXRpb25fMS5Db25maWd1cmF0aW9uOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/types/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./webhooks */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/webhooks.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxtRkFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2FydmluL0RvY3VtZW50cy9Xb3JrIExvY2FsL1RoZSBDb21wYW55IExvY2FsL0V4dGVybmFsL1NpZ25hbENhc3Qvbm9kZV9tb2R1bGVzL0BuZXluYXIvbm9kZWpzLXNkay9idWlsZC90eXBlcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dlYmhvb2tzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/webhooks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/types/webhooks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL3R5cGVzL3dlYmhvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvYXJ2aW4vRG9jdW1lbnRzL1dvcmsgTG9jYWwvVGhlIENvbXBhbnkgTG9jYWwvRXh0ZXJuYWwvU2lnbmFsQ2FzdC9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL3R5cGVzL3dlYmhvb2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/types/webhooks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/utils/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./is-api-error-response */ \"(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/is-api-error-response.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2R0FBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvdXRpbHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pcy1hcGktZXJyb3ItcmVzcG9uc2VcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/is-api-error-response.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/build/utils/is-api-error-response.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isApiErrorResponse = void 0;\nconst axios_1 = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n/**\n * Utility for parsing errors returned by the Neynar API servers. Returns true\n * if the given error is caused by an error response from the server, and\n * narrows the type of `error` accordingly.\n */\nconst isApiErrorResponse = (\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nerror) => {\n    var _a;\n    if (!(error instanceof axios_1.AxiosError))\n        return false;\n    return ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== undefined && \"message\" in error.response.data;\n};\nexports.isApiErrorResponse = isApiErrorResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leW5hci9ub2RlanMtc2RrL2J1aWxkL3V0aWxzL2lzLWFwaS1lcnJvci1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnZpbi9Eb2N1bWVudHMvV29yayBMb2NhbC9UaGUgQ29tcGFueSBMb2NhbC9FeHRlcm5hbC9TaWduYWxDYXN0L25vZGVfbW9kdWxlcy9AbmV5bmFyL25vZGVqcy1zZGsvYnVpbGQvdXRpbHMvaXMtYXBpLWVycm9yLXJlc3BvbnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FwaUVycm9yUmVzcG9uc2UgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gcmVxdWlyZShcImF4aW9zXCIpO1xuLyoqXG4gKiBVdGlsaXR5IGZvciBwYXJzaW5nIGVycm9ycyByZXR1cm5lZCBieSB0aGUgTmV5bmFyIEFQSSBzZXJ2ZXJzLiBSZXR1cm5zIHRydWVcbiAqIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBjYXVzZWQgYnkgYW4gZXJyb3IgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBhbmRcbiAqIG5hcnJvd3MgdGhlIHR5cGUgb2YgYGVycm9yYCBhY2NvcmRpbmdseS5cbiAqL1xuY29uc3QgaXNBcGlFcnJvclJlc3BvbnNlID0gKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmVycm9yKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgYXhpb3NfMS5BeGlvc0Vycm9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKF9hID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gdW5kZWZpbmVkICYmIFwibWVzc2FnZVwiIGluIGVycm9yLnJlc3BvbnNlLmRhdGE7XG59O1xuZXhwb3J0cy5pc0FwaUVycm9yUmVzcG9uc2UgPSBpc0FwaUVycm9yUmVzcG9uc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@neynar/nodejs-sdk/build/utils/is-api-error-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@neynar/nodejs-sdk/package.json":
/*!******************************************************!*\
  !*** ./node_modules/@neynar/nodejs-sdk/package.json ***!
  \******************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@neynar/nodejs-sdk","version":"2.46.0","description":"SDK to interact with Neynar APIs (https://docs.neynar.com/reference/quickstart)","main":"./build/index.js","types":"./build/index.d.ts","files":["build/**/*","v1-to-v2-migration.md"],"scripts":{"clean":"del-cli ./build/*","build":"yarn run clean && tsc","generate:api":"del-cli src/api && openapi-generator-cli generate -i ./oas/src/v2/spec.yaml -g typescript-axios -o ./src/api --config ./openapi-generator-config.json --inline-schema-options \'REFACTOR_ALLOF_INLINE_SCHEMAS=true\'","generate:hub-api":"del-cli src/hub-api && openapi-generator-cli generate -i ./oas/src/hub-rest-api/spec.yaml -g typescript-axios -o ./src/hub-api --config ./openapi-generator-config.json --inline-schema-options \'REFACTOR_ALLOF_INLINE_SCHEMAS=true\'","generate":"yarn generate:api && yarn generate:hub-api","generate:api:wrapper":"cross-env CLIENT_TYPE=api ts-node -P tsconfig.scripts.json scripts/generate-wrapper.ts","generate:hub-api:wrapper":"cross-env CLIENT_TYPE=hub-api ts-node -P tsconfig.scripts.json scripts/generate-wrapper.ts","generate:wrapper":"yarn generate:api:wrapper && yarn generate:hub-api:wrapper","generate:all":"yarn generate && yarn generate:wrapper"},"author":"Neynar","license":"MIT","dependencies":{"@openapitools/openapi-generator-cli":"^2.14.1","semver":"^7.6.3","viem":"^2.21.44"},"devDependencies":{"@types/node":"^22.7.9","cross-env":"^7.0.3","del-cli":"^6.0.0","ts-node":"^10.9.2","typescript":"^5.6.3"},"engines":{"node":">=19.9.0"},"keywords":["ethereum","optimism","farcaster","neynar","nodejs"]}');

/***/ })

};
;